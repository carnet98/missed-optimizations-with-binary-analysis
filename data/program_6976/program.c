/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --no-bitfields --checksum --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-jumps --no-longlong --no-force-non-uniform-arrays --no-math64 --no-muls --packed-struct --paranoid --pointers --structs --inline-function --no-return-structs --no-arg-structs --no-dangling-global-pointers
 * Seed:      5349092656494899442
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   uint32_t  f0;
   int32_t  f1;
   int32_t  f2;
   uint32_t  f3;
   int32_t  f4;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int8_t g_6 = 0x0B;
static int32_t g_18 = 0x4F88039D;
static struct S1 g_64 = {0xFC6E20B3,1,0,0x74462D17,1};
static struct S1 *g_63 = &g_64;
static struct S1 g_101 = {1U,-10,0x8B304F1B,0xD962F93B,0xB47BED26};
static int32_t *g_103 = (void*)0;
static int32_t **g_102 = &g_103;
static struct S0 g_120 = {0x7D50A455,0x58EAAB99};
static int32_t g_187 = 0;
static struct S1 **g_210 = &g_63;
static struct S1 ***g_209 = &g_210;
static struct S1 ****g_229 = &g_209;
static struct S1 *****g_228 = &g_229;
static int32_t g_239 = 0xFE06BF84;
static struct S0 g_300 = {0x07A54B7A,4294967295U};


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
static int32_t * func_2(int32_t * p_3);
static int32_t * func_4(uint8_t  p_5);
inline static int16_t  func_7(int16_t  p_8, int32_t  p_9, int16_t  p_10, uint8_t  p_11, uint16_t  p_12);
inline static int16_t  func_23(uint16_t  p_24);
static uint8_t  func_27(int32_t * p_28, uint8_t  p_29, uint32_t  p_30);
inline static uint8_t  func_36(int32_t * p_37, uint32_t  p_38, uint32_t  p_39, uint32_t  p_40);
static int32_t * func_41(int32_t * p_42);
inline static int8_t  func_51(struct S0 * p_52);
static int32_t ** func_54(struct S0 * p_55, int32_t  p_56, struct S1 * p_57, int32_t  p_58);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_18 g_63 g_64.f0 g_64.f3 g_64.f4 g_102 g_103 g_101.f3 g_64.f1 g_120 g_101.f1 g_101.f2 g_64.f2 g_187 g_101.f0 g_209 g_228 g_239 g_101.f4 g_229
 * writes: g_6 g_64.f3 g_64.f2 g_64.f4 g_101 g_120 g_103 g_64.f1 g_18 g_64 g_210 g_300 g_187
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    struct S0 *l_334 = (void*)0;
    struct S0 **l_333 = &l_334;
    struct S0 ***l_335 = &l_333;
    int32_t *l_342 = &g_239;
    (*g_102) = func_2(func_4((6 <= 252U)));
    /* statement id: 191 */
    assert (g_103 == &g_101.f2 || g_103 == 0 || g_103 == &g_18);
    assert (g_210 == 0 || g_210 == &g_63);
    (*l_335) = l_333;
    for (g_187 = 16; (g_187 != 4); g_187 = safe_sub_func_uint32_t_u_u(g_187, 6))
    { /* block id: 195 */
        g_300 = g_120;
    }
    if ((0x8EA4B398 & 0x2192E822))
    { /* block id: 198 */
        for (g_101.f4 = 6; (g_101.f4 >= 28); g_101.f4 = safe_add_func_int16_t_s_s(g_101.f4, 1))
        { /* block id: 201 */
            int32_t l_340 = 0xC2C12560;
            int32_t *l_341 = &g_64.f2;
            (*l_341) = l_340;
        }
        (*g_102) = (*g_102);
    }
    else
    { /* block id: 205 */
        (*g_102) = l_342;
        /* statement id: 206 */
        assert (g_103 == &g_239);
        (*g_102) = (*g_102);
    }
    /* facts after branching */
    assert (g_103 == &g_239 || g_103 == &g_101.f2 || g_103 == 0 || g_103 == &g_18);
    return (*l_342);
}


/* ------------------------------------------ */
/* 
 * reads : g_102 g_103
 * writes: g_64.f2 g_103
 */
static int32_t * func_2(int32_t * p_3)
{ /* block id: 186 */
    struct S1 *l_323 = (void*)0;
    int32_t l_326 = 0x12BC8413;
    uint8_t l_332 = 0x11;
    p_3 = (*g_102);
    g_64.f2 = (((l_323 == l_323) != (safe_rshift_func_uint8_t_u_u(l_326, l_326))) & ((safe_unary_minus_func_uint32_t_u(l_326)) <= (safe_mod_func_int8_t_s_s(((0U ^ l_326) || (0x260B == ((safe_sub_func_int32_t_s_s((((4294967286U == l_326) >= 8) == 0x3C94A2A3), l_332)) <= (-1)))), l_332))));
    (*g_102) = p_3;
    return p_3;
    /* statement id: 190 */
    //assert (func_2_rv == &g_101.f2 || func_2_rv == 0 || func_2_rv == &g_18);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_18 g_63 g_64.f0 g_64.f3 g_64.f4 g_102 g_103 g_101.f3 g_64.f1 g_120 g_101.f1 g_101.f2 g_64.f2 g_187 g_101.f0 g_209 g_228 g_239 g_101.f4 g_229
 * writes: g_6 g_64.f3 g_64.f2 g_64.f4 g_101 g_120 g_103 g_64.f1 g_18 g_64 g_210 g_300
 */
static int32_t * func_4(uint8_t  p_5)
{ /* block id: 1 */
    int32_t *l_17 = &g_18;
    uint32_t l_173 = 1U;
    uint16_t l_193 = 0x1D99;
    struct S1 ***l_215 = &g_210;
    struct S1 ****l_220 = (void*)0;
    struct S1 *****l_219 = &l_220;
    struct S0 *l_276 = (void*)0;
    struct S0 *l_306 = (void*)0;
    struct S0 *l_307 = (void*)0;
    struct S0 *l_308 = &g_120;
    int8_t l_321 = 0xEC;
    int32_t *l_322 = (void*)0;
    if ((g_6 && (g_6 || (func_7((safe_rshift_func_int8_t_s_u(((safe_lshift_func_int16_t_s_u((l_17 == l_17), p_5)) != (safe_add_func_uint8_t_u_u((safe_sub_func_int8_t_s_s(((*l_17) & (func_23((safe_rshift_func_uint8_t_u_s(func_27(l_17, p_5, g_6), g_64.f0))) < p_5)), 0U)), 6U))), g_64.f0)), g_18, (*l_17), g_18, g_64.f0) == (*l_17)))))
    { /* block id: 92 */
        int32_t *l_148 = &g_101.f2;
        struct S1 **l_149 = (void*)0;
        (*l_17) = ((!(l_148 != (void*)0)) || ((void*)0 == l_149));
        if ((+(*l_17)))
        { /* block id: 94 */
            g_64.f2 = (safe_mod_func_int8_t_s_s((g_64.f1 & g_18), g_64.f3));
            return (*g_102);
            /* statement id: 96 */
            //assert (func_4_rv == 0 || func_4_rv == &g_18);
        }
        else
        { /* block id: 97 */
            (*l_148) = ((p_5 != ((+(safe_add_func_int16_t_s_s((safe_add_func_uint32_t_u_u(((~(p_5 < (*l_148))) <= (safe_rshift_func_uint8_t_u_u(((safe_lshift_func_int8_t_s_s((safe_lshift_func_int8_t_s_s((0x2E8C5F53 & (((safe_lshift_func_int16_t_s_u(((g_101.f3 | 0x6125DDC9) >= ((p_5 || ((safe_mod_func_int32_t_s_s(((safe_add_func_int16_t_s_s((g_64.f4 >= ((safe_add_func_uint16_t_u_u(p_5, g_101.f3)) || p_5)), (*l_17))) & 7), 4U)) ^ (*l_148))) & p_5)), l_173)) < (*l_148)) & p_5)), 0)), 5)) >= g_101.f1), 4))), 0xCB9547BA)), 0xA1BB))) | g_64.f4)) && g_64.f2);
            return (*g_102);
            /* statement id: 99 */
            //assert (func_4_rv == 0 || func_4_rv == &g_18);
        }
    }
    else
    { /* block id: 101 */
        uint16_t l_180 = 1U;
        struct S1 l_232 = {0U,0x97C7D5AE,0x717A6D3C,0xF17199E9,0x429188FF};
        int32_t *l_238 = &g_18;
        struct S1 ***l_253 = &g_210;
        uint8_t l_257 = 0U;
        struct S1 *****l_267 = &g_229;
        if ((((safe_sub_func_int8_t_s_s(((safe_mod_func_int32_t_s_s((g_64.f0 >= (safe_mod_func_uint32_t_u_u(p_5, p_5))), (l_180 | (safe_sub_func_int32_t_s_s((0xCABF || (*l_17)), (safe_add_func_int16_t_s_s((g_101.f3 < (((safe_mod_func_int16_t_s_s((l_17 != (*g_102)), p_5)) && l_180) & 0x51A9)), p_5))))))) | g_101.f3), 0x51)) >= l_180) <= g_187))
        { /* block id: 102 */
            struct S1 ****l_189 = (void*)0;
            struct S1 *****l_188 = &l_189;
            (*l_188) = (void*)0;
        }
        else
        { /* block id: 104 */
            int32_t l_192 = 0;
            struct S1 *****l_218 = (void*)0;
            int32_t *l_221 = &g_18;
            if (((safe_mod_func_int32_t_s_s(((((void*)0 != &g_103) != (((l_192 > (l_193 & g_120.f0)) & ((((*l_17) < (-1)) > ((!(((safe_mod_func_uint32_t_u_u(g_18, (safe_rshift_func_int16_t_s_s((safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s((safe_sub_func_uint32_t_u_u(((g_101.f1 || (*l_17)) & 0x9E), l_180)), 14)), (-1))), p_5)))) | 0x6390) <= p_5)) | 255U)) || g_101.f0)) | g_6)) ^ (*l_17)), p_5)) <= 0x0225))
            { /* block id: 105 */
                g_101.f2 = 0;
            }
            else
            { /* block id: 107 */
                int32_t *l_207 = &g_18;
                struct S1 ***l_208 = (void*)0;
                (*l_207) = ((((((safe_mod_func_int8_t_s_s(p_5, ((((((*g_102) == l_207) == (0x30A8829C || 2)) <= l_192) ^ (l_208 != g_209)) && g_64.f1))) | p_5) > 0x81) & 0U) != g_101.f0) ^ 0);
                (*l_17) = ((safe_rshift_func_int16_t_s_u(g_120.f0, (g_120.f0 | (((safe_lshift_func_uint8_t_u_u(((l_215 != &g_210) ^ 1U), 5)) ^ (safe_lshift_func_int8_t_s_s((&l_215 == &l_208), 3))) != (l_218 == l_219))))) > p_5);
            }
            (*g_102) = l_221;
            /* statement id: 111 */
            assert (g_103 == &g_18);
            (*l_17) = (safe_mod_func_int8_t_s_s((safe_add_func_int32_t_s_s((((safe_mod_func_int32_t_s_s((((0xAC852239 && g_101.f1) == ((*l_221) && 0x45B6)) || (l_180 >= (0x9C80 ^ ((g_228 == &g_229) & ((4294967289U | (*l_221)) ^ l_180))))), 1U)) >= 6) > (-1)), 4294967290U)), l_180));
        }
        for (l_193 = 0; (l_193 < 44); ++l_193)
        { /* block id: 116 */
            g_64.f2 = (l_180 || 9);
            (*g_63) = l_232;
        }
        (*l_17) = ((safe_add_func_int32_t_s_s(p_5, (((~(safe_sub_func_uint16_t_u_u(p_5, (*l_17)))) != g_101.f1) && (l_232.f3 >= l_232.f1)))) >= ((l_232.f0 > (l_17 != l_238)) || g_239));
        for (l_173 = 0; (l_173 < 48); l_173 = safe_add_func_uint32_t_u_u(l_173, 2))
        { /* block id: 123 */
            uint8_t l_242 = 0x29;
            uint32_t l_252 = 0x3DF59240;
            struct S1 *****l_268 = (void*)0;
            struct S0 l_301 = {5U,4294967290U};
            int32_t *l_303 = &g_101.f2;
            if (l_242)
                break;
            if ((safe_mod_func_uint8_t_u_u(((p_5 > ((~(safe_sub_func_uint32_t_u_u((249U > (safe_rshift_func_int8_t_s_s(0x11, 6))), p_5))) > (0xE62A && (((safe_rshift_func_uint8_t_u_u(0x2D, (*l_17))) == g_64.f1) < (((l_242 || 0xB1) || l_252) == 6))))) >= (*l_238)), (*l_17))))
            { /* block id: 125 */
                uint16_t l_264 = 0xFD4D;
                (*l_17) = (4 < (p_5 == ((((((void*)0 != l_253) ^ (!g_64.f2)) <= (safe_sub_func_uint16_t_u_u(p_5, 0x8ADF))) < ((((void*)0 != &g_229) || 1U) | l_257)) && 0x6F)));
                if (((g_120.f1 != ((safe_rshift_func_uint16_t_u_u((((safe_rshift_func_uint16_t_u_u(p_5, 14)) | ((safe_add_func_int16_t_s_s(l_242, (*l_17))) | (0xFE3C >= (2U && l_264)))) > (safe_add_func_int32_t_s_s(g_18, ((l_267 == l_268) | g_101.f4)))), (*l_17))) <= g_64.f4)) < p_5))
                { /* block id: 127 */
                    for (p_5 = 12; (p_5 > 24); p_5 = safe_add_func_int16_t_s_s(p_5, 6))
                    { /* block id: 130 */
                        (*l_17) = (*l_238);
                        (*g_102) = (*g_102);
                        return l_17;
                        /* statement id: 133 */
                        //assert (func_4_rv == &g_18);
                    }
                    if (p_5)
                        break;
                }
                else
                { /* block id: 136 */
                    (*l_17) = (0x64BD ^ g_64.f4);
                }
            }
            else
            { /* block id: 139 */
                int32_t *l_271 = &g_239;
                l_271 = func_41(l_271);
                /* statement id: 140 */
                assert (l_271 == &g_18);
                (***l_267) = (void*)0;
                /* statement id: 141 */
                assert (g_210 == 0);
                (*l_238) = (p_5 < (safe_lshift_func_uint8_t_u_s(p_5, 1)));
            }
            if ((safe_lshift_func_int8_t_s_u((l_276 != &g_120), p_5)))
            { /* block id: 144 */
                struct S0 *l_302 = &l_301;
                if (((safe_unary_minus_func_int32_t_s((~(g_101.f0 != (safe_rshift_func_uint8_t_u_u((safe_lshift_func_uint16_t_u_u(p_5, 13)), 6)))))) >= (safe_lshift_func_uint8_t_u_u((safe_mod_func_int32_t_s_s((*l_17), 0x6760B6CA)), (((0x4F | (&g_103 != (void*)0)) || 0U) && (((g_239 && g_101.f0) & g_64.f2) && l_252))))))
                { /* block id: 145 */
                    (*l_238) = (safe_rshift_func_int16_t_s_u(1, 9));
                    for (g_18 = (-12); (g_18 < 4); ++g_18)
                    { /* block id: 149 */
                        (*g_102) = func_41(l_238);
                        /* statement id: 150 */
                        assert (g_103 == &g_18);
                    }
                }
                else
                { /* block id: 152 */
                    int32_t *l_293 = &l_232.f2;
                    struct S0 l_299 = {0x99C1F599,0x488BF626};
                    for (l_232.f1 = (-20); (l_232.f1 == (-5)); l_232.f1++)
                    { /* block id: 155 */
                        (*g_102) = (*g_102);
                        l_293 = (*g_102);
                        /* statement id: 157 */
                        assert (l_293 == 0 || l_293 == &g_18);
                        (*g_102) = l_238;
                        /* statement id: 158 */
                        assert (g_103 == &g_18);
                        if ((**g_102))
                            break;
                    }
                    /* facts after for loop */
                    assert (l_293 == 0 || l_293 == &g_18 || l_293 == &l_232.f2);
                    if (l_242)
                    { /* block id: 161 */
                        (*l_17) = (~(safe_mod_func_uint8_t_u_u((safe_unary_minus_func_uint16_t_u(65530U)), g_64.f3)));
                        (*g_102) = l_293;
                        /* statement id: 163 */
                        assert (g_103 == 0 || g_103 == &g_18 || g_103 == &l_232.f2);
                        (*g_102) = l_17;
                        /* statement id: 164 */
                        assert (g_103 == &g_18);
                    }
                    else
                    { /* block id: 165 */
                        uint8_t l_298 = 0x7A;
                        (*l_17) = l_298;
                        g_300 = l_299;
                    }
                }
                if (p_5)
                    continue;
                (*l_302) = l_301;
            }
            else
            { /* block id: 172 */
                (*g_102) = l_303;
                /* statement id: 173 */
                assert (g_103 == &g_101.f2);
                return (*g_102);
                /* statement id: 174 */
                //assert (func_4_rv == &g_101.f2);
            }
        }
        /* facts after for loop */
        assert (g_210 == 0 || g_210 == &g_63);
    }
    /* facts after branching */
    assert (g_103 == 0 || g_103 == &g_18);
    assert (g_210 == 0 || g_210 == &g_63);
    for (g_101.f1 = 0; (g_101.f1 == 7); g_101.f1++)
    { /* block id: 180 */
        return l_17;
        /* statement id: 181 */
        //assert (func_4_rv == &g_18);
    }
    (*l_308) = g_120;
    (*l_17) = ((0x209D3674 && ((safe_add_func_uint8_t_u_u(p_5, (1 != (0xF0F2C868 < (safe_add_func_uint16_t_u_u(((*l_17) ^ (((g_6 ^ (safe_rshift_func_uint16_t_u_s((0x18 <= ((safe_lshift_func_uint8_t_u_u((((safe_mul_func_int32_t_s_s((safe_rshift_func_uint16_t_u_s(g_101.f4, 12)), ((0x23 >= g_64.f3) == (*l_17)))) > 0x5C) || (*l_17)), (*l_17))) < 0x04982AE6)), 14))) | l_321) && 0x4AF36F42)), p_5)))))) >= p_5)) < 0x48C4F69C);
    return l_322;
    /* statement id: 185 */
    //assert (func_4_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_64.f2 g_120.f0 g_64.f0 g_18
 * writes: g_64.f2
 */
inline static int16_t  func_7(int16_t  p_8, int32_t  p_9, int16_t  p_10, uint8_t  p_11, uint16_t  p_12)
{ /* block id: 89 */
    struct S0 *l_139 = &g_120;
    int32_t *l_146 = &g_64.f2;
    (*l_146) = ((l_139 == l_139) & (safe_add_func_int8_t_s_s((255U < g_64.f2), (((0x460C9FB3 ^ g_120.f0) <= (safe_rshift_func_uint16_t_u_u(g_64.f0, (safe_lshift_func_uint8_t_u_u(p_10, 3))))) > ((p_9 | p_8) ^ 2U)))));
    return g_18;
}


/* ------------------------------------------ */
/* 
 * reads : g_64.f1 g_102 g_101.f1 g_103 g_18 g_101.f2 g_64.f2
 * writes: g_64.f1 g_101 g_103 g_64.f2
 */
inline static int16_t  func_23(uint16_t  p_24)
{ /* block id: 49 */
    int16_t l_132 = 1;
    int32_t *l_133 = &g_18;
    int8_t l_138 = 0xC6;
    for (g_64.f1 = 0; (g_64.f1 != (-23)); g_64.f1--)
    { /* block id: 52 */
        struct S1 l_125 = {0U,1,0xE7C9D89B,0xA404EFFB,0};
        int32_t *l_128 = &g_18;
        struct S1 **l_130 = &g_63;
        if (p_24)
        { /* block id: 53 */
            struct S1 *l_126 = (void*)0;
            struct S1 *l_127 = &g_101;
            (*l_127) = l_125;
            (*g_102) = l_128;
            /* statement id: 55 */
            assert (g_103 == &g_18);
            return g_101.f1;
        }
        else
        { /* block id: 57 */
            int32_t *l_129 = (void*)0;
            struct S1 ***l_131 = &l_130;
            l_128 = func_41(l_129);
            (*l_131) = l_130;
            (*g_102) = (void*)0;
            /* statement id: 60 */
            assert (g_103 == 0);
            (*g_102) = l_129;
        }
        /* facts after branching */
        assert (g_103 == 0);
        if (l_132)
            continue;
        if (p_24)
        { /* block id: 64 */
            (*g_102) = func_41((*g_102));
            /* statement id: 65 */
            assert (g_103 == &g_18);
            if ((*l_128))
                continue;
        }
        else
        { /* block id: 67 */
            (*g_102) = l_133;
            /* statement id: 68 */
            assert (g_103 == &g_18);
            for (g_101.f2 = (-26); (g_101.f2 != 17); ++g_101.f2)
            { /* block id: 71 */
                for (g_64.f2 = (-27); (g_64.f2 > 13); ++g_64.f2)
                { /* block id: 74 */
                    if (l_138)
                    { /* block id: 75 */
                        if ((*g_103))
                            break;
                    }
                    else
                    { /* block id: 77 */
                        return g_64.f2;
                    }
                }
                (*g_102) = func_41(l_128);
                l_128 = func_41((*g_102));
                (*g_102) = func_41((*g_102));
            }
            return g_18;
        }
        /* facts after branching */
        assert (g_103 == &g_18);
    }
    /* facts after for loop */
    assert (g_103 == 0 || g_103 == &g_18);
    return (*l_133);
}


/* ------------------------------------------ */
/* 
 * reads : g_18 g_63 g_64.f0 g_64.f3 g_6 g_64.f4 g_102 g_103 g_101.f3 g_64.f1 g_120 g_101.f1
 * writes: g_6 g_64.f3 g_64.f2 g_64.f4 g_101 g_120 g_103
 */
static uint8_t  func_27(int32_t * p_28, uint8_t  p_29, uint32_t  p_30)
{ /* block id: 2 */
    struct S1 l_31 = {0xE2B79DC8,-1,0xCD1D2A6F,0xA4D91F06,0x85FCB444};
    struct S1 *l_32 = (void*)0;
    struct S1 *l_33 = &l_31;
    struct S0 *l_53 = (void*)0;
    (*l_33) = l_31;
    l_31.f2 = (((safe_rshift_func_uint8_t_u_u(func_36(func_41(&g_18), g_18, (safe_rshift_func_int8_t_s_s((((safe_lshift_func_uint8_t_u_u(p_30, 0)) > (safe_sub_func_int32_t_s_s(((0x6E9F81A7 >= (((p_30 | func_51(l_53)) >= (l_53 == l_53)) != l_31.f3)) < l_31.f0), g_18))) > g_64.f0), 5)), l_31.f1), 4)) & (*p_28)) <= 0xE1);
    /* statement id: 47 */
    assert (g_103 == &g_18);
    return g_101.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_102 g_64.f4
 * writes: g_103
 */
inline static uint8_t  func_36(int32_t * p_37, uint32_t  p_38, uint32_t  p_39, uint32_t  p_40)
{ /* block id: 44 */
    int32_t *l_122 = &g_64.f2;
    (*g_102) = func_41(func_41(l_122));
    /* statement id: 45 */
    assert (g_103 == &g_18);
    return g_64.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_41(int32_t * p_42)
{ /* block id: 4 */
    struct S0 l_43 = {0x2783DE76,9U};
    struct S0 *l_44 = &l_43;
    (*l_44) = l_43;
    return &g_18;
    /* statement id: 6 */
    //assert (func_41_rv == &g_18);
}


/* ------------------------------------------ */
/* 
 * reads : g_63 g_64.f0 g_18 g_64.f3 g_6 g_64.f4 g_102 g_103 g_101.f3 g_64.f1 g_120
 * writes: g_6 g_64.f3 g_64.f2 g_64.f4 g_101 g_120
 */
inline static int8_t  func_51(struct S0 * p_52)
{ /* block id: 7 */
    struct S0 *l_59 = (void*)0;
    int32_t l_62 = 0x1EB1ED30;
    int32_t **l_65 = (void*)0;
    struct S0 *l_121 = &g_120;
    l_65 = func_54(l_59, (safe_mod_func_int8_t_s_s(l_62, 251U)), g_63, (l_65 != l_65));
    /* statement id: 41 */
    assert (l_65 == &g_103);
    (*l_121) = g_120;
    return g_64.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_64.f0 g_18 g_64.f3 g_6 g_64.f4 g_102 g_103 g_101.f3 g_64.f1
 * writes: g_6 g_64.f3 g_64.f2 g_64.f4 g_101
 */
static int32_t ** func_54(struct S0 * p_55, int32_t  p_56, struct S1 * p_57, int32_t  p_58)
{ /* block id: 8 */
    int32_t *l_66 = &g_18;
    int32_t **l_67 = &l_66;
    int16_t l_78 = (-7);
    struct S0 l_117 = {0xDEA61E07,0x3A0897D5};
    (*l_67) = func_41(l_66);
    if ((4 | (0xD7 != ((safe_rshift_func_int16_t_s_u(p_58, ((((4U > (&l_66 == &l_66)) >= (safe_lshift_func_int16_t_s_u(g_64.f0, 1))) == 6) < ((safe_lshift_func_uint8_t_u_u((((safe_lshift_func_int8_t_s_s((safe_rshift_func_int16_t_s_u((*l_66), 9)), 5)) > g_64.f3) <= 0x36), g_64.f3)) || p_56)))) >= l_78))))
    { /* block id: 10 */
        int8_t l_96 = 1;
        (*l_67) = (void*)0;
        /* statement id: 11 */
        assert (l_66 == 0);
        for (l_78 = 15; (l_78 > 9); l_78 = safe_sub_func_int32_t_s_s(l_78, 2))
        { /* block id: 14 */
            int32_t l_92 = 0x815F77FB;
            int32_t **l_116 = &g_103;
            for (g_6 = 0; (g_6 < (-12)); --g_6)
            { /* block id: 17 */
                for (g_64.f3 = (-10); (g_64.f3 != 50); ++g_64.f3)
                { /* block id: 20 */
                    int32_t *l_97 = &g_64.f2;
                    struct S1 l_100 = {0U,0x60D0C570,0x93D6BDAD,4294967295U,0xF1EAAC29};
                    (*l_97) = ((p_58 != (safe_sub_func_int32_t_s_s((((safe_rshift_func_uint8_t_u_s(((0xCDC8 ^ p_58) <= (safe_add_func_uint16_t_u_u(((safe_unary_minus_func_uint32_t_u(l_92)) || 0xEFDF), g_18))), ((void*)0 != p_55))) < (+(safe_lshift_func_int8_t_s_s(((l_96 & g_6) < 0x17), 6)))) < g_18), 0x6E77A780))) ^ p_56);
                    for (g_64.f4 = 0; (g_64.f4 == (-1)); --g_64.f4)
                    { /* block id: 24 */
                        g_101 = l_100;
                        return g_102;
                        /* statement id: 26 */
                        //assert (func_54_rv == &g_103);
                    }
                    (*l_67) = (*g_102);
                }
            }
            (*l_67) = func_41((*g_102));
            /* statement id: 31 */
            assert (l_66 == &g_18);
            l_92 = ((((p_56 >= 4294967286U) < 0xCA839EF2) != (safe_sub_func_int8_t_s_s(((*l_66) > g_64.f3), (p_58 >= (!(~(~p_58))))))) <= (((!(safe_rshift_func_uint8_t_u_s((((safe_sub_func_uint8_t_u_u(1U, (safe_rshift_func_uint8_t_u_u(p_56, 7)))) && g_101.f3) ^ 0x09581AD2), 4))) > g_64.f1) > 0x94F5));
            return l_116;
            /* statement id: 33 */
            //assert (func_54_rv == &g_103);
        }
    }
    else
    { /* block id: 35 */
        struct S0 *l_118 = &l_117;
        int32_t **l_119 = &l_66;
        (*l_118) = l_117;
        l_119 = &l_66;
        (*l_67) = func_41((*g_102));
    }
    /* facts after branching */
    assert (l_66 == &g_18 || l_66 == 0);
    return &g_103;
    /* statement id: 40 */
    //assert (func_54_rv == &g_103);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_18, "g_18", print_hash_value);
    transparent_crc(g_64.f0, "g_64.f0", print_hash_value);
    transparent_crc(g_64.f1, "g_64.f1", print_hash_value);
    transparent_crc(g_64.f2, "g_64.f2", print_hash_value);
    transparent_crc(g_64.f3, "g_64.f3", print_hash_value);
    transparent_crc(g_64.f4, "g_64.f4", print_hash_value);
    transparent_crc(g_101.f0, "g_101.f0", print_hash_value);
    transparent_crc(g_101.f1, "g_101.f1", print_hash_value);
    transparent_crc(g_101.f2, "g_101.f2", print_hash_value);
    transparent_crc(g_101.f3, "g_101.f3", print_hash_value);
    transparent_crc(g_101.f4, "g_101.f4", print_hash_value);
    transparent_crc(g_120.f0, "g_120.f0", print_hash_value);
    transparent_crc(g_120.f1, "g_120.f1", print_hash_value);
    transparent_crc(g_187, "g_187", print_hash_value);
    transparent_crc(g_239, "g_239", print_hash_value);
    transparent_crc(g_300.f0, "g_300.f0", print_hash_value);
    transparent_crc(g_300.f1, "g_300.f1", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 59
   depth: 1, occurrence: 11
XXX total union variables: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 142
   depth: 2, occurrence: 30
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 3
   depth: 14, occurrence: 2
   depth: 15, occurrence: 5
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 72

XXX times a variable address is taken: 56
XXX times a pointer is dereferenced on RHS: 51
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 1
XXX times a pointer is dereferenced on LHS: 55
breakdown:
   depth: 1, occurrence: 54
   depth: 2, occurrence: 0
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 165

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 139
   level: 2, occurrence: 20
   level: 3, occurrence: 2
XXX number of pointers point to pointers: 25
XXX number of pointers point to scalars: 26
XXX number of pointers point to structs: 21
XXX percent of pointers has null in alias set: 37.5
XXX average alias set size: 1.24

XXX times a non-volatile is read: 352
XXX times a non-volatile is write: 143
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 127
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 20
   depth: 2, occurrence: 30
   depth: 3, occurrence: 18
   depth: 4, occurrence: 11
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 21.2
XXX percentage an existing variable is used: 78.8
********************* end of statistics **********************/

