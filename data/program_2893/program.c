/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-jumps --longlong --force-non-uniform-arrays --math64 --no-muls --no-packed-struct --paranoid --pointers --structs --no-inline-function --no-return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      7158551297057000003
 */

#include "csmith.h"

volatile uint64_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint64_t  f0;
   uint8_t  f1;
   uint64_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = (-1L);
static int8_t g_10 = 0L;
static int8_t g_23 = 0x91L;
static int8_t *g_22 = &g_23;
static uint16_t g_26 = 0UL;
static int64_t g_62 = (-6L);
static uint8_t g_72 = 0x8BL;
static int64_t g_74 = 0x911CCFE983D4F39ALL;
static int32_t g_76 = 1L;
static struct S0 g_84 = {18446744073709551613UL,7UL,0x954028E04799C819LL};
static uint16_t g_97 = 0x3ADDL;
static uint32_t g_115 = 2UL;
static int32_t g_118 = 0x6537570CL;
static struct S0 g_123 = {0x01F95A7F279EC88CLL,0x85L,0x2798E9ECA6A3F29ALL};
static int16_t g_150 = 0x3A6BL;
static int32_t *g_202 = &g_76;
static uint64_t *g_220 = &g_84.f0;
static uint16_t *g_238 = &g_97;
static uint16_t **g_237 = &g_238;
static int32_t g_261 = 0x518A1B9CL;
static uint32_t g_329 = 0x76915BE6L;
static struct S0 g_401 = {0x5374227142950DD1LL,5UL,8UL};


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
static int32_t * const  func_5(int8_t  p_6, uint64_t  p_7, int32_t  p_8);
static int32_t  func_11(uint8_t  p_12, int8_t * p_13, int32_t * p_14, int32_t  p_15);
static uint8_t  func_16(uint8_t  p_17, int32_t * p_18, int32_t * p_19, const uint64_t  p_20, int32_t  p_21);
static int32_t * func_27(int32_t  p_28, struct S0  p_29, int32_t  p_30);
static int32_t  func_31(int8_t * p_32);
static int8_t * func_33(uint64_t  p_34, uint8_t * p_35);
static uint32_t  func_39(int8_t  p_40, int8_t * p_41);
static int8_t  func_42(int8_t  p_43);
static int32_t * func_51(int8_t * p_52, uint8_t  p_53);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_22 g_23 g_72 g_62 g_97 g_123 g_76 g_84.f1 g_150 g_84.f0 g_115 g_118 g_220 g_202 g_84 g_237 g_238 g_10
 * writes: g_2 g_10 g_26 g_62 g_72 g_74 g_76 g_84 g_97 g_115 g_118 g_123 g_150 g_23 g_202 g_237 g_261
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_24 = 0xB2C57E71L;
    const int32_t l_50 = 0xF08877E0L;
    int32_t l_122 = 0x5C702051L;
    const uint16_t *l_280 = &g_97;
    const uint16_t **l_279 = &l_280;
    const uint16_t ***l_278 = &l_279;
    int32_t **l_297 = &g_202;
    int32_t ***l_296 = &l_297;
    int32_t l_310 = 0x19DF5A9DL;
    uint16_t l_318 = 0x9448L;
    uint32_t l_320 = 4294967295UL;
    uint64_t l_330 = 0x7632F3C2238E3D9CLL;
    int32_t l_381 = 0x8269F73CL;
    for (g_2 = (-28); (g_2 <= (-16)); g_2++)
    { /* block id: 3 */
        int8_t *l_9 = &g_10;
        uint8_t *l_25 = (void*)0;
        const int32_t l_85 = 0x128B415AL;
        int32_t *l_120 = (void*)0;
        int32_t *l_121 = &g_76;
        int32_t **l_276 = (void*)0;
        int32_t **l_277 = &l_121;
        const uint16_t ****l_281 = &l_278;
        int64_t *l_294 = &g_62;
        int16_t *l_295 = &g_150;
        (*l_277) = func_5(((*l_9) = 8L), g_2, func_11(func_16((g_26 = (l_24 = ((void*)0 != g_22))), func_27((l_122 = ((*l_121) = func_31(func_33((safe_unary_minus_func_int32_t_s((safe_mod_func_uint32_t_u_u(((func_39((*g_22), l_25) >= g_23) & func_42((safe_sub_func_int8_t_s_s((safe_div_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(((void*)0 != g_22), l_50)), g_23)), (-8L))))), l_85)))), g_22)))), g_123, l_50), &g_2, g_23, g_23), g_22, &g_2, g_2));
        /* statement id: 134 */
        assert (l_121 == &g_76 || l_121 == &g_118);
        (*g_202) = ((&g_237 == ((*l_281) = l_278)) == ((*g_202) && (safe_sub_func_uint32_t_u_u((safe_mod_func_int16_t_s_s((254UL && (g_2 ^ (safe_rshift_func_uint16_t_u_u(((safe_mod_func_int16_t_s_s(((*l_295) = ((0x75F4AB859C66F5C5LL == (safe_rshift_func_uint16_t_u_u(((l_294 != &g_62) != g_72), l_50))) <= (**l_277))), l_122)) & 0L), (**g_237))))), 0xA90BL)), g_72))));
    }
    /* facts after for loop */
    assert (g_202 == &g_76 || g_202 == &g_118);
    (*l_296) = &g_202;
    for (g_72 = 12; (g_72 <= 42); ++g_72)
    { /* block id: 142 */
        const uint32_t l_317 = 18446744073709551609UL;
        uint8_t *l_319 = &g_123.f1;
        int32_t *l_321 = (void*)0;
        int32_t *l_322 = (void*)0;
        int32_t *l_323 = &g_2;
        const int8_t l_324 = (-5L);
        uint32_t *l_331 = &l_24;
        uint32_t *l_332 = (void*)0;
        uint32_t *l_333 = &l_320;
        const int32_t ***l_334 = (void*)0;
    }
    return (***l_296);
}


/* ------------------------------------------ */
/* 
 * reads : g_202 g_76 g_118 g_220 g_237 g_22 g_23 g_84.f0 g_123.f1 g_238 g_97 g_10 g_115 g_62 g_84.f1
 * writes: g_76 g_118 g_84.f0 g_237 g_261 g_123 g_202
 */
static int32_t * const  func_5(int8_t  p_6, uint64_t  p_7, int32_t  p_8)
{ /* block id: 109 */
    uint16_t l_233 = 0x7361L;
    int32_t *l_272 = &g_76;
    (*g_202) = (~p_6);
    l_233 = (*g_202);
    if ((safe_unary_minus_func_uint64_t_u((safe_rshift_func_uint16_t_u_u((((*g_220) = 0UL) && 0UL), 15)))))
    { /* block id: 113 */
        uint16_t ***l_239 = &g_237;
        int32_t l_258 = 0x65C23F69L;
        struct S0 l_262 = {5UL,255UL,1UL};
        int32_t **l_269 = &g_202;
        (*l_239) = g_237;
        g_261 = (((*g_22) & (((safe_add_func_int8_t_s_s(((safe_lshift_func_int16_t_s_s(((*g_220) > ((safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(((safe_sub_func_uint64_t_u_u((*g_220), g_123.f1)) < ((-1L) & ((*g_202) = (p_6 & (safe_mod_func_uint8_t_u_u(((safe_div_func_int32_t_s_s((*g_202), (safe_mod_func_uint64_t_u_u((p_7 = l_258), (safe_lshift_func_uint16_t_u_u((((((l_258 != g_123.f1) ^ 0x55L) < 6L) && (*g_238)) > (**g_237)), 11)))))) <= 0x0FFB38DBL), (-5L))))))), g_10)), (**g_237))) <= (*g_238))), 15)) || g_115), 0x93L)) >= g_123.f1) > (*g_22))) < 4294967295UL);
        (*l_269) = func_27(l_233, l_262, ((*g_202) = (safe_lshift_func_int16_t_s_u((safe_sub_func_uint16_t_u_u((**g_237), 65535UL)), ((safe_div_func_int16_t_s_s((((*g_220) = (((&p_8 != &p_8) >= l_262.f2) || ((0xBA9BF42089E89AD7LL < (0UL >= l_262.f2)) && (*g_22)))) & l_262.f0), g_10)) & g_62)))));
        /* statement id: 120 */
        assert (g_202 == &g_118);
        return (*l_269);
        /* statement id: 121 */
        //assert (func_5_rv == &g_118);
    }
    else
    { /* block id: 122 */
        for (p_7 = 0; (p_7 >= 18); p_7 = safe_add_func_int16_t_s_s(p_7, 2))
        { /* block id: 125 */
            int32_t **l_273 = &l_272;
            (*l_273) = l_272;
            if (p_6)
                break;
            if ((*g_202))
                continue;
            g_118 = ((**l_273) = (safe_rshift_func_int8_t_s_u(p_8, g_84.f1)));
        }
    }
    return l_272;
    /* statement id: 133 */
    //assert (func_5_rv == &g_76);
}


/* ------------------------------------------ */
/* 
 * reads : g_84 g_2 g_202
 * writes: g_84 g_123 g_76 g_118
 */
static int32_t  func_11(uint8_t  p_12, int8_t * p_13, int32_t * p_14, int32_t  p_15)
{ /* block id: 103 */
    struct S0 l_226 = {0xE53CA36A7B885A69LL,0x67L,18446744073709551615UL};
    struct S0 *l_227 = (void*)0;
    struct S0 *l_228 = &g_84;
    int32_t l_229 = 0x1378FC94L;
    (*l_228) = l_226;
    g_123 = g_84;
    (*g_202) = (((l_229 = 0xE57EE2591527C6EFLL) ^ (safe_mod_func_uint64_t_u_u(0x5A1EA19F92D8F591LL, p_12))) < (*p_14));
    return (*p_14);
}


/* ------------------------------------------ */
/* 
 * reads : g_84.f0 g_76 g_84.f1 g_150 g_22 g_23 g_2 g_115 g_118 g_123.f1 g_220 g_202
 * writes: g_84.f0 g_118 g_97 g_150 g_84.f2 g_115 g_23 g_62 g_123.f0 g_202 g_76
 */
static uint8_t  func_16(uint8_t  p_17, int32_t * p_18, int32_t * p_19, const uint64_t  p_20, int32_t  p_21)
{ /* block id: 50 */
    uint64_t l_141 = 18446744073709551612UL;
    int32_t l_143 = 1L;
    int8_t l_147 = 0x51L;
    struct S0 *l_188 = &g_123;
    int32_t *l_223 = &l_143;
    for (g_84.f0 = 0; (g_84.f0 < 53); ++g_84.f0)
    { /* block id: 53 */
        uint16_t *l_144 = &g_97;
        const int32_t l_148 = 1L;
        int16_t *l_149 = &g_150;
        int32_t l_153 = 0x6F30DCE9L;
        const int16_t l_168 = 5L;
        int32_t *l_196 = &g_118;
        int32_t **l_195 = &l_196;
        p_21 = (safe_div_func_uint64_t_u_u(0UL, (safe_sub_func_int16_t_s_s((safe_mod_func_int16_t_s_s(((*l_149) = (((+(safe_sub_func_int16_t_s_s(((safe_add_func_int32_t_s_s((l_141 = (safe_lshift_func_int16_t_s_u(g_76, 3))), ((*p_18) = (+p_20)))) || ((void*)0 != &g_118)), g_84.f1))) & ((*l_144) = l_143)) < (safe_add_func_uint64_t_u_u(l_147, l_148)))), 0xFB56L)), 0x31A1L))));
        for (g_84.f2 = 11; (g_84.f2 >= 56); g_84.f2 = safe_add_func_int32_t_s_s(g_84.f2, 8))
        { /* block id: 61 */
            uint8_t l_169 = 251UL;
            if ((l_153 = 0xBC0B8426L))
            { /* block id: 63 */
                uint64_t l_162 = 1UL;
                uint32_t *l_167 = &g_115;
                int32_t l_170 = 6L;
                l_170 = ((safe_rshift_func_int8_t_s_u((safe_div_func_int8_t_s_s(((g_150 != (-5L)) | (safe_div_func_int8_t_s_s((l_162 == (((*g_22) = (safe_sub_func_int16_t_s_s(((1UL >= (p_20 >= (*g_22))) && ((safe_div_func_uint16_t_u_u((l_141 > (((((*l_167) = p_20) > (l_144 != (void*)0)) != l_148) | 0x70F7L)), l_168)) <= (*g_22))), 65532UL))) <= g_150)), l_169))), g_84.f0)), 5)) == p_17);
            }
            else
            { /* block id: 67 */
                return g_150;
            }
            if ((*p_19))
            { /* block id: 70 */
                return g_115;
            }
            else
            { /* block id: 72 */
                int8_t l_197 = 0L;
                int32_t l_201 = 1L;
                int64_t l_218 = 1L;
                for (g_62 = 0; (g_62 < 8); ++g_62)
                { /* block id: 75 */
                    int64_t l_177 = 0xB76DB0F7197FE5D2LL;
                    int32_t *l_179 = (void*)0;
                    int32_t **l_178 = &l_179;
                    int64_t *l_198 = (void*)0;
                    int64_t *l_199 = &l_177;
                    uint64_t *l_200 = &g_123.f0;
                    int64_t l_222 = (-2L);
                    if (l_143)
                    { /* block id: 76 */
                        int32_t **l_173 = (void*)0;
                        int32_t **l_174 = (void*)0;
                        int32_t *l_176 = &l_153;
                        int32_t **l_175 = &l_176;
                        (*l_175) = &p_21;
                        /* statement id: 77 */
                        assert (l_176 == &p_21);
                        (*p_18) = l_147;
                    }
                    else
                    { /* block id: 79 */
                        return l_177;
                    }
                    (*l_178) = &p_21;
                    /* statement id: 82 */
                    assert (l_179 == &p_21);
                    if (((((((safe_mod_func_uint32_t_u_u((((safe_div_func_int32_t_s_s((0UL < (safe_mod_func_int16_t_s_s((safe_sub_func_uint64_t_u_u(((&g_84 != l_188) && l_147), ((*l_200) = (safe_div_func_int8_t_s_s(((((safe_mod_func_uint64_t_u_u(p_17, g_76)) != l_169) == ((*l_199) = (safe_lshift_func_int16_t_s_u(p_21, (l_197 = (l_195 != &p_19)))))) ^ g_115), 0xB5L))))), 0xBA64L))), l_169)) ^ (-7L)) ^ l_201), 1L)) != 0xC490E50DD9F3165BLL) >= (**l_178)) != (*p_19)) < l_169) >= (*l_196)))
                    { /* block id: 86 */
                        uint64_t **l_219 = &l_200;
                        uint64_t l_221 = 18446744073709551606UL;
                        (*l_178) = (g_202 = (*l_195));
                        /* statement id: 88 */
                        assert (g_202 == &g_118);
                        assert (l_179 == &g_118);
                        (*g_202) = (safe_unary_minus_func_uint64_t_u(((((safe_rshift_func_int8_t_s_s(0xDAL, 7)) >= (0x333B9D5F1929AE18LL && (((safe_div_func_int8_t_s_s(((0L && ((+(safe_unary_minus_func_int32_t_s((-9L)))) >= ((safe_sub_func_int16_t_s_s(p_17, (safe_mod_func_int16_t_s_s((g_123.f1 == p_21), ((((safe_div_func_uint8_t_u_u((l_218 >= (((*l_219) = (void*)0) == g_220)), g_118)) && l_221) && g_84.f1) && p_21))))) < l_222))) || 0x09D23E52L), p_17)) != l_143) || (*g_220)))) != 0xE8CDL) != l_221)));
                        /* statement id: 90 */
                        assert (l_200 == &g_123.f0 || l_200 == 0);
                    }
                    else
                    { /* block id: 91 */
                        if ((*p_19))
                            break;
                        (*l_178) = &g_118;
                        /* statement id: 93 */
                        assert (l_179 == &g_118);
                    }
                    /* facts after branching */
                    assert (l_179 == &g_118);
                    assert (l_200 == &g_123.f0 || l_200 == 0);
                }
            }
            l_223 = (void*)0;
            /* statement id: 97 */
            assert (l_223 == 0);
        }
        (*g_202) = (**l_195);
        (*g_202) = (safe_lshift_func_int8_t_s_u(p_20, 2));
    }
    /* facts after for loop */
    assert (l_223 == 0 || l_223 == &l_143);
    return g_118;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_123
 */
static int32_t * func_27(int32_t  p_28, struct S0  p_29, int32_t  p_30)
{ /* block id: 47 */
    struct S0 l_124 = {1UL,0x85L,0xA07B4D734B0E876FLL};
    struct S0 *l_125 = &g_123;
    (*l_125) = l_124;
    return &g_118;
    /* statement id: 49 */
    //assert (func_27_rv == &g_118);
}


/* ------------------------------------------ */
/* 
 * reads : g_97
 * writes:
 */
static int32_t  func_31(int8_t * p_32)
{ /* block id: 42 */
    uint16_t l_119 = 0x5E4DL;
    l_119 = 0x9A65E11EL;
    return g_97;
}


/* ------------------------------------------ */
/* 
 * reads : g_76 g_22 g_23 g_2
 * writes: g_76 g_97 g_115 g_118
 */
static int8_t * func_33(uint64_t  p_34, uint8_t * p_35)
{ /* block id: 25 */
    uint64_t l_103 = 0x948C0F44DC86549ELL;
    int32_t *l_113 = &g_2;
    for (g_76 = 0; (g_76 <= 8); ++g_76)
    { /* block id: 28 */
        int64_t *l_90 = &g_74;
        int64_t *l_92 = (void*)0;
        int8_t *l_102 = (void*)0;
        int32_t l_106 = (-6L);
        int32_t *l_112 = &g_2;
        uint32_t *l_114 = &g_115;
        int32_t l_116 = 0x1824DA47L;
        int32_t *l_117 = &g_118;
        if (p_34)
            break;
        for (p_34 = 15; (p_34 == 15); p_34 = safe_add_func_uint16_t_u_u(p_34, 6))
        { /* block id: 32 */
            int64_t **l_91 = &l_90;
            int64_t **l_93 = &l_92;
            int32_t *l_94 = (void*)0;
            int32_t *l_95 = (void*)0;
            int32_t *l_96 = (void*)0;
            g_97 = ((253UL && (((*l_91) = l_90) == (void*)0)) != (((*l_93) = l_92) == &g_74));
        }
        (*l_117) = (safe_mod_func_uint64_t_u_u((safe_div_func_int32_t_s_s((((l_103 = ((void*)0 == l_102)) != (p_34 != ((safe_add_func_int8_t_s_s(l_106, (!((p_34 < (0x95D3L <= (-1L))) < ((*l_114) = (safe_add_func_uint32_t_u_u((p_34 && (safe_lshift_func_int16_t_s_u(((l_112 != l_113) == 0xDE648FB3L), p_34))), 0x415B52D1L))))))) == 1UL))) > (*g_22)), (*l_113))), l_116));
    }
    return &g_23;
    /* statement id: 41 */
    //assert (func_33_rv == &g_23);
}


/* ------------------------------------------ */
/* 
 * reads : g_2
 * writes:
 */
static uint32_t  func_39(int8_t  p_40, int8_t * p_41)
{ /* block id: 7 */
    return g_2;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_22 g_23 g_72 g_62
 * writes: g_62 g_72 g_74 g_76 g_84
 */
static int8_t  func_42(int8_t  p_43)
{ /* block id: 9 */
    int8_t *l_54 = &g_23;
    int32_t l_56 = 0x4286A4ABL;
    int32_t *l_82 = (void*)0;
    int32_t **l_81 = &l_82;
    struct S0 l_83 = {0x1C9C8A038AA138A8LL,0x04L,3UL};
    (*l_81) = func_51(l_54, (+l_56));
    /* statement id: 21 */
    assert (l_82 == &g_2);
    l_83 = (g_84 = l_83);
    return (*g_22);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_22 g_23 g_72 g_62
 * writes: g_62 g_72 g_74 g_76
 */
static int32_t * func_51(int8_t * p_52, uint8_t  p_53)
{ /* block id: 10 */
    int32_t l_60 = 0x6DAAFD55L;
    int64_t *l_61 = &g_62;
    int16_t l_69 = 3L;
    uint8_t *l_70 = (void*)0;
    uint8_t *l_71 = &g_72;
    int64_t *l_73 = &g_74;
    int32_t *l_75 = &g_76;
    int32_t **l_77 = (void*)0;
    int32_t **l_78 = &l_75;
    int8_t l_79 = 1L;
    int32_t *l_80 = &l_60;
    (*l_75) = ((~(safe_div_func_int64_t_s_s((((l_60 = ((((*l_61) = l_60) <= (safe_sub_func_int16_t_s_s((safe_add_func_int32_t_s_s((0x205EL && 0xD1F2L), ((((*l_73) = (((*l_71) = (((g_2 && (g_22 == g_22)) & ((safe_div_func_uint64_t_u_u(l_69, g_2)) == g_23)) != l_69)) <= (-1L))) | p_53) && 0x1D4B4EA65D3384F7LL))), 6L))) < 0xFFFBC9EE52129E5ELL)) ^ g_23) ^ 0x6BC6715623A55A41LL), 0xD96456CFC4FF2D4ELL))) && g_72);
    (*l_75) = g_62;
    (*l_78) = &l_60;
    /* statement id: 17 */
    assert (l_75 == &l_60);
    (*l_80) = (l_79 == (((*l_78) = (*l_78)) == (void*)0));
    return &g_2;
    /* statement id: 20 */
    //assert (func_51_rv == &g_2);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_2;
    csmith_sink_ = g_10;
    csmith_sink_ = g_23;
    csmith_sink_ = g_26;
    csmith_sink_ = g_62;
    csmith_sink_ = g_72;
    csmith_sink_ = g_74;
    csmith_sink_ = g_76;
    csmith_sink_ = g_84.f0;
    csmith_sink_ = g_84.f1;
    csmith_sink_ = g_84.f2;
    csmith_sink_ = g_97;
    csmith_sink_ = g_115;
    csmith_sink_ = g_118;
    csmith_sink_ = g_123.f0;
    csmith_sink_ = g_123.f1;
    csmith_sink_ = g_123.f2;
    csmith_sink_ = g_150;
    csmith_sink_ = g_261;
    csmith_sink_ = g_329;
    csmith_sink_ = g_401.f0;
    csmith_sink_ = g_401.f1;
    csmith_sink_ = g_401.f2;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 65
   depth: 1, occurrence: 7
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 12
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 97

XXX times a variable address is taken: 95
XXX times a pointer is dereferenced on RHS: 66
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 12
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 76
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 181

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 280
   level: 2, occurrence: 28
   level: 3, occurrence: 7
XXX number of pointers point to pointers: 28
XXX number of pointers point to scalars: 62
XXX number of pointers point to structs: 7
XXX percent of pointers has null in alias set: 23.7
XXX average alias set size: 1.11

XXX times a non-volatile is read: 342
XXX times a non-volatile is write: 193
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 65
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 14
   depth: 2, occurrence: 8
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 22.9
XXX percentage an existing variable is used: 77.1
********************* end of statistics **********************/

