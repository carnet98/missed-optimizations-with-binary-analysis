/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --checksum --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-jumps --no-longlong --force-non-uniform-arrays --no-math64 --no-muls --packed-struct --paranoid --pointers --structs --no-inline-function --no-return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      7323910467221326348
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   unsigned f1 : 1;
   int8_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 1;
static int32_t g_8 = 0x845D811F;
static int32_t **g_16 = (void*)0;
static int32_t g_63 = (-8);
static int32_t ***g_78 = &g_16;
static int32_t ****g_77 = &g_78;
static int32_t *****g_76 = &g_77;
static struct S0 g_81 = {0xA4792D8C,0,-9};
static int32_t g_84 = (-2);
static uint16_t g_121 = 0xCD2C;
static struct S0 *g_182 = (void*)0;
static struct S0 **g_181 = &g_182;
static struct S0 ***g_180 = &g_181;
static uint32_t g_214 = 4U;
static uint32_t g_356 = 0xE4B26791;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static int32_t * func_13(int32_t  p_14, int32_t ** p_15);
static int32_t * func_17(uint32_t  p_18);
static int32_t * func_24(int32_t **** p_25, int32_t ** p_26);
static int32_t **** func_27(int8_t  p_28, struct S0  p_29, int32_t **** p_30, int32_t * p_31);
static uint16_t  func_32(uint32_t  p_33, int32_t *** p_34);
static uint32_t  func_35(int32_t  p_36, int16_t  p_37, int32_t  p_38);
static int8_t  func_41(int32_t * p_42, uint32_t  p_43);
static int32_t * func_44(int32_t **** p_45, int32_t *** p_46, int32_t **** p_47, int32_t **** p_48);
static int32_t **** func_49(int32_t ** p_50, int16_t  p_51, int8_t  p_52, uint32_t  p_53);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_8 g_16 g_121 g_81.f2
 * writes: g_2 g_8 g_84 g_121 g_63
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    int32_t ***l_11 = (void*)0;
    int32_t *l_359 = (void*)0;
    int32_t **l_360 = (void*)0;
    int32_t **l_361 = &l_359;
    struct S0 *l_380 = &g_81;
    struct S0 *****l_384 = (void*)0;
    for (g_2 = 0; (g_2 >= 25); ++g_2)
    { /* block id: 3 */
        int32_t *l_5 = (void*)0;
        int32_t **l_6 = (void*)0;
        int32_t **l_7 = &l_5;
        (*l_7) = l_5;
        for (g_8 = 0; (g_8 <= 17); g_8++)
        { /* block id: 7 */
            int32_t ****l_12 = &l_11;
            (*l_12) = l_11;
            (*l_7) = func_13(g_8, g_16);
            /* statement id: 141 */
            assert (l_5 == &g_8);
        }
        /* facts after for loop */
        assert (l_5 == &g_8 || l_5 == 0);
        l_359 = (*l_7);
    }
    /* facts after for loop */
    assert (l_359 == &g_8 || l_359 == 0);
    (*l_361) = l_359;
    for (g_121 = (-27); (g_121 < 54); g_121 = safe_add_func_uint16_t_u_u(g_121, 7))
    { /* block id: 148 */
        int32_t *l_364 = &g_8;
        l_364 = l_364;
    }
    for (g_8 = (-5); (g_8 > 0); g_8 = safe_add_func_int32_t_s_s(g_8, 2))
    { /* block id: 153 */
        int32_t l_370 = (-1);
        struct S0 ****l_383 = &g_180;
        struct S0 *****l_382 = &l_383;
        for (g_84 = (-27); (g_84 >= (-7)); g_84++)
        { /* block id: 156 */
            int8_t l_369 = 0xD9;
            int32_t *l_371 = &g_84;
            int32_t *l_372 = &g_63;
            g_2 = (((0x5950CD63 > l_369) , &g_181) == (l_370 , &g_181));
            if (l_369)
            { /* block id: 158 */
                (*l_361) = (void*)0;
                /* statement id: 159 */
                assert (l_359 == 0);
            }
            else
            { /* block id: 160 */
                (*l_361) = l_371;
                /* statement id: 161 */
                assert (l_359 == &g_84);
                if (l_370)
                    break;
            }
            /* facts after branching */
            assert (l_359 == &g_84 || l_359 == 0);
            (*l_372) = l_370;
        }
        for (g_2 = 0; (g_2 >= (-14)); g_2 = safe_sub_func_int16_t_s_s(g_2, 1))
        { /* block id: 168 */
            int8_t l_375 = 1;
            struct S0 *l_381 = (void*)0;
            int32_t *l_385 = (void*)0;
            if (l_375)
                break;
            g_84 = (safe_rshift_func_uint16_t_u_s((safe_add_func_uint8_t_u_u((l_380 == l_381), (l_382 != (g_121 , ((&g_77 != (void*)0) , l_384))))), 11));
        }
    }
    /* facts after for loop */
    assert (l_359 == &g_84 || l_359 == 0 || l_359 == &g_8);
    return g_81.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_2
 * writes: g_84
 */
static int32_t * func_13(int32_t  p_14, int32_t ** p_15)
{ /* block id: 9 */
    int32_t *l_358 = &g_63;
    l_358 = func_17(g_2);
    /* statement id: 139 */
    assert (l_358 == &g_8);
    return l_358;
    /* statement id: 140 */
    //assert (func_13_rv == &g_8);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_84
 */
static int32_t * func_17(uint32_t  p_18)
{ /* block id: 10 */
    int32_t *l_149 = &g_8;
    int32_t **l_148 = &l_149;
    int32_t l_195 = (-3);
    struct S0 l_197 = {4294967286U,0,0xD5};
    int8_t l_225 = 0x37;
    int32_t ****l_237 = &g_78;
    uint16_t l_277 = 0xBEAF;
    int32_t *l_289 = &g_84;
    int8_t l_337 = 4;
    struct S0 ****l_338 = &g_180;
    uint16_t l_354 = 1U;
    for (p_18 = (-25); (p_18 > 57); ++p_18)
    { /* block id: 13 */
        int16_t l_21 = 0x8905;
        int32_t *l_126 = &g_2;
        uint16_t l_234 = 4U;
        int32_t ****l_238 = &g_78;
        int32_t **l_247 = (void*)0;
        struct S0 ***l_273 = &g_181;
        int32_t *l_287 = &g_8;
        struct S0 *****l_339 = &l_338;
        uint8_t l_355 = 253U;
        int32_t *l_357 = &g_63;
    }
    (*l_289) = 0;
    return &g_8;
    /* statement id: 138 */
    //assert (func_17_rv == &g_8);
}


/* ------------------------------------------ */
/* 
 * reads : g_63 g_84 g_81.f0 g_2 g_8
 * writes: g_63
 */
static int32_t * func_24(int32_t **** p_25, int32_t ** p_26)
{ /* block id: 56 */
    uint16_t l_150 = 65535U;
    struct S0 *l_159 = (void*)0;
    struct S0 **l_158 = &l_159;
    int32_t *l_167 = &g_63;
    int32_t **l_166 = &l_167;
    int32_t l_168 = 0x6DB7C975;
    uint32_t l_169 = 4294967295U;
    if (((((((l_150 , (((((((safe_mod_func_int16_t_s_s(l_150, (safe_mod_func_int8_t_s_s(((safe_rshift_func_int8_t_s_s(l_150, (0x19 && (+(l_158 == ((((safe_lshift_func_int8_t_s_u((safe_lshift_func_int8_t_s_u((p_26 == p_26), (safe_sub_func_int8_t_s_s(l_150, ((l_166 != (void*)0) < 1))))), 1)) <= (*l_167)) != (*l_167)) , (void*)0)))))) | (**l_166)), g_84)))) <= g_81.f0) < g_2) ^ (*l_167)) && 0x3C) > 4294967292U) >= g_81.f0)) > (*l_167)) , (**p_26)) , (*l_167)) < l_168) , l_169))
    { /* block id: 57 */
        (*l_166) = (*l_166);
        (**l_166) = (0xF106 < 0x207F);
        (*l_167) = (safe_lshift_func_uint8_t_u_s((&l_167 == (void*)0), 2));
    }
    else
    { /* block id: 61 */
        return (*p_26);
        /* statement id: 62 */
        //assert (func_24_rv == &g_8);
    }
    return (*p_26);
    /* statement id: 64 */
    //assert (func_24_rv == &g_8);
}


/* ------------------------------------------ */
/* 
 * reads : g_63 g_2 g_81.f2 g_8 g_121 g_84 g_81.f1 g_76 g_77 g_78 g_81.f0
 * writes: g_63
 */
static int32_t **** func_27(int8_t  p_28, struct S0  p_29, int32_t **** p_30, int32_t * p_31)
{ /* block id: 52 */
    int8_t l_127 = 0;
    int32_t *l_128 = &g_63;
    int32_t l_146 = (-3);
    int32_t ****l_147 = &g_78;
    (*l_128) = (0x213B74EA && l_127);
    (*l_128) = (safe_mod_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u(g_63, (safe_lshift_func_int16_t_s_u((((((p_29.f1 && 1) , (*l_128)) && g_2) & (safe_lshift_func_int8_t_s_u(((safe_add_func_uint8_t_u_u((((((((((((~g_81.f2) && ((safe_add_func_uint32_t_u_u(0x43A15A7C, (((safe_mod_func_int16_t_s_s((safe_add_func_uint16_t_u_u((((g_8 == (g_63 , 2U)) || g_121) ^ 0xFEA1), 0x47B4)), (*l_128))) , g_2) != 0x8F7C))) , g_84)) >= 0x3857) > l_146) > g_81.f1) >= p_28) < (*l_128)) , (void*)0) != (**g_76)) <= g_2) , 0U), (*l_128))) && g_81.f0), 5))) != 1), (*l_128))))), 0x6544));
    return l_147;
    /* statement id: 55 */
    //assert (func_27_rv == &g_78);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_32(uint32_t  p_33, int32_t *** p_34)
{ /* block id: 49 */
    int16_t l_123 = 1;
    int32_t l_124 = 0xB9CE0359;
    l_124 = l_123;
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_2 g_76 g_63 g_81 g_84 g_77 g_121
 * writes: g_63 g_78
 */
static uint32_t  func_35(int32_t  p_36, int16_t  p_37, int32_t  p_38)
{ /* block id: 18 */
    int32_t ***l_68 = (void*)0;
    int32_t ****l_67 = &l_68;
    struct S0 l_98 = {0xEE7A7411,0,0xD7};
    int32_t l_101 = 0x4312F30C;
    for (p_36 = 20; (p_36 > (-20)); --p_36)
    { /* block id: 21 */
        int32_t *l_55 = &g_8;
        int32_t **l_54 = &l_55;
        int32_t ****l_69 = (void*)0;
        uint32_t l_118 = 4294967295U;
        int8_t l_119 = 0xCA;
        uint8_t l_120 = 255U;
        (*l_54) = (func_41(func_44(func_49(l_54, (**l_54), g_8, (safe_rshift_func_uint8_t_u_u(p_36, 4))), &g_16, l_67, l_69), g_84) , (void*)0);
        /* statement id: 40 */
        assert (l_55 == 0);
        if ((((safe_rshift_func_int8_t_s_u(((((p_38 != ((((safe_mod_func_uint32_t_u_u((p_38 ^ ((safe_add_func_uint32_t_u_u(p_36, (+((((safe_add_func_uint16_t_u_u(g_63, ((p_37 <= (safe_rshift_func_int8_t_s_s(p_37, g_2))) & (l_98 , ((safe_add_func_uint16_t_u_u((0 || 0x433F2F19), p_37)) , l_101))))) < g_63) == p_38) , 0x08F1)))) & 0)), p_37)) == g_81.f0) & p_38) == g_81.f2)) == g_81.f2) | p_36) | p_37), 7)) ^ p_36) ^ p_36))
        { /* block id: 41 */
            int32_t ****l_102 = &g_78;
            (*g_77) = (*l_67);
            /* statement id: 42 */
            assert (g_78 == 0);
            (*l_54) = func_44(&l_68, (*l_67), l_102, ((g_63 < ((((((safe_add_func_uint16_t_u_u((((safe_add_func_int32_t_s_s((safe_sub_func_uint16_t_u_u(p_37, p_36)), (safe_add_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u(p_38, 11)) != ((!(((safe_sub_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u(((((p_38 >= l_118) || 1) , 1) != p_36), g_81.f2)), 7)) && p_37) <= p_36)) && g_63)), l_119)))) || p_37) <= p_36), g_81.f0)) | p_37) , l_120) & g_121) , p_38) | g_81.f0)) , (*g_76)));
            /* statement id: 43 */
            assert (l_55 == &g_2);
        }
        else
        { /* block id: 44 */
            return p_36;
        }
        /* facts after branching */
        assert (l_55 == &g_2);
        assert (g_78 == 0);
    }
    return g_81.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_41(int32_t * p_42, uint32_t  p_43)
{ /* block id: 38 */
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_63 g_76 g_81
 * writes: g_63
 */
static int32_t * func_44(int32_t **** p_45, int32_t *** p_46, int32_t **** p_47, int32_t **** p_48)
{ /* block id: 27 */
    uint32_t l_70 = 0x41209775;
    int32_t *l_73 = &g_2;
    int32_t **l_72 = &l_73;
    int32_t *l_83 = &g_84;
    struct S0 **l_85 = (void*)0;
    (*l_72) = ((l_70 || (~g_2)) , &g_8);
    /* statement id: 28 */
    assert (l_73 == &g_8);
    (*l_72) = (*l_72);
    for (g_63 = 0; (g_63 <= (-1)); g_63 = safe_sub_func_uint16_t_u_u(g_63, 1))
    { /* block id: 32 */
        int32_t *****l_79 = &g_77;
        struct S0 l_80 = {1U,0,-1};
        int32_t *l_82 = &g_2;
        struct S0 ***l_86 = &l_85;
        l_79 = g_76;
        l_83 = ((l_80 , (g_63 , g_81)) , l_82);
        /* statement id: 34 */
        assert (l_83 == &g_2);
        (*l_86) = l_85;
    }
    /* facts after for loop */
    assert (l_83 == &g_2 || l_83 == &g_84);
    return &g_2;
    /* statement id: 37 */
    //assert (func_44_rv == &g_2);
}


/* ------------------------------------------ */
/* 
 * reads : g_8
 * writes: g_63
 */
static int32_t **** func_49(int32_t ** p_50, int16_t  p_51, int8_t  p_52, uint32_t  p_53)
{ /* block id: 22 */
    int32_t *l_58 = &g_8;
    struct S0 l_59 = {0x4B13B106,0,-6};
    struct S0 *l_60 = (void*)0;
    struct S0 *l_61 = &l_59;
    int32_t *l_62 = &g_63;
    int32_t ***l_65 = &g_16;
    int32_t ****l_64 = &l_65;
    int32_t ****l_66 = (void*)0;
    (*p_50) = l_58;
    (*l_61) = l_59;
    (*l_62) = g_8;
    return l_66;
    /* statement id: 26 */
    //assert (func_49_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_63, "g_63", print_hash_value);
    transparent_crc(g_81.f0, "g_81.f0", print_hash_value);
    transparent_crc(g_81.f1, "g_81.f1", print_hash_value);
    transparent_crc(g_81.f2, "g_81.f2", print_hash_value);
    transparent_crc(g_84, "g_84", print_hash_value);
    transparent_crc(g_121, "g_121", print_hash_value);
    transparent_crc(g_214, "g_214", print_hash_value);
    transparent_crc(g_356, "g_356", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 91
   depth: 1, occurrence: 9
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 21
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 1
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 6
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 8

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 12
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 8, occurrence: 1
   depth: 13, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 101

XXX times a variable address is taken: 79
XXX times a pointer is dereferenced on RHS: 62
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 10
XXX times a pointer is dereferenced on LHS: 32
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 508

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 178
   level: 2, occurrence: 64
   level: 3, occurrence: 60
   level: 4, occurrence: 67
   level: 5, occurrence: 21
XXX number of pointers point to pointers: 58
XXX number of pointers point to scalars: 35
XXX number of pointers point to structs: 8
XXX percent of pointers has null in alias set: 32.7
XXX average alias set size: 1.23

XXX times a non-volatile is read: 444
XXX times a non-volatile is write: 102
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 56
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 15
   depth: 2, occurrence: 10
   depth: 3, occurrence: 3

XXX percentage a fresh-made variable is used: 16.6
XXX percentage an existing variable is used: 83.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

