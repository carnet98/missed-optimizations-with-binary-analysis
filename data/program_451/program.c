/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-jumps --no-longlong --force-non-uniform-arrays --math64 --muls --packed-struct --paranoid --pointers --structs --no-inline-function --return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      42150168
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int8_t g_4 = 0x59;
static const int8_t g_70 = 1;
static uint16_t g_79 = 6U;
static int32_t g_98 = 5;
static int32_t g_126 = 0x64F5E99A;
static int32_t *g_128 = &g_126;
static int32_t **g_127 = &g_128;
static int32_t ***g_317 = &g_127;
static int32_t ****g_316 = &g_317;
static int32_t *****g_315 = &g_316;
static uint16_t g_362 = 3U;
static int16_t g_368 = (-1);


/* --- FORWARD DECLARATIONS --- */
static const int8_t  func_1(void);
static int32_t  func_2(int8_t  p_3);
static int16_t  func_8(int32_t  p_9, int32_t  p_10);
static int32_t  func_11(uint16_t  p_12, int16_t  p_13);
static uint32_t  func_33(uint32_t  p_34, int32_t  p_35, int32_t  p_36, int8_t  p_37);
static int32_t  func_44(uint16_t  p_45, uint32_t  p_46);
static int32_t  func_51(uint16_t  p_52, int8_t  p_53);
static int16_t  func_61(int16_t  p_62);
static int16_t  func_63(uint16_t  p_64, uint8_t  p_65, uint8_t  p_66, int32_t  p_67);
static int8_t  func_82(int8_t  p_83, int32_t  p_84, uint32_t  p_85, const int32_t  p_86);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_70 g_79 g_98 g_127 g_128 g_126 g_317 g_316 g_315 g_362 g_368
 * writes: g_98 g_126 g_128 g_79 g_4 g_315 g_368
 */
static const int8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_16 = 0xDCC80FC3;
    uint8_t l_147 = 0x8A;
    const int32_t *l_153 = &g_98;
    const int32_t **l_152 = &l_153;
    int32_t l_175 = (-1);
    const int8_t l_383 = 0xD7;
    if (func_2(g_4))
    { /* block id: 3 */
        int32_t l_7 = 0x00011151;
        int32_t *l_181 = &l_16;
        if ((((-1) & (safe_mod_func_int8_t_s_s(((l_7 >= func_8((func_2(g_4) < l_7), func_11(g_4, (safe_mul_func_uint16_t_u_u((l_16 != (safe_mod_func_int16_t_s_s(g_4, l_16))), 0xAF5B))))) <= 0), 0x0C))) < g_79))
        { /* block id: 40 */
            int32_t *l_142 = &g_126;
            (*g_128) = (safe_add_func_uint8_t_u_u(0xD4, (safe_lshift_func_int8_t_s_u((g_4 && l_7), 4))));
            (*g_127) = l_142;
            (**g_127) = (((&l_7 != &l_16) <= ((g_70 && (safe_mod_func_int32_t_s_s((((safe_lshift_func_int8_t_s_u(l_147, (&g_127 == (void*)0))) | ((void*)0 == &g_128)) && (**g_127)), g_79))) >= (*l_142))) ^ (-1));
            return g_79;
        }
        else
        { /* block id: 45 */
            int32_t *l_158 = &g_126;
            int32_t ***l_183 = &g_127;
            int32_t ****l_182 = &l_183;
            for (g_79 = 0; (g_79 == 47); g_79 = safe_add_func_uint32_t_u_u(g_79, 3))
            { /* block id: 48 */
                int32_t *l_171 = &l_16;
                int32_t l_173 = 0xEA803138;
                if ((safe_lshift_func_uint8_t_u_s((l_152 == (void*)0), 0)))
                { /* block id: 49 */
                    int32_t *l_161 = &l_16;
                    uint8_t l_174 = 7U;
                    for (g_4 = 0; (g_4 != 8); g_4 = safe_add_func_uint8_t_u_u(g_4, 1))
                    { /* block id: 52 */
                        (*g_128) = 0x2D9A964D;
                        (*g_128) = (0x79DB & (safe_lshift_func_int16_t_s_s(g_98, (&g_128 == &g_128))));
                        (*l_152) = (void*)0;
                        /* statement id: 55 */
                        assert (l_153 == 0);
                        (*l_152) = l_158;
                        /* statement id: 56 */
                        assert (l_153 == &g_126);
                    }
                    /* facts after for loop */
                    assert (l_153 == &g_126 || l_153 == &g_98);
                    for (l_16 = 25; (l_16 != 16); l_16 = safe_sub_func_int16_t_s_s(l_16, 9))
                    { /* block id: 60 */
                        int8_t l_172 = 0;
                        (*g_127) = l_161;
                        /* statement id: 61 */
                        assert (g_128 == &l_16);
                        g_126 = 1;
                        (*l_158) = 0xFFD6E934;
                        l_175 = (safe_mod_func_uint32_t_u_u((safe_lshift_func_uint8_t_u_s((g_4 > (1 >= (((((safe_sub_func_uint32_t_u_u((*l_158), (((((+((0xB645FD3A >= (*l_158)) != (((0x7E502840 | (**g_127)) ^ ((safe_add_func_uint8_t_u_u(((l_171 == (*g_127)) ^ (*l_171)), 253U)) | (*l_161))) == l_172))) != l_7) >= (*l_153)) && 0x7F3A) < l_173))) >= g_126) | (*g_128)) != 0x6F35BB46) || (*l_161)))), g_70)), l_174));
                    }
                    /* facts after for loop */
                    assert (g_128 == &l_16 || g_128 == &g_126);
                    return g_70;
                    /* statement id: 66 */
                    //assert (g_128 == dangling || g_128 == &g_126);
                }
                else
                { /* block id: 67 */
                    for (l_7 = 0; (l_7 <= 3); ++l_7)
                    { /* block id: 70 */
                        int32_t ****l_178 = (void*)0;
                        int32_t ***l_180 = &g_127;
                        int32_t ****l_179 = &l_180;
                        (*l_179) = &g_127;
                        l_181 = (void*)0;
                        /* statement id: 72 */
                        assert (l_181 == 0);
                    }
                    (**g_127) = (*l_158);
                }
                if ((*l_158))
                    continue;
            }
            /* facts after for loop */
            assert (l_181 == 0 || l_181 == &l_16);
            (*l_182) = &g_127;
            (*g_128) = (((*g_127) == (*g_127)) & (safe_mod_func_uint8_t_u_u(((***l_183) != ((safe_rshift_func_int8_t_s_s(g_70, 5)) || ((safe_mul_func_int16_t_s_s((safe_unary_minus_func_int8_t_s((g_79 | ((safe_add_func_uint32_t_u_u((((**l_183) != (void*)0) != (*l_153)), g_79)) == g_70)))), g_98)) && g_126))), 1U)));
        }
        /* facts after branching */
        assert (l_181 == 0 || l_181 == &l_16);
    }
    else
    { /* block id: 81 */
        int32_t ** const *l_206 = &g_127;
        const int16_t l_214 = 0;
        int32_t ***l_244 = &g_127;
        int32_t ****l_243 = &l_244;
        const uint16_t l_350 = 0x1A13;
        uint16_t l_367 = 1U;
        int32_t l_373 = 0x343D952B;
        if ((+1U))
        { /* block id: 82 */
            uint8_t l_201 = 0x77;
            int32_t ***l_202 = &g_127;
            for (g_79 = 0; (g_79 < 42); ++g_79)
            { /* block id: 85 */
                int16_t l_205 = 0x52D8;
                int32_t ** const **l_207 = (void*)0;
                int32_t ** const **l_208 = &l_206;
                (***l_202) = (safe_unary_minus_func_uint32_t_u((safe_lshift_func_uint16_t_u_s(((safe_mul_func_int16_t_s_s(l_201, 0x7F41)) || (&g_127 != l_202)), (safe_rshift_func_int16_t_s_s((g_98 && (l_205 & ((((((*g_128) && ((***l_202) ^ (*g_128))) < g_4) || g_70) && g_4) == g_98))), 9))))));
                (*l_208) = l_206;
                (*g_128) = ((safe_unary_minus_func_uint32_t_u((l_202 == &g_127))) > ((1U & (safe_lshift_func_uint8_t_u_u((0x6D & 0xED), ((*g_127) != (***l_208))))) > ((void*)0 == (*l_206))));
                (*g_127) = (*g_127);
            }
            (*l_152) = (*g_127);
            /* statement id: 91 */
            assert (l_153 == &g_126);
            for (g_126 = 0; (g_126 >= 25); g_126 = safe_add_func_uint8_t_u_u(g_126, 6))
            { /* block id: 94 */
                int32_t **l_217 = &g_128;
                int32_t l_229 = 0;
                if (l_214)
                    break;
            }
        }
        else
        { /* block id: 110 */
            uint32_t l_242 = 0xAB97BF4D;
            (***l_206) = (l_242 || (l_242 & (**l_152)));
        }
        /* facts after branching */
        assert (l_153 == &g_98 || l_153 == &g_126);
        (*l_243) = &g_127;
        for (l_16 = 0; (l_16 > 15); l_16 = safe_add_func_uint16_t_u_u(l_16, 2))
        { /* block id: 116 */
            const uint16_t l_248 = 1U;
            (*g_128) = ((((~(((****l_243) > (0 <= ((l_248 != 4U) | ((safe_rshift_func_int16_t_s_u((g_79 || g_4), (0x63 && (**l_152)))) && ((~((!(((safe_sub_func_int16_t_s_s((0 < 3), l_248)) && g_126) < g_4)) != (*l_153))) >= (-7)))))) <= (****l_243))) < 255U) ^ 0xD9) != (*g_128));
            (*g_127) = (*g_127);
        }
        for (l_147 = 0; (l_147 != 48); l_147 = safe_add_func_uint8_t_u_u(l_147, 2))
        { /* block id: 122 */
            uint32_t l_266 = 4294967295U;
            uint32_t l_281 = 3U;
            int32_t * const l_282 = &l_175;
            int32_t ****l_346 = &l_244;
            if (((*l_152) != (*g_127)))
            { /* block id: 123 */
                uint32_t l_269 = 4294967295U;
                const int32_t l_280 = (-3);
                int32_t l_349 = 7;
                if (((safe_mod_func_uint8_t_u_u((safe_mod_func_uint16_t_u_u((safe_mod_func_int16_t_s_s((255U | (+(safe_lshift_func_int8_t_s_u(0, 4)))), ((***l_244) && (g_126 | (***l_244))))), l_266)), ((((safe_sub_func_uint8_t_u_u(((((l_269 > g_79) >= ((safe_mul_func_uint16_t_u_u((safe_sub_func_int32_t_s_s((safe_mod_func_int16_t_s_s((!(safe_add_func_int32_t_s_s((safe_unary_minus_func_uint16_t_u(((l_266 >= l_280) && g_70))), (*g_128)))), (-2))), l_266)), 0xAE22)) < g_4)) && l_280) != l_266), 0x00)) & 4294967295U) & 0x0A595513) && (**g_127)))) < l_281))
                { /* block id: 124 */
                    (*g_127) = l_282;
                    /* statement id: 125 */
                    assert (g_128 == &l_175);
                    (****l_243) = ((safe_mod_func_int8_t_s_s(((safe_rshift_func_int8_t_s_s((-7), 5)) != (*g_128)), 0x4A)) && g_126);
                    (**l_244) = (*g_127);
                    (*g_127) = (***l_243);
                }
                else
                { /* block id: 129 */
                    uint16_t l_310 = 0xD784;
                    int16_t l_311 = 1;
                    int32_t *l_331 = (void*)0;
                    if ((**l_152))
                    { /* block id: 130 */
                        int16_t l_289 = (-1);
                        (*g_128) = (((safe_mod_func_int8_t_s_s(0xB9, l_289)) == ((~(safe_mul_func_int8_t_s_s(g_4, (safe_add_func_uint32_t_u_u(((((((safe_unary_minus_func_uint16_t_u(((**l_152) || g_4))) < ((((safe_add_func_uint16_t_u_u((((((**g_127) || (g_79 || (safe_rshift_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((((safe_lshift_func_int8_t_s_u(((**g_127) | (safe_mod_func_int16_t_s_s((safe_mod_func_uint32_t_u_u((safe_sub_func_int8_t_s_s((l_289 && (*g_128)), l_310)), l_310)), 0x844A))), g_126)) > g_98) & g_98), 12)), 15)))) == g_4) != l_280) & l_289), l_280)) == l_280) <= 1) == (*l_282))) & l_289) || g_79) <= 0x33) && g_79), l_311))))) >= 0x2929)) && 0xD023A199);
                    }
                    else
                    { /* block id: 132 */
                        const uint32_t l_312 = 4294967287U;
                        return l_312;
                        /* statement id: 133 */
                        //assert (g_128 == &g_126 || g_128 == dangling);
                    }
                    for (g_126 = 0; (g_126 < 23); ++g_126)
                    { /* block id: 137 */
                        if (l_280)
                            break;
                    }
                    g_315 = &l_243;
                    /* statement id: 140 */
                    assert (g_315 == &l_243);
                    if (((safe_sub_func_int8_t_s_s(((safe_rshift_func_uint8_t_u_u(0x33, 5)) && (safe_sub_func_uint8_t_u_u((&g_316 == &g_316), (&l_280 != (**l_244))))), ((((((safe_lshift_func_uint16_t_u_s(0U, (*l_282))) != (safe_mul_func_int8_t_s_s((~(***l_244)), (safe_mod_func_uint8_t_u_u((((void*)0 != (*g_317)) == l_311), g_70))))) >= l_311) <= 0x18) && (*l_282)) < g_98))) == (****l_243)))
                    { /* block id: 141 */
                        (**g_127) = ((g_126 && g_98) ^ (**g_127));
                        (***g_316) = (**g_317);
                        l_331 = (*g_127);
                        /* statement id: 144 */
                        assert (l_331 == &g_126 || l_331 == &l_16);
                        (****g_315) = (void*)0;
                        /* statement id: 145 */
                        assert (g_128 == 0);
                    }
                    else
                    { /* block id: 146 */
                        int32_t *l_338 = &g_126;
                        l_349 = ((g_70 || (((safe_sub_func_int32_t_s_s((safe_mod_func_uint16_t_u_u((((****g_315) != l_338) == ((safe_rshift_func_uint16_t_u_s(((safe_mod_func_int32_t_s_s((safe_add_func_uint8_t_u_u(((~((void*)0 == l_346)) != (((&l_243 != &l_346) < (safe_mul_func_int16_t_s_s((((void*)0 != (*g_315)) || l_269), l_269))) == 0xD1BB)), (***l_244))), (****l_346))) || 1U), (*l_338))) == 0x942C)), l_269)), 0x5DE6AF59)) && (*l_338)) != (*l_338))) < 5);
                        (*l_152) = (**g_317);
                        /* statement id: 148 */
                        assert (l_153 == &g_126 || l_153 == &l_16);
                        (*l_152) = &l_280;
                        /* statement id: 149 */
                        assert (l_153 == &l_280);
                        (***l_206) = 0;
                    }
                    /* facts after branching */
                    assert (g_128 == &g_126 || g_128 == &l_16 || g_128 == 0);
                    assert (l_153 == &l_280 || l_153 == &g_98 || l_153 == &g_126);
                    assert (l_331 == 0 || l_331 == &g_126 || l_331 == &l_16);
                }
                /* facts after branching */
                assert (g_128 == &g_126 || g_128 == &l_16 || g_128 == 0 || g_128 == &l_175);
                assert (l_153 == &l_280 || l_153 == &g_98 || l_153 == &g_126);
                assert (g_315 == &l_243 || g_315 == &g_316);
                return l_350;
                /* statement id: 153 */
                //assert (g_128 == &g_126 || g_128 == dangling || g_128 == 0);
                //assert (g_315 == dangling || g_315 == &g_316);
            }
            else
            { /* block id: 154 */
                int32_t *l_351 = &g_98;
                int32_t *l_354 = &l_16;
                if ((**g_127))
                { /* block id: 155 */
                    int32_t ***l_359 = &g_127;
                    (***l_243) = l_351;
                    /* statement id: 156 */
                    assert (g_128 == &g_98);
                    (****l_243) = (safe_rshift_func_int8_t_s_u((*l_153), 6));
                    (**l_206) = l_354;
                    /* statement id: 158 */
                    assert (g_128 == &l_16);
                    (*g_128) = ((safe_lshift_func_uint16_t_u_u(((((safe_lshift_func_uint16_t_u_s(((void*)0 == l_359), (0x40DBB3CF < g_4))) == (safe_mod_func_int16_t_s_s(((g_70 <= ((*l_354) < g_362)) || (safe_mod_func_uint16_t_u_u((safe_sub_func_int8_t_s_s((**l_152), g_70)), (****l_346)))), l_367))) | (*l_354)) || (**l_152)), g_70)) | g_4);
                }
                else
                { /* block id: 160 */
                    if (g_368)
                        break;
                    for (g_368 = 11; (g_368 >= 3); g_368 = safe_sub_func_int32_t_s_s(g_368, 3))
                    { /* block id: 164 */
                        return g_362;
                        /* statement id: 165 */
                        //assert (g_128 == &g_126 || g_128 == dangling);
                    }
                    (****g_315) = (****g_315);
                }
                (**l_206) = (***l_243);
                (*l_282) = (***l_206);
                (**l_244) = (**g_317);
            }
            (*g_127) = (**l_244);
            (****g_316) = (((safe_sub_func_int16_t_s_s(l_373, (***l_244))) != g_126) < ((safe_add_func_uint32_t_u_u((safe_mod_func_int32_t_s_s((safe_add_func_int16_t_s_s((g_126 < (((*g_315) == (void*)0) && (((4U || ((g_98 < ((((safe_sub_func_int16_t_s_s(((safe_unary_minus_func_int32_t_s((***g_317))) || (**l_152)), g_79)) && 8U) ^ (**l_152)) <= g_362)) > (***l_244))) < g_79) & (****l_346)))), (**l_152))), 0x53BC47F2)), 0U)) <= g_4));
        }
        /* facts after for loop */
        assert (g_128 == &g_126 || g_128 == &l_16);
    }
    /* facts after branching */
    assert (g_128 == &g_126 || g_128 == &l_16);
    assert (l_153 == &g_98 || l_153 == &g_126);
    return l_383;
    /* statement id: 177 */
    //assert (g_128 == &g_126 || g_128 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_2(int8_t  p_3)
{ /* block id: 1 */
    return p_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_4
 * writes:
 */
static int16_t  func_8(int32_t  p_9, int32_t  p_10)
{ /* block id: 37 */
    int32_t **l_136 = &g_128;
    int32_t ***l_137 = &l_136;
    (*l_137) = l_136;
    return g_4;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_70 g_79 g_98 g_127 g_128 g_126
 * writes: g_98 g_126
 */
static int32_t  func_11(uint16_t  p_12, int16_t  p_13)
{ /* block id: 4 */
    int32_t l_19 = 0xBEFCDF11;
    uint8_t l_39 = 0x14;
    uint32_t l_134 = 1U;
    int32_t l_135 = 6;
    l_135 = ((func_2(func_2(l_19)) && (0x6C >= p_13)) >= (!(safe_sub_func_int16_t_s_s(((safe_add_func_int8_t_s_s(func_2(((((safe_mod_func_uint16_t_u_u(((safe_sub_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s(((9U > func_33((!l_19), l_39, (safe_rshift_func_uint8_t_u_u(5U, l_19)), p_12)) == l_39), p_13)), l_19)), l_134)) == g_70), 0x54D5)) && p_13) >= 0x2C) || l_134)), 5)) == p_12), l_39))));
    return l_134;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_70 g_79 g_98 g_127 g_128 g_126
 * writes: g_98 g_126
 */
static uint32_t  func_33(uint32_t  p_34, int32_t  p_35, int32_t  p_36, int8_t  p_37)
{ /* block id: 5 */
    uint16_t l_54 = 0U;
    int32_t *l_125 = &g_126;
    int32_t **l_124 = &l_125;
    (**l_124) = (((safe_add_func_int32_t_s_s(func_44((safe_sub_func_int32_t_s_s((safe_add_func_uint32_t_u_u(func_2(p_35), func_51(g_4, l_54))), g_70)), (safe_mul_func_int8_t_s_s((1U | (safe_lshift_func_int8_t_s_u((safe_mod_func_uint16_t_u_u(((l_124 != g_127) & (**g_127)), (**l_124))), 1))), g_126))), 0xB76A7FFA)) | p_35) == g_4);
    return g_79;
}


/* ------------------------------------------ */
/* 
 * reads : g_70 g_128
 * writes: g_126
 */
static int32_t  func_44(uint16_t  p_45, uint32_t  p_46)
{ /* block id: 26 */
    for (p_45 = 12; (p_45 < 34); p_45 = safe_add_func_int32_t_s_s(p_45, 8))
    { /* block id: 29 */
        int8_t l_133 = 0x5B;
        (*g_128) = ((safe_add_func_uint32_t_u_u(l_133, (0xCDA0 ^ 1U))) || g_70);
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_70 g_4 g_79 g_98
 * writes: g_98
 */
static int32_t  func_51(uint16_t  p_52, int8_t  p_53)
{ /* block id: 6 */
    int16_t l_76 = (-6);
    int32_t *l_114 = &g_98;
    if (p_53)
    { /* block id: 7 */
        int32_t l_112 = 0;
        int32_t *l_113 = &g_98;
        int32_t **l_115 = &l_113;
        (*l_113) = (safe_add_func_int8_t_s_s((safe_mod_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((func_2((p_53 == (func_61(func_63((safe_mod_func_int16_t_s_s(g_70, (((safe_mod_func_uint16_t_u_u(func_2((safe_mod_func_int16_t_s_s((func_2((!l_76)) & g_70), (l_76 & 0x01)))), (safe_lshift_func_int16_t_s_u(func_2(((0x3C | g_4) & 0x93)), p_52)))) >= p_53) | g_4))), p_53, g_79, g_79)) || 0x115B))) == p_53), g_4)), g_79)), l_112));
        (*l_115) = l_114;
    }
    else
    { /* block id: 22 */
        int32_t **l_116 = (void*)0;
        int32_t **l_117 = &l_114;
        (*l_117) = &g_98;
    }
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads : g_98 g_70
 * writes: g_98
 */
static int16_t  func_61(int16_t  p_62)
{ /* block id: 17 */
    int32_t *l_107 = &g_98;
    int32_t **l_106 = &l_107;
    (**l_106) = (safe_mod_func_int32_t_s_s((safe_lshift_func_uint16_t_u_s((((((void*)0 == l_106) >= (250U != (((void*)0 == (*l_106)) < 0x1DAE))) | ((safe_rshift_func_uint16_t_u_s((safe_mul_func_int16_t_s_s(0xEE13, 0x8558)), (p_62 || g_98))) == g_70)) > 0U), (*l_107))), (*l_107)));
    return g_70;
}


/* ------------------------------------------ */
/* 
 * reads : g_79 g_70 g_4 g_98
 * writes: g_98
 */
static int16_t  func_63(uint16_t  p_64, uint8_t  p_65, uint8_t  p_66, int32_t  p_67)
{ /* block id: 8 */
    int32_t * const l_99 = &g_98;
    if (p_64)
    { /* block id: 9 */
        uint32_t l_94 = 0U;
        int32_t *l_97 = &g_98;
        (*l_97) = (safe_sub_func_uint16_t_u_u((1 < ((0x47 & func_82((g_79 > ((safe_unary_minus_func_int32_t_s((((safe_mul_func_uint8_t_u_u((!(safe_mod_func_uint8_t_u_u(g_70, ((~((l_94 && (p_67 >= ((((1 ^ ((safe_add_func_int16_t_s_s((g_79 < (g_79 ^ 4294967295U)), 0x0DD1)) <= g_70)) > 0U) || p_67) < 1U))) && p_67)) && l_94)))), 0x6F)) <= p_67) <= l_94))) == 0x05AF)), g_4, g_79, g_79)) < 0x73)), l_94));
    }
    else
    { /* block id: 13 */
        int32_t *l_101 = (void*)0;
        int32_t **l_100 = &l_101;
        (*l_100) = l_99;
        /* statement id: 14 */
        assert (l_101 == &g_98);
    }
    return (*l_99);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_82(int8_t  p_83, int32_t  p_84, uint32_t  p_85, const int32_t  p_86)
{ /* block id: 10 */
    return p_86;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_70, "g_70", print_hash_value);
    transparent_crc(g_79, "g_79", print_hash_value);
    transparent_crc(g_98, "g_98", print_hash_value);
    transparent_crc(g_126, "g_126", print_hash_value);
    transparent_crc(g_362, "g_362", print_hash_value);
    transparent_crc(g_368, "g_368", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 64
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 120
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 47

XXX times a variable address is taken: 61
XXX times a pointer is dereferenced on RHS: 100
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 27
   depth: 3, occurrence: 16
   depth: 4, occurrence: 8
XXX times a pointer is dereferenced on LHS: 56
breakdown:
   depth: 1, occurrence: 36
   depth: 2, occurrence: 10
   depth: 3, occurrence: 5
   depth: 4, occurrence: 5
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 185

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 129
   level: 2, occurrence: 57
   level: 3, occurrence: 31
   level: 4, occurrence: 19
XXX number of pointers point to pointers: 27
XXX number of pointers point to scalars: 20
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 14.9
XXX average alias set size: 1.32

XXX times a non-volatile is read: 510
XXX times a non-volatile is write: 168
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 100
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 18
   depth: 1, occurrence: 11
   depth: 2, occurrence: 16
   depth: 3, occurrence: 13
   depth: 4, occurrence: 20
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 18.2
XXX percentage an existing variable is used: 81.8
********************* end of statistics **********************/

