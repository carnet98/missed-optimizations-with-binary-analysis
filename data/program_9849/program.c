/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --jumps --longlong --force-non-uniform-arrays --math64 --no-muls --no-packed-struct --paranoid --pointers --structs --inline-function --return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      332884880
 */

#include "csmith.h"

volatile uint64_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 22;
   signed f1 : 19;
   signed f2 : 9;
   int32_t  f3;
   uint64_t  f4;
};

struct S1 {
   signed f0 : 8;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_17 = 0xF29ACD40L;
static int32_t *g_16[1][3][5] = {{{&g_17,&g_17,&g_17,&g_17,&g_17},{&g_17,&g_17,&g_17,&g_17,&g_17},{&g_17,&g_17,&g_17,&g_17,&g_17}}};
static struct S1 g_74 = {3};
static struct S1 *g_73[5][1] = {{&g_74},{&g_74},{&g_74},{&g_74},{&g_74}};
static int32_t **g_106 = &g_16[0][0][2];
static int32_t ***g_105 = &g_106;
static struct S0 g_108 = {886,-90,-6,0L,0xCC30D4DDF0F57B56LL};
static int32_t g_152 = 0xB60DBC48L;
static uint16_t g_170 = 8UL;
static struct S0 *g_209[8] = {&g_108,&g_108,&g_108,&g_108,&g_108,&g_108,&g_108,&g_108};
static struct S0 **g_208 = &g_209[7];
static struct S1 **g_274 = &g_73[2][0];
static struct S1 ***g_418 = &g_274;
static struct S1 ****g_417 = &g_418;
static int32_t ***g_469 = &g_106;
static int16_t g_603 = 0x3D8DL;
static struct S0 ***g_715 = &g_208;
static struct S0 ****g_714 = &g_715;
static struct S0 *****g_719 = (void*)0;
static int16_t g_746 = 1L;
static int8_t g_804 = 0x61L;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
inline static int32_t * func_2(int32_t * p_3, int64_t  p_4);
inline static int32_t * func_5(int32_t * p_6, int32_t  p_7, uint32_t  p_8, int32_t * p_9, int32_t * p_10);
static int32_t * func_11(uint64_t  p_12, int32_t * p_13, int32_t * p_14, int32_t * p_15);
static uint64_t  func_18(uint32_t  p_19, int32_t * p_20, uint16_t  p_21);
inline static int32_t * func_22(uint16_t  p_23, uint8_t  p_24, uint32_t  p_25, int16_t  p_26, int32_t  p_27);
inline static struct S1  func_31(int8_t  p_32, int16_t  p_33, int32_t * p_34);
static int8_t  func_50(uint32_t  p_51, int32_t  p_52);
static int32_t ** func_53(uint32_t  p_54, uint64_t  p_55, int32_t * p_56, int16_t  p_57, int32_t * p_58);
inline static uint64_t  func_59(int32_t * p_60, int32_t  p_61, int16_t  p_62, int32_t ** p_63);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_16 g_17 g_108.f4 g_74.f0 g_106 g_105 g_603 g_108.f0 g_417 g_418 g_274 g_73 g_74 g_715 g_208 g_469 g_209
 * writes: g_108.f4 g_603 g_17 g_74 g_16 g_108
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int16_t l_28 = 0x261FL;
    int32_t *l_852 = &g_17;
    (**g_469) = func_2(func_5(func_11((((g_16[0][0][2] != (void*)0) && (((func_18(g_17, func_22(l_28, g_17, g_17, g_17, l_28), g_17) && g_74.f0) && l_28) || g_74.f0)) || g_17), (*g_106), (**g_105), l_852), l_28, g_108.f0, (**g_105), l_852), l_28);
    /* statement id: 499 */
    //assert (g_16[0][0][0] == &g_152 || g_16[0][0][0] == 0 || g_16[0][0][0] == &g_17);
    return (*l_852);
}


/* ------------------------------------------ */
/* 
 * reads : g_208 g_209
 * writes: g_108
 */
inline static int32_t * func_2(int32_t * p_3, int64_t  p_4)
{ /* block id: 496 */
    struct S0 l_880 = {100,425,12,0xE718B560L,2UL};
    int32_t *l_881 = &g_152;
    (**g_208) = l_880;
    return l_881;
    /* statement id: 498 */
    //assert (func_2_rv == &g_152);
}


/* ------------------------------------------ */
/* 
 * reads : g_417 g_418 g_274 g_73 g_74 g_106 g_17 g_715 g_208 g_108.f4 g_469 g_16
 * writes: g_74 g_16 g_17
 */
inline static int32_t * func_5(int32_t * p_6, int32_t  p_7, uint32_t  p_8, int32_t * p_9, int32_t * p_10)
{ /* block id: 491 */
    int32_t *l_856 = &g_17;
    struct S0 *****l_865 = &g_714;
    struct S1 *l_872 = (void*)0;
    (**g_274) = (****g_417);
    (*g_106) = l_856;
    (*l_856) = ((safe_rshift_func_int16_t_s_s(((safe_mod_func_uint64_t_u_u(1UL, ((safe_div_func_int16_t_s_s(((0xD3F2B688L || ((0x6439F9CE753B2C59LL <= p_8) & ((**g_418) != l_872))) && (safe_add_func_int16_t_s_s(g_17, ((safe_sub_func_uint64_t_u_u((safe_sub_func_uint16_t_u_u(0x5604L, ((~((*g_715) != (*g_715))) | (*l_856)))), p_8)) || (*l_856))))), g_108.f4)) || 0x8BL))) <= 0x7AE7L), (*l_856))) <= p_8);
    return (**g_469);
    /* statement id: 495 */
    //assert (func_5_rv == 0 || func_5_rv == &g_17);
}


/* ------------------------------------------ */
/* 
 * reads : g_603 g_106 g_16 g_105
 * writes: g_603 g_17
 */
static int32_t * func_11(uint64_t  p_12, int32_t * p_13, int32_t * p_14, int32_t * p_15)
{ /* block id: 484 */
    int32_t *l_855 = &g_17;
    for (g_603 = (-10); (g_603 > (-4)); ++g_603)
    { /* block id: 487 */
        (*p_15) = ((*g_106) == (**g_105));
    }
    return l_855;
    /* statement id: 490 */
    //assert (func_11_rv == &g_17);
}


/* ------------------------------------------ */
/* 
 * reads : g_108.f4
 * writes: g_108.f4
 */
static uint64_t  func_18(uint32_t  p_19, int32_t * p_20, uint16_t  p_21)
{ /* block id: 477 */
    uint32_t l_851 = 0x88097E1EL;
    for (g_108.f4 = 1; (g_108.f4 <= 7); g_108.f4 += 1)
    { /* block id: 480 */
        return l_851;
    }
    return l_851;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_22(uint16_t  p_23, uint8_t  p_24, uint32_t  p_25, int16_t  p_26, int32_t  p_27)
{ /* block id: 1 */
    int32_t *l_492 = &g_17;
    int32_t l_502[2];
    struct S1 ****l_537 = &g_418;
    struct S0 **l_565 = &g_209[7];
    struct S0 l_611 = {500,-189,16,0L,6UL};
    int32_t l_650 = 0L;
    uint32_t l_666[10] = {0x118F45BCL,0x118F45BCL,0x118F45BCL,0x118F45BCL,0x118F45BCL,0x118F45BCL,0x118F45BCL,0x118F45BCL,0x118F45BCL,0x118F45BCL};
    int32_t ****l_680 = (void*)0;
    int32_t *****l_679 = &l_680;
    uint16_t l_816 = 0x94FCL;
    struct S1 *l_818 = &g_74;
    int32_t *l_850 = &g_152;
    int i;
    for (i = 0; i < 2; i++)
        l_502[i] = (-8L);
    for (p_26 = 0; (p_26 == (-25)); p_26 = safe_sub_func_int16_t_s_s(p_26, 4))
    { /* block id: 4 */
        int8_t l_35[10] = {(-1L),0L,0L,(-1L),0L,0L,(-1L),0L,0x44L,0L};
        int32_t *l_36[5][10] = {{(void*)0,&g_17,&g_17,(void*)0,&g_17,&g_17,&g_17,(void*)0,&g_17,&g_17},{&g_17,&g_17,&g_17,&g_17,&g_17,(void*)0,&g_17,&g_17,(void*)0,&g_17},{&g_17,&g_17,&g_17,&g_17,(void*)0,(void*)0,(void*)0,&g_17,&g_17,&g_17},{&g_17,&g_17,&g_17,&g_17,&g_17,&g_17,&g_17,(void*)0,&g_17,&g_17},{(void*)0,(void*)0,(void*)0,&g_17,&g_17,&g_17,&g_17,(void*)0,(void*)0,(void*)0}};
        struct S1 *l_476 = &g_74;
        struct S0 ***l_572 = &g_208;
        int16_t l_586 = 0xDE8BL;
        int i, j;
    }
    return l_850;
    /* statement id: 476 */
    //assert (func_22_rv == &g_152);
}


/* ------------------------------------------ */
/* 
 * reads : g_17 g_73 g_74.f0 g_108.f0 g_108.f3 g_106 g_108.f4 g_108.f2 g_108.f1 g_152 g_170 g_105 g_16 g_108 g_208 g_209 g_74 g_274 g_417
 * writes: g_73 g_16 g_105 g_74 g_106 g_152 g_108.f4 g_108 g_170 g_274 g_208
 */
inline static struct S1  func_31(int8_t  p_32, int16_t  p_33, int32_t * p_34)
{ /* block id: 5 */
    int64_t l_48 = (-1L);
    struct S1 l_155[10][4] = {{{8},{13},{8},{2}},{{8},{2},{2},{8}},{{12},{2},{-4},{2}},{{2},{13},{-4},{-4}},{{12},{12},{2},{-4}},{{8},{13},{8},{2}},{{8},{2},{2},{8}},{{12},{2},{-4},{2}},{{2},{13},{-4},{-4}},{{12},{12},{2},{-4}}};
    struct S0 *l_188 = &g_108;
    struct S0 **l_187 = &l_188;
    int32_t *l_191 = &g_152;
    struct S0 l_202 = {755,448,10,-10L,0x4888C0F74BF00CB8LL};
    struct S1 **l_272 = &g_73[3][0];
    int32_t ***l_307 = &g_106;
    uint32_t l_315 = 9UL;
    uint16_t l_349 = 0UL;
    int32_t *l_463[9];
    int32_t *l_468[10][7] = {{&g_152,(void*)0,&g_17,&g_17,(void*)0,&g_152,&g_17},{&g_17,&g_152,(void*)0,&g_152,&g_152,(void*)0,&g_152},{&g_152,(void*)0,&g_17,&g_17,(void*)0,&g_152,&g_17},{&g_17,&g_152,(void*)0,&g_152,&g_152,(void*)0,&g_152},{&g_152,(void*)0,&g_17,&g_17,(void*)0,&g_152,&g_17},{&g_17,&g_152,(void*)0,&g_152,&g_152,(void*)0,&g_152},{&g_152,(void*)0,&g_17,&g_17,(void*)0,&g_152,&g_17},{&g_17,&g_152,(void*)0,&g_152,&g_152,(void*)0,&g_152},{&g_152,(void*)0,&g_17,&g_17,(void*)0,&g_152,&g_17},{&g_17,&g_152,(void*)0,&g_152,&g_152,(void*)0,&g_152}};
    int i, j;
    for (i = 0; i < 9; i++)
        l_463[i] = &g_17;
    if ((&g_17 != (void*)0))
    { /* block id: 6 */
        int32_t *l_49 = &g_17;
        struct S1 l_156 = {10};
        struct S1 **l_176 = &g_73[1][0];
        struct S0 *l_186[10] = {(void*)0,(void*)0,&g_108,(void*)0,(void*)0,&g_108,(void*)0,(void*)0,&g_108,(void*)0};
        struct S0 **l_185 = &l_186[7];
        struct S0 l_198 = {235,-376,4,-4L,0xC989E8BE2EB9B0FDLL};
        int8_t l_263 = 0x80L;
        uint8_t l_270 = 0x01L;
        int i;
        if ((p_32 == (&g_17 == &g_17)))
        { /* block id: 7 */
            int8_t l_150 = 0xDAL;
            struct S0 l_153 = {615,-385,-12,0xA2A823BFL,18446744073709551609UL};
            struct S0 *l_154 = &l_153;
            int32_t **l_159 = &g_16[0][2][3];
            int32_t *l_171[2];
            int i;
            for (i = 0; i < 2; i++)
                l_171[i] = &g_152;
            for (p_33 = 0; (p_33 < (-11)); p_33--)
            { /* block id: 10 */
                int32_t *l_151 = &g_152;
                (*l_151) = (safe_lshift_func_uint16_t_u_u(g_17, (((~p_33) & (safe_div_func_uint32_t_u_u((!(((safe_sub_func_int64_t_s_s(((void*)0 != &g_17), (safe_unary_minus_func_int32_t_s(l_48)))) | (p_34 != l_49)) > func_50(g_17, (*l_49)))), g_108.f2))) || l_150)));
                if (l_150)
                    goto lbl_157;
            }
            /* facts after for loop */
            //assert (g_16[0][0][0] == dangling || g_16[0][0][0] == 0 || g_16[0][0][0] == &g_17);
            //assert (g_105 == &g_106 || g_105 == dangling);
            (*l_154) = l_153;
lbl_157:
            l_156 = l_155[4][0];
            l_155[4][0].f0 = (((0x02422DCDL != (+0xBD156105C8CF0411LL)) == (&l_49 == l_159)) >= (safe_rshift_func_int16_t_s_u((safe_div_func_int8_t_s_s(g_152, p_33)), (p_33 >= (safe_mul_func_int64_t_s_s(p_32, ((((safe_lshift_func_int8_t_s_u((((safe_add_func_int64_t_s_s(g_170, 0xBD87E6F67040F244LL)) | g_108.f2) || p_33), p_33)) < p_32) || l_153.f3) >= g_170)))))));
        }
        else
        { /* block id: 48 */
            struct S1 l_194 = {-1};
            struct S0 **l_239 = &l_186[7];
            int32_t l_256 = 0xDED1CDC8L;
            struct S0 l_281[9] = {{474,-486,-13,0xAB0926F4L,0x1218535F4C0952EELL},{474,-486,-13,0xAB0926F4L,0x1218535F4C0952EELL},{474,-486,-13,0xAB0926F4L,0x1218535F4C0952EELL},{474,-486,-13,0xAB0926F4L,0x1218535F4C0952EELL},{474,-486,-13,0xAB0926F4L,0x1218535F4C0952EELL},{474,-486,-13,0xAB0926F4L,0x1218535F4C0952EELL},{474,-486,-13,0xAB0926F4L,0x1218535F4C0952EELL},{474,-486,-13,0xAB0926F4L,0x1218535F4C0952EELL},{474,-486,-13,0xAB0926F4L,0x1218535F4C0952EELL}};
            int i;
            if ((safe_add_func_int8_t_s_s(((g_108.f1 && ((safe_add_func_int8_t_s_s((l_176 == &g_73[4][0]), (safe_div_func_uint16_t_u_u(((+((safe_rshift_func_int8_t_s_s(((safe_sub_func_int32_t_s_s(((~(p_32 & (l_185 == l_187))) != (((safe_rshift_func_uint8_t_u_u((l_191 != (void*)0), 2)) | 3L) < g_108.f4)), 0x6FFE17F8L)) ^ 0xD3BA113AL), 5)) < 65533UL)) < p_32), g_108.f2)))) | 1L)) == (*l_191)), 7L)))
            { /* block id: 49 */
                int8_t l_195 = 0x80L;
                uint16_t l_207[9][7] = {{0UL,0x6753L,0x946FL,65535UL,65535UL,0x946FL,0x6753L},{0UL,0x6753L,0x946FL,0UL,0UL,65535UL,0x7F4DL},{0UL,0x7F4DL,65535UL,0UL,0UL,65535UL,0x7F4DL},{0UL,0x7F4DL,65535UL,0UL,0UL,65535UL,0x7F4DL},{0UL,0x7F4DL,65535UL,0UL,0UL,65535UL,0x7F4DL},{0UL,0x7F4DL,65535UL,0UL,0UL,65535UL,0x7F4DL},{0UL,0x7F4DL,65535UL,0UL,0UL,65535UL,0x7F4DL},{0UL,0x7F4DL,65535UL,0UL,0UL,65535UL,0x7F4DL},{0UL,0x7F4DL,65535UL,0UL,0UL,65535UL,0x7F4DL}};
                struct S1 **l_247 = &g_73[2][0];
                int i, j;
                for (g_108.f4 = 3; (g_108.f4 > 14); g_108.f4++)
                { /* block id: 52 */
                    l_155[4][0] = l_194;
                    if (l_195)
                        break;
                    (*l_191) = 7L;
                }
                if ((*l_49))
                { /* block id: 57 */
                    (**g_105) = (**g_105);
                    for (l_48 = 26; (l_48 >= (-8)); l_48 = safe_sub_func_int8_t_s_s(l_48, 2))
                    { /* block id: 61 */
                        (*l_188) = l_198;
                        l_194.f0 = (*l_191);
                    }
                    for (g_108.f3 = (-18); (g_108.f3 >= 21); g_108.f3++)
                    { /* block id: 67 */
                        int32_t *l_201 = &g_17;
                        if ((*l_49))
                            break;
                        (**g_105) = l_201;
                        (*l_187) = &g_108;
                        l_202 = (*l_188);
                    }
                }
                else
                { /* block id: 73 */
                    int8_t l_210 = 0x7DL;
                    (*l_191) = ((0x44L & (g_74.f0 > l_195)) <= (safe_sub_func_int64_t_s_s((safe_sub_func_int32_t_s_s(p_33, l_207[8][4])), 1L)));
                    l_210 = ((void*)0 != g_208);
                }
                if ((safe_lshift_func_int16_t_s_u((safe_rshift_func_int8_t_s_s((safe_mod_func_int64_t_s_s((safe_div_func_int64_t_s_s((g_108.f1 != p_32), (safe_sub_func_uint32_t_u_u((~(safe_div_func_uint16_t_u_u((g_152 >= (g_17 >= p_33)), ((safe_sub_func_uint8_t_u_u(((safe_sub_func_int16_t_s_s((l_195 & (0xBB7FL && (safe_mul_func_uint16_t_u_u(1UL, (((safe_div_func_int16_t_s_s(((safe_add_func_uint32_t_u_u(0UL, l_195)) & (-1L)), (-2L))) != 0xD08EL) >= (-1L)))))), 0x8B99L)) & 0L), (*l_49))) ^ (*l_49))))), 0UL)))), 0x68A93EDA46FE84D5LL)), (*l_49))), 10)))
                { /* block id: 77 */
                    uint16_t l_257 = 0x737EL;
                    (**g_208) = (**g_208);
                    if (l_198.f2)
                        goto lbl_234;
lbl_234:
                    (**g_105) = (**g_105);
                    l_257 = (safe_add_func_int8_t_s_s((safe_rshift_func_int8_t_s_s(((l_239 == (void*)0) != (safe_div_func_uint8_t_u_u((~(safe_add_func_int64_t_s_s((g_108.f2 || (safe_add_func_int16_t_s_s((l_195 ^ ((void*)0 == l_247)), (safe_add_func_uint16_t_u_u(l_194.f0, (safe_lshift_func_int16_t_s_u((safe_div_func_uint8_t_u_u((safe_add_func_uint32_t_u_u(l_256, g_17)), g_17)), p_33))))))), 0xA8943D24E930141ALL))), 0xC4L))), 2)), l_256));
                    for (g_170 = 0; (g_170 > 28); ++g_170)
                    { /* block id: 84 */
                        (*l_191) = p_33;
                        (**l_176) = l_155[9][2];
                        l_187 = &g_209[1];
                        /* statement id: 87 */
                        assert ((l_187 >= &g_209[0] && l_187 <= &g_209[7]));
                        (*l_191) = 0xF237C987L;
                    }
                    /* facts after for loop */
                    assert ((l_187 >= &g_209[0] && l_187 <= &g_209[7]) || l_187 == &l_188);
                }
                else
                { /* block id: 90 */
                    uint32_t l_262 = 4294967289UL;
                    for (l_202.f4 = 0; (l_202.f4 > 34); l_202.f4 = safe_add_func_uint8_t_u_u(l_202.f4, 4))
                    { /* block id: 93 */
                        if (l_262)
                            break;
                        (**g_105) = (**g_105);
                    }
                }
                /* facts after branching */
                assert ((l_187 >= &g_209[0] && l_187 <= &g_209[7]) || l_187 == &l_188);
            }
            else
            { /* block id: 98 */
                (*l_191) = l_263;
            }
            /* facts after branching */
            assert ((l_187 >= &g_209[0] && l_187 <= &g_209[7]) || l_187 == &l_188);
            for (l_202.f4 = 0; (l_202.f4 <= 49); l_202.f4 = safe_add_func_uint16_t_u_u(l_202.f4, 4))
            { /* block id: 103 */
                struct S0 l_271[4] = {{487,248,-11,0x8F4A9C1BL,18446744073709551615UL},{487,248,-11,0x8F4A9C1BL,18446744073709551615UL},{487,248,-11,0x8F4A9C1BL,18446744073709551615UL},{487,248,-11,0x8F4A9C1BL,18446744073709551615UL}};
                int i;
                if ((safe_rshift_func_uint16_t_u_s(1UL, 8)))
                { /* block id: 104 */
                    int32_t l_280 = (-8L);
                    struct S0 l_282[5][5] = {{{1429,-592,-8,0x8DD0C9CBL,0x4429F3894AB442EELL},{554,241,-5,0x0D2587FEL,0x8B080ABBFA448F8ALL},{1429,-592,-8,0x8DD0C9CBL,0x4429F3894AB442EELL},{1429,-592,-8,0x8DD0C9CBL,0x4429F3894AB442EELL},{554,241,-5,0x0D2587FEL,0x8B080ABBFA448F8ALL}},{{271,442,-15,0xFED91531L,1UL},{850,520,-7,0x4E9B1BF5L,0x3ECEDD2AB83D353ELL},{850,520,-7,0x4E9B1BF5L,0x3ECEDD2AB83D353ELL},{271,442,-15,0xFED91531L,1UL},{850,520,-7,0x4E9B1BF5L,0x3ECEDD2AB83D353ELL}},{{554,241,-5,0x0D2587FEL,0x8B080ABBFA448F8ALL},{554,241,-5,0x0D2587FEL,0x8B080ABBFA448F8ALL},{1831,-264,-2,0x4A534BA0L,1UL},{554,241,-5,0x0D2587FEL,0x8B080ABBFA448F8ALL},{554,241,-5,0x0D2587FEL,0x8B080ABBFA448F8ALL}},{{850,520,-7,0x4E9B1BF5L,0x3ECEDD2AB83D353ELL},{271,442,-15,0xFED91531L,1UL},{850,520,-7,0x4E9B1BF5L,0x3ECEDD2AB83D353ELL},{850,520,-7,0x4E9B1BF5L,0x3ECEDD2AB83D353ELL},{271,442,-15,0xFED91531L,1UL}},{{554,241,-5,0x0D2587FEL,0x8B080ABBFA448F8ALL},{1429,-592,-8,0x8DD0C9CBL,0x4429F3894AB442EELL},{1429,-592,-8,0x8DD0C9CBL,0x4429F3894AB442EELL},{554,241,-5,0x0D2587FEL,0x8B080ABBFA448F8ALL},{1429,-592,-8,0x8DD0C9CBL,0x4429F3894AB442EELL}}};
                    int i, j;
                    if ((g_108.f2 >= (safe_add_func_int16_t_s_s((g_170 > l_270), ((*g_106) == p_34)))))
                    { /* block id: 105 */
                        struct S1 ***l_273[3][7][8] = {{{&l_176,(void*)0,&l_272,&l_176,&l_272,&l_272,&l_272,&l_176},{&l_272,&l_272,&l_272,(void*)0,&l_176,&l_272,&l_272,&l_176},{&l_176,&l_272,(void*)0,&l_272,&l_176,&l_176,&l_176,&l_176},{&l_176,&l_272,(void*)0,&l_272,&l_176,&l_176,&l_176,&l_272},{&l_272,&l_176,&l_272,&l_272,&l_272,&l_272,&l_176,&l_272},{&l_176,&l_272,&l_272,&l_272,(void*)0,&l_272,&l_272,(void*)0},{&l_272,&l_176,&l_176,&l_176,&l_272,&l_272,&l_272,(void*)0}},{{&l_272,&l_272,&l_176,&l_176,&l_176,&l_272,&l_272,&l_272},{(void*)0,&l_176,&l_176,&l_176,(void*)0,&l_176,&l_272,&l_272},{&l_272,&l_272,&l_272,&l_272,&l_176,&l_176,&l_176,&l_176},{&l_272,&l_272,&l_272,&l_272,&l_176,&l_272,&l_272,&l_176},{&l_176,&l_272,&l_176,&l_272,&l_272,&l_272,&l_272,&l_176},{(void*)0,(void*)0,&l_176,&l_272,&l_272,&l_176,&l_272,&l_272},{&l_176,&l_272,&l_176,&l_176,&l_176,&l_272,&l_272,&l_176}},{{&l_176,&l_272,(void*)0,&l_272,&l_176,&l_272,&l_272,&l_272},{&l_272,&l_272,&l_176,(void*)0,&l_176,&l_272,&l_272,(void*)0},{(void*)0,&l_272,&l_272,&l_272,&l_176,&l_272,&l_272,&l_272},{&l_176,&l_272,&l_176,&l_272,&l_176,&l_272,&l_272,(void*)0},{(void*)0,&l_272,&l_272,&l_272,&l_176,&l_272,&l_272,&l_176},{&l_272,&l_272,&l_272,&l_272,&l_176,&l_272,&l_176,&l_272},{&l_176,&l_176,&l_272,&l_272,&l_176,(void*)0,&l_272,&l_176}}};
                        int i, j, k;
                        (**g_208) = l_271[1];
                        g_274 = l_272;
                    }
                    else
                    { /* block id: 108 */
                        int32_t l_277 = 0xD1F882EDL;
                        (*l_191) = ((safe_sub_func_uint64_t_u_u((g_108.f1 || (l_277 && ((safe_add_func_int32_t_s_s(((((p_32 >= p_32) != 0L) & g_152) >= ((0UL || 0xDF76A9F0L) != 7UL)), p_32)) & g_152))), (*l_49))) & l_280);
                        l_282[3][0] = l_281[2];
                        if (l_277)
                            break;
                    }
                }
                else
                { /* block id: 113 */
                    int16_t l_283 = 1L;
                    l_194 = (**l_176);
                    l_281[2].f1 = l_194.f0;
                    (*l_191) = 1L;
                    if (l_283)
                        break;
                }
            }
        }
        /* facts after branching */
        //assert (g_16[0][0][0] == dangling || g_16[0][0][0] == 0 || g_16[0][0][0] == &g_17);
        //assert (g_105 == &g_106 || g_105 == dangling);
        assert ((l_187 >= &g_209[0] && l_187 <= &g_209[7]) || l_187 == &l_188);
    }
    else
    { /* block id: 121 */
        uint32_t l_288[2];
        uint32_t l_299 = 0x31E6BA40L;
        int i;
        for (i = 0; i < 2; i++)
            l_288[i] = 0xD52E694BL;
        (**g_105) = (**g_105);
        for (l_202.f4 = 0; (l_202.f4 == 23); ++l_202.f4)
        { /* block id: 125 */
            uint16_t l_304 = 0x971FL;
            int32_t ***l_308 = &g_106;
            (*l_191) = (safe_rshift_func_int16_t_s_u((l_288[0] >= ((((safe_sub_func_uint64_t_u_u((((safe_sub_func_uint16_t_u_u(1UL, ((safe_div_func_uint8_t_u_u((safe_add_func_uint64_t_u_u(l_299, (safe_lshift_func_int16_t_s_u((safe_div_func_int32_t_s_s(l_304, (safe_rshift_func_int16_t_s_s(l_304, (l_307 == l_308))))), (safe_rshift_func_uint8_t_u_s((((safe_div_func_int8_t_s_s((g_108.f3 == ((void*)0 != &g_73[0][0])), g_17)) || 9UL) || 0x8F1FB9C763639430LL), 5)))))), 255UL)) & 1L))) > p_33) || 0UL), p_32)) == g_170) & l_315) >= (*l_191))), p_32));
        }
    }
    /* facts after branching */
    //assert (g_16[0][0][0] == dangling || g_16[0][0][0] == 0 || g_16[0][0][0] == &g_17);
    //assert (g_105 == &g_106 || g_105 == dangling);
    assert ((l_187 >= &g_209[0] && l_187 <= &g_209[7]) || l_187 == &l_188);
    if ((safe_unary_minus_func_int16_t_s((((safe_lshift_func_int16_t_s_u((((safe_rshift_func_uint16_t_u_u((0x25318A651242CBDCLL | (safe_mod_func_uint16_t_u_u((safe_rshift_func_uint8_t_u_s(g_152, p_33)), (g_17 && (&g_274 != &g_274))))), (safe_div_func_uint32_t_u_u(((((+(safe_mod_func_uint32_t_u_u((((safe_add_func_uint64_t_u_u((g_108.f4 <= ((l_307 == (void*)0) == g_108.f1)), (*l_191))) || 255UL) >= 6L), 0x6EC3D0FCL))) < p_33) | p_33) != p_32), p_32)))) == 0xF3DBL) < g_17), p_32)) >= p_33) && p_32))))
    { /* block id: 129 */
        struct S0 l_332 = {1289,559,-21,0L,0x5A896354CBC2A9CALL};
        int32_t ***l_376 = &g_106;
        struct S1 l_378[8] = {{-12},{-12},{-12},{-12},{-12},{-12},{-12},{-12}};
        int i;
        for (g_108.f4 = 0; (g_108.f4 <= 7); g_108.f4 += 1)
        { /* block id: 132 */
            struct S1 ***l_350 = &g_274;
            int32_t l_352 = 0x061BE2EFL;
            int64_t l_359 = 0x67F09A42ADB1AD04LL;
            int i;
            l_332 = l_332;
            (*l_191) = (safe_rshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_u((safe_sub_func_int32_t_s_s(((*g_208) == (*g_208)), 0x445A74A0L)), ((safe_sub_func_int16_t_s_s((0x689AE391288609CCLL > (l_191 != p_34)), ((0xAC32L < ((void*)0 == (*g_208))) <= g_108.f0))) || 0x42434B2BL))), 10));
            (*g_106) = p_34;
            if ((((void*)0 == &g_16[0][1][2]) > ((*l_187) == (void*)0)))
            { /* block id: 136 */
                struct S1 l_341 = {9};
                return l_341;
                /* statement id: 137 */
                //assert (g_208 == dangling || (g_208 >= &g_209[0] && g_208 <= &g_209[7]));
            }
            else
            { /* block id: 138 */
                struct S1 ***l_351 = &g_274;
                struct S0 **l_355 = &l_188;
                int32_t l_360 = 1L;
                uint8_t l_361 = 0UL;
                struct S0 ***l_362 = &g_208;
                l_352 = ((((p_32 && ((safe_div_func_int16_t_s_s((((p_33 >= (!(safe_lshift_func_uint16_t_u_u(1UL, (safe_lshift_func_uint16_t_u_u((g_152 > (g_108.f4 >= 7L)), 14)))))) | l_349) != ((l_350 == l_351) != 0x97A7L)), 1L)) >= 0x3FCAL)) == g_74.f0) != g_108.f2) | g_108.f1);
                l_361 = (safe_mod_func_int8_t_s_s((l_355 == &g_209[5]), (((((safe_rshift_func_uint16_t_u_u((p_33 >= (((void*)0 != (*g_208)) | (!((p_32 == ((*l_191) != g_170)) & (8L == l_359))))), 0)) & 0xF3CD9F6087561C71LL) >= l_360) <= 0xC0404CD1A385CBB0LL) ^ g_152)));
                (*l_362) = &l_188;
                /* statement id: 141 */
                assert (g_208 == &l_188);
                (*l_191) = l_352;
            }
            /* facts after branching */
            assert (g_208 == &l_188);
            for (l_359 = 0; (l_359 >= 0); l_359 -= 1)
            { /* block id: 146 */
                uint32_t l_371 = 0xE3F350D2L;
                if ((safe_div_func_int8_t_s_s((safe_sub_func_int16_t_s_s(l_359, (((safe_sub_func_uint64_t_u_u(((p_33 | (safe_sub_func_int64_t_s_s((-3L), (((l_359 >= (l_371 | g_108.f1)) == 1UL) || l_332.f4)))) < (((safe_add_func_int64_t_s_s((~0UL), 8L)) & 0x8B31L) > g_170)), 0xBC35C1B076C08D80LL)) && p_32) && (-1L)))), l_352)))
                { /* block id: 147 */
                    if (l_371)
                    { /* block id: 148 */
                        (*l_191) = ((void*)0 != &g_274);
                        if (p_33)
                            continue;
                    }
                    else
                    { /* block id: 151 */
                        return (**g_274);
                        /* statement id: 152 */
                        //assert (g_208 == dangling);
                    }
                    if (l_371)
                        break;
                }
                else
                { /* block id: 155 */
                    (*l_191) = ((!(l_376 == (void*)0)) & (*l_191));
                    p_34 = p_34;
                }
                for (l_202.f3 = 2; (l_202.f3 <= 7); l_202.f3 += 1)
                { /* block id: 161 */
                    (*l_191) = (safe_unary_minus_func_uint64_t_u(0x55DD7CDD833FBF26LL));
                }
            }
        }
        /* facts after for loop */
        assert (g_208 == &l_188 || (g_208 >= &g_209[0] && g_208 <= &g_209[7]));
        return l_378[4];
        /* statement id: 166 */
        //assert (g_208 == dangling || (g_208 >= &g_209[0] && g_208 <= &g_209[7]));
    }
    else
    { /* block id: 167 */
        uint32_t l_379 = 0xC2EF98C2L;
        struct S1 l_380 = {-1};
        uint16_t l_437 = 0x3EBEL;
        struct S0 *l_454 = &l_202;
        int32_t ****l_465 = (void*)0;
        struct S0 l_470 = {1367,-118,-8,0x83281D47L,0x47D4C15BA14C7D38LL};
        if (l_379)
        { /* block id: 168 */
            return l_380;
        }
        else
        { /* block id: 170 */
            struct S1 **l_394 = &g_73[0][0];
            int32_t l_395 = (-1L);
            struct S0 *l_453[6];
            int32_t ***l_455 = &g_106;
            int i;
            for (i = 0; i < 6; i++)
                l_453[i] = &l_202;
            if ((g_108.f2 & (g_152 & (safe_add_func_uint64_t_u_u(((safe_sub_func_uint16_t_u_u((g_17 | (((*l_191) && (safe_lshift_func_int16_t_s_s(((!(safe_mod_func_int8_t_s_s((&g_209[1] != (void*)0), (safe_add_func_uint8_t_u_u(255UL, (((safe_div_func_uint16_t_u_u(((void*)0 != l_394), 0xAADBL)) | p_33) & l_395)))))) < p_32), 6))) ^ g_152)), g_170)) ^ 0x38L), p_32)))))
            { /* block id: 171 */
                struct S0 *l_413 = &l_202;
                int32_t l_414 = 1L;
                (*l_191) = ((safe_div_func_int8_t_s_s(((safe_add_func_uint16_t_u_u(((g_108.f3 | (p_32 <= (safe_sub_func_uint16_t_u_u(65528UL, (safe_lshift_func_int8_t_s_u((((safe_lshift_func_uint16_t_u_s((safe_sub_func_uint64_t_u_u((safe_unary_minus_func_uint16_t_u(g_108.f0)), 0xB4C910CA1BCADB23LL)), 8)) <= (safe_add_func_uint32_t_u_u(((65534UL & (((void*)0 == l_413) >= ((g_108.f2 & 0xA8L) != (-9L)))) > g_108.f2), l_414))) & (-2L)), l_395)))))) >= g_152), 0xFC68L)) && (-9L)), 0x38L)) && g_17);
                (*g_274) = (*l_394);
            }
            else
            { /* block id: 174 */
                int16_t l_420[3][8][6] = {{{4L,0L,1L,0x514EL,0x604BL,0x5C79L},{(-2L),0xF814L,0x4139L,1L,4L,0xE35EL},{0x604BL,0L,1L,0x5C79L,1L,0L},{0x604BL,0xE35EL,4L,1L,0x4139L,0xF814L},{(-2L),0x5C79L,0x604BL,0x514EL,1L,0L},{4L,0x5C79L,0xF0BDL,0x5A0EL,0x4139L,0x514EL},{0x62D7L,0xE35EL,(-1L),0x70FAL,1L,0x70FAL},{(-1L),0L,(-1L),0xF814L,4L,0x514EL}},{{(-10L),0xF814L,0xF0BDL,1L,0x604BL,0L},{0x271EL,0L,0x604BL,1L,0xF0BDL,0xF814L},{(-10L),0x514EL,4L,0xF814L,(-1L),0L},{(-1L),0x70FAL,1L,0x70FAL,(-1L),0xE35EL},{0x62D7L,0x514EL,0x4139L,0x5A0EL,0xF0BDL,0x5C79L},{4L,0L,1L,0x514EL,0x604BL,0x5C79L},{(-2L),0xF814L,0x4139L,1L,4L,0xE35EL},{0x604BL,0L,1L,0x5C79L,1L,0L}},{{0x604BL,0xE35EL,4L,1L,0x4139L,0xF814L},{(-2L),0x5C79L,0x604BL,0x514EL,1L,0L},{4L,0x5C79L,0xF0BDL,0x5A0EL,0x4139L,0x514EL},{0x62D7L,0xE35EL,(-1L),0x70FAL,1L,0x70FAL},{(-1L),0L,(-1L),0xE35EL,0xF0BDL,0L},{(-1L),0xE35EL,0x62D7L,0x5C79L,0x271EL,1L},{4L,1L,0x271EL,0x5C79L,0x62D7L,0xE35EL},{(-1L),0L,0xF0BDL,0xE35EL,1L,0x5A0EL}}};
                int i, j, k;
                (**l_394) = (**l_272);
                if (g_152)
                    goto lbl_471;
                (*l_191) = 1L;
                for (l_379 = 10; (l_379 > 47); ++l_379)
                { /* block id: 179 */
                    for (l_48 = 0; (l_48 <= 0); l_48 += 1)
                    { /* block id: 182 */
                        struct S1 ****l_419 = &g_418;
                        (*l_394) = (*g_274);
                        l_419 = g_417;
                    }
                    if (l_420[1][0][0])
                        break;
                }
            }
            for (l_202.f4 = 0; (l_202.f4 > 20); l_202.f4 = safe_add_func_uint16_t_u_u(l_202.f4, 3))
            { /* block id: 191 */
                int64_t l_429 = 0x09F750CC62C7827CLL;
                int32_t ***l_445 = &g_106;
                uint8_t l_451 = 0x66L;
                struct S1 ***l_452 = (void*)0;
            }
lbl_471:
            (*l_454) = l_470;
            (*l_191) = (safe_lshift_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_s(g_108.f0, 4)), 6));
        }
        (*g_106) = p_34;
        (**l_307) = p_34;
    }
    return (**l_272);
}


/* ------------------------------------------ */
/* 
 * reads : g_17 g_73 g_74.f0 g_108.f0 g_108.f3 g_106 g_108.f4 g_108.f2 g_108.f1
 * writes: g_73 g_16 g_105 g_74 g_106
 */
static int8_t  func_50(uint32_t  p_51, int32_t  p_52)
{ /* block id: 11 */
    int32_t *l_64 = (void*)0;
    int32_t l_72 = 0x4B172ABFL;
    int32_t *l_76 = &g_17;
    int32_t ***l_147 = &g_106;
    struct S1 *l_148[3];
    struct S1 **l_149 = &l_148[0];
    int i;
    for (i = 0; i < 3; i++)
        l_148[i] = (void*)0;
    (*l_147) = func_53(((func_59(l_64, ((p_52 & (safe_mod_func_int32_t_s_s(((safe_lshift_func_uint16_t_u_s(0xFEA4L, 14)) | (0x80A6F85D55A9D45CLL != (((0x0E206F6EC37461BCLL & ((p_51 & 0x5144L) != g_17)) ^ (!p_52)) | p_51))), p_51))) ^ l_72), l_72, &g_16[0][0][2]) | p_52) <= g_17), p_52, l_76, (*l_76), &l_72);
    /* statement id: 39 */
    //assert (g_16[0][0][0] == &l_72 || g_16[0][0][0] == 0 || g_16[0][0][0] == &g_17 || g_16[0][0][0] == dangling || g_16[0][0][0] == &p_27);
    (*l_149) = l_148[0];
    return p_52;
    /* statement id: 41 */
    //assert (g_16[0][0][0] == dangling || g_16[0][0][0] == 0 || g_16[0][0][0] == &g_17 || g_16[0][0][0] == &p_27);
}


/* ------------------------------------------ */
/* 
 * reads : g_74.f0 g_17 g_73 g_108.f0 g_108.f3 g_106 g_108.f4 g_108.f2 g_108.f1
 * writes: g_16 g_105 g_74
 */
static int32_t ** func_53(uint32_t  p_54, uint64_t  p_55, int32_t * p_56, int16_t  p_57, int32_t * p_58)
{ /* block id: 15 */
    struct S1 **l_79 = &g_73[0][0];
    struct S1 *l_93 = &g_74;
    int32_t l_95 = 0xCC4390ACL;
    int32_t ***l_141 = (void*)0;
    struct S0 *l_142 = &g_108;
    g_16[0][0][2] = p_58;
    /* statement id: 16 */
    //assert (g_16[0][0][0] == &l_72 || g_16[0][0][0] == 0 || g_16[0][0][0] == &g_17 || g_16[0][0][0] == dangling || g_16[0][0][0] == &p_27);
    for (p_57 = 18; (p_57 <= (-15)); p_57 = safe_sub_func_uint64_t_u_u(p_57, 4))
    { /* block id: 19 */
        struct S1 *l_92[3];
        int32_t l_96[3][1][8] = {{{0x68985BB2L,0x68985BB2L,0xA1B0F83DL,0x7596CDD1L,0xA1B0F83DL,0x68985BB2L,0x68985BB2L,0xA1B0F83DL}},{{0xFC2FE0ECL,0xA1B0F83DL,0xA1B0F83DL,0xFC2FE0ECL,0x1CF63D7CL,0xFC2FE0ECL,0xA1B0F83DL,0xA1B0F83DL}},{{0xA1B0F83DL,0x1CF63D7CL,0x7596CDD1L,0x7596CDD1L,0x1CF63D7CL,0xA1B0F83DL,0x1CF63D7CL,0x7596CDD1L}}};
        int32_t ***l_126 = &g_106;
        int i, j, k;
        for (i = 0; i < 3; i++)
            l_92[i] = &g_74;
        if ((l_79 != (void*)0))
        { /* block id: 20 */
            int32_t **l_80 = &g_16[0][0][2];
            (*l_80) = &g_17;
        }
        else
        { /* block id: 22 */
            uint32_t l_127 = 0UL;
            (*p_58) = (safe_sub_func_int64_t_s_s(((((safe_unary_minus_func_int16_t_s(((safe_div_func_int64_t_s_s((7UL == (safe_lshift_func_uint16_t_u_s(((safe_lshift_func_int8_t_s_u((((safe_rshift_func_int8_t_s_u(p_57, (l_92[2] != l_92[2]))) ^ (g_74.f0 < ((void*)0 != l_93))) && g_17), ((((+((l_95 || p_55) > 0UL)) > 0x27326B30262A889ELL) < 0x5B9AADFEL) > 0xBDC4L))) ^ p_55), 6))), 18446744073709551608UL)) > l_96[2][0][3]))) & 0UL) | 255UL) ^ p_54), l_96[0][0][0]));
            if ((((safe_add_func_uint8_t_u_u(((g_17 >= (p_55 == (safe_sub_func_int8_t_s_s((0xFFF357798ED4FF94LL >= (l_95 < (g_74.f0 >= 3L))), (p_57 <= ((l_95 >= ((*p_58) && g_74.f0)) & g_17)))))) || 0x8AL), 1L)) < 0UL) > p_57))
            { /* block id: 24 */
                int32_t **l_104 = &g_16[0][1][0];
                int32_t ***l_103 = &l_104;
                struct S0 *l_107 = &g_108;
                struct S0 **l_109 = &l_107;
                g_105 = l_103;
                /* statement id: 25 */
                assert (g_105 == &l_104);
                (*l_109) = l_107;
                if (l_95)
                    break;
                //assert (g_105 == dangling);
                (*l_109) = &g_108;
            }
            else
            { /* block id: 29 */
                struct S1 l_110 = {-5};
                (**l_79) = l_110;
                (*p_58) = (safe_mod_func_int64_t_s_s((safe_mod_func_int8_t_s_s((p_57 || ((safe_rshift_func_int8_t_s_u(p_54, ((p_55 == (~l_95)) && (safe_add_func_int32_t_s_s((safe_add_func_uint64_t_u_u((((g_108.f0 && g_74.f0) ^ (safe_sub_func_uint16_t_u_u((g_108.f3 || ((g_17 ^ (safe_add_func_int16_t_s_s((l_126 != (void*)0), p_57))) & 0xAA74C462L)), 0x2BC4L))) && 3L), 0xB9E22A4178B3ED55LL)), (*p_58)))))) || p_55)), l_127)), 1UL));
            }
            (*g_106) = (void*)0;
        }
    }
    l_95 = ((((safe_rshift_func_uint16_t_u_s(((safe_add_func_int8_t_s_s((safe_sub_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((g_108.f4 != (safe_unary_minus_func_int32_t_s((safe_add_func_uint32_t_u_u(p_55, (l_95 | ((g_108.f3 < (g_74.f0 & (safe_sub_func_int64_t_s_s(g_108.f2, p_55)))) != (((&g_106 == l_141) & 0xB5E453FCL) >= p_57)))))))), 1UL)), 0xBE73L)), g_108.f1)) | l_95), 12)) > 0xD72DL) > g_108.f4) || g_108.f1);
    (*p_58) = (((0x3A66A3BBL | ((-4L) && 0x0BL)) >= (&g_108 == l_142)) && ((safe_add_func_int8_t_s_s((safe_div_func_uint64_t_u_u(g_17, g_74.f0)), ((void*)0 != l_142))) & p_54));
    return &g_16[0][0][2];
    /* statement id: 38 */
    //assert ((func_53_rv >= &g_16[0][0][0] && func_53_rv <= &g_16[0][2][4]));
}


/* ------------------------------------------ */
/* 
 * reads : g_73 g_74.f0
 * writes: g_73
 */
inline static uint64_t  func_59(int32_t * p_60, int32_t  p_61, int16_t  p_62, int32_t ** p_63)
{ /* block id: 12 */
    struct S1 **l_75 = &g_73[1][0];
    (*l_75) = g_73[0][0];
    return g_74.f0;
}




/* ---------------------------------------- */
int main (void)
{
    int i, j, k;
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_17;
    csmith_sink_ = g_74.f0;
    csmith_sink_ = g_108.f0;
    csmith_sink_ = g_108.f1;
    csmith_sink_ = g_108.f2;
    csmith_sink_ = g_108.f3;
    csmith_sink_ = g_108.f4;
    csmith_sink_ = g_152;
    csmith_sink_ = g_170;
    csmith_sink_ = g_603;
    csmith_sink_ = g_746;
    csmith_sink_ = g_804;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 184
   depth: 1, occurrence: 24
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 83
breakdown:
   indirect level: 0, occurrence: 24
   indirect level: 1, occurrence: 21
   indirect level: 2, occurrence: 15
   indirect level: 3, occurrence: 9
   indirect level: 4, occurrence: 6
   indirect level: 5, occurrence: 8
XXX full-bitfields structs in the program: 10
breakdown:
   indirect level: 0, occurrence: 10
XXX times a bitfields struct's address is taken: 77
XXX times a bitfields struct on LHS: 8
XXX times a bitfields struct on RHS: 23
XXX times a single bitfield on LHS: 4
XXX times a single bitfield on RHS: 73

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 154
   depth: 2, occurrence: 24
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 3
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 3
   depth: 26, occurrence: 1

XXX total number of pointers: 148

XXX times a variable address is taken: 421
XXX times a pointer is dereferenced on RHS: 100
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 28
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 100
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 27
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 45
XXX times a pointer is compared with address of another variable: 22
XXX times a pointer is compared with another pointer: 23
XXX times a pointer is qualified to be dereferenced: 1007

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 274
   level: 2, occurrence: 153
   level: 3, occurrence: 86
   level: 4, occurrence: 28
   level: 5, occurrence: 10
XXX number of pointers point to pointers: 76
XXX number of pointers point to scalars: 46
XXX number of pointers point to structs: 26
XXX percent of pointers has null in alias set: 31.1
XXX average alias set size: 1.47

XXX times a non-volatile is read: 886
XXX times a non-volatile is write: 341
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 3

XXX stmts: 133
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 11
   depth: 2, occurrence: 21
   depth: 3, occurrence: 26
   depth: 4, occurrence: 26
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 18.7
XXX percentage an existing variable is used: 81.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

