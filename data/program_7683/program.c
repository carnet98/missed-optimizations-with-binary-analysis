/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --checksum --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-jumps --no-longlong --no-force-non-uniform-arrays --math64 --no-muls --packed-struct --paranoid --pointers --no-structs --no-inline-function --return-structs --arg-structs --dangling-global-pointers
 * Seed:      3744462600
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint8_t g_2 = 0U;
static uint16_t g_32 = 0xD485;
static int32_t g_100 = 0x57D2A19D;
static int32_t *g_117 = &g_100;
static int32_t **g_116 = &g_117;
static int32_t *g_121 = &g_100;
static int32_t g_137 = 0;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static uint16_t  func_4(int8_t  p_5);
static int16_t  func_6(int32_t  p_7, int32_t  p_8, uint32_t  p_9, uint32_t  p_10, uint32_t  p_11);
static int8_t  func_17(uint8_t  p_18, int16_t  p_19, int32_t  p_20, int8_t  p_21, const int32_t  p_22);
static uint8_t  func_25(uint32_t  p_26, uint16_t  p_27, uint8_t  p_28, int16_t  p_29);
static const int8_t  func_33(uint32_t  p_34);
static uint16_t  func_37(int32_t  p_38, uint16_t  p_39, uint16_t  p_40);
static uint8_t  func_49(uint32_t  p_50, int32_t  p_51, const int8_t  p_52);
static int16_t  func_55(uint32_t  p_56, int8_t  p_57, uint8_t  p_58, uint16_t  p_59);
static uint16_t  func_74(int32_t  p_75, uint32_t  p_76, int32_t  p_77);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_32 g_100 g_116 g_121 g_117 g_137
 * writes: g_100 g_117 g_137 g_121
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    const uint8_t l_3 = 0xDE;
    uint8_t l_178 = 0xA7;
    int32_t l_179 = 0x003A25DF;
    l_179 = (g_2 == ((g_2 || 1) || (l_3 & ((func_4(l_3) == (l_3 | (((g_32 < ((0x4A >= g_32) <= 0xB9C5361A)) > g_32) && l_3))) , l_178))));
    /* statement id: 61 */
    assert (g_117 == &g_100 || g_117 == &g_137);
    assert (g_121 == &g_100 || g_121 == 0);
    return g_2;
}


/* ------------------------------------------ */
/* 
 * reads : g_32 g_2 g_100 g_116 g_121 g_117 g_137
 * writes: g_100 g_117 g_137 g_121
 */
static uint16_t  func_4(int8_t  p_5)
{ /* block id: 1 */
    int32_t l_42 = 5;
    int16_t l_174 = 0xF4EC;
    int32_t *l_177 = &g_137;
    (*l_177) = (func_6((safe_rshift_func_uint8_t_u_s((safe_unary_minus_func_uint32_t_u(((safe_rshift_func_int8_t_s_u((func_17((safe_mod_func_int8_t_s_s((func_25(p_5, ((safe_lshift_func_uint16_t_u_s(g_32, (((func_33((safe_lshift_func_int16_t_s_u(0x8407, func_37((safe_unary_minus_func_int8_t_s(l_42)), p_5, p_5)))) && (safe_add_func_uint8_t_u_u((l_42 & l_42), p_5))) || p_5) , p_5))) ^ l_42), p_5, l_42) == p_5), p_5)), l_42, l_42, g_2, g_2) <= g_32), 7)) || l_174))), 4)), l_174, l_42, l_174, l_42) <= 7);
    /* statement id: 59 */
    assert (g_117 == &g_137);
    assert (g_121 == 0);
    return g_137;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_121
 */
static int16_t  func_6(int32_t  p_7, int32_t  p_8, uint32_t  p_9, uint32_t  p_10, uint32_t  p_11)
{ /* block id: 56 */
    int32_t * const l_175 = (void*)0;
    int32_t **l_176 = &g_121;
    (*l_176) = l_175;
    /* statement id: 57 */
    assert (g_121 == 0);
    return p_9;
}


/* ------------------------------------------ */
/* 
 * reads : g_32
 * writes:
 */
static int8_t  func_17(uint8_t  p_18, int16_t  p_19, int32_t  p_20, int8_t  p_21, const int32_t  p_22)
{ /* block id: 53 */
    int32_t l_172 = 0x86F9DF61;
    int32_t l_173 = (-1);
    l_173 = l_172;
    return g_32;
}


/* ------------------------------------------ */
/* 
 * reads : g_116 g_137
 * writes: g_117
 */
static uint8_t  func_25(uint32_t  p_26, uint16_t  p_27, uint8_t  p_28, int16_t  p_29)
{ /* block id: 50 */
    int32_t *l_171 = &g_137;
    (*g_116) = l_171;
    /* statement id: 51 */
    assert (g_117 == &g_137);
    return (*l_171);
}


/* ------------------------------------------ */
/* 
 * reads : g_100 g_116 g_117 g_137 g_2 g_121
 * writes: g_100 g_117 g_137
 */
static const int8_t  func_33(uint32_t  p_34)
{ /* block id: 31 */
    int32_t ***l_139 = &g_116;
    int32_t ****l_138 = &l_139;
    int32_t *****l_140 = (void*)0;
    int32_t *****l_141 = (void*)0;
    int32_t *****l_142 = (void*)0;
    int32_t *****l_143 = (void*)0;
    int32_t *****l_144 = &l_138;
    const uint16_t l_154 = 1U;
    for (g_100 = 5; (g_100 < (-22)); g_100--)
    { /* block id: 34 */
        int32_t *l_135 = &g_100;
        int32_t *l_136 = &g_137;
        (*g_116) = l_135;
        if (p_34)
            continue;
        (*l_136) = (**g_116);
    }
    (*l_144) = l_138;
    if ((*g_117))
    { /* block id: 40 */
        int32_t *l_145 = &g_137;
        l_145 = (*g_116);
        /* statement id: 41 */
        assert (l_145 == &g_100);
        return p_34;
    }
    else
    { /* block id: 43 */
        uint8_t l_158 = 247U;
        int16_t l_163 = 2;
        (*****l_144) = (((&g_116 == &g_116) , (((safe_div_func_uint32_t_u_u((&l_138 == (void*)0), (((((safe_add_func_uint8_t_u_u(p_34, (safe_div_func_int32_t_s_s(l_154, g_100)))) >= 0x783AD51A) , (safe_unary_minus_func_int16_t_s((g_137 , (****l_138))))) <= 0x64) , 0x2F113D48))) >= 0U) && 0x1EC5)) , 0x66FAEDDA);
        (*g_121) = (((((5 >= (((((*g_116) != (void*)0) == ((0x53FEA8E8 == ((((safe_add_func_uint32_t_u_u((l_158 ^ g_2), (safe_lshift_func_uint8_t_u_u(((((*****l_144) & ((safe_sub_func_uint16_t_u_u((((g_137 || ((*****l_144) <= g_100)) && 0x04891CAF) > l_163), p_34)) <= p_34)) || l_158) == g_2), 0)))) >= 6U) , p_34) , p_34)) ^ p_34)) || g_100) , p_34)) != l_163) > 4U) < 0xDF) || 0xE1A3);
        (***l_139) = 5;
    }
    (*g_116) = ((+(safe_rshift_func_uint16_t_u_s((safe_div_func_uint32_t_u_u(g_100, g_2)), 15))) , (*g_116));
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_32 g_100 g_116 g_121 g_117
 * writes: g_100
 */
static uint16_t  func_37(int32_t  p_38, uint16_t  p_39, uint16_t  p_40)
{ /* block id: 2 */
    int32_t l_64 = 0x3763964E;
    int32_t **l_109 = (void*)0;
    int16_t l_112 = 1;
    if ((safe_div_func_uint32_t_u_u((0xB2 ^ ((((safe_add_func_int8_t_s_s((safe_div_func_uint8_t_u_u(func_49((((((safe_lshift_func_int16_t_s_s((65526U & 0xBA8D), ((func_55(((safe_sub_func_int16_t_s_s((safe_div_func_int16_t_s_s(0, ((0x5894 || (l_64 >= (safe_add_func_int32_t_s_s(0x7FB108F9, (safe_mod_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_s(((255U || (safe_sub_func_int32_t_s_s((-4), l_64))) < g_2), p_38)), g_32)))))) && 0x4F))), g_2)) >= 0x1675), g_2, p_39, p_38) > 0xA6A6) & g_2))) || g_32) , l_64) >= l_64) | 0), g_32, p_38), g_32)), g_2)) | 0x26) > p_40) , g_100)), 0xE6445A0A)))
    { /* block id: 12 */
        int32_t *l_104 = &l_64;
        int32_t **l_103 = &l_104;
        (*l_103) = &p_38;
        /* statement id: 13 */
        assert (l_104 == &p_38);
        (*l_103) = &p_38;
        return p_38;
    }
    else
    { /* block id: 16 */
        uint32_t l_105 = 4294967295U;
        if ((g_32 >= l_105))
        { /* block id: 17 */
            const int8_t l_106 = 5;
            g_100 = (l_106 == ((safe_sub_func_uint32_t_u_u((l_106 , (l_109 != l_109)), l_105)) <= (p_38 < ((g_100 , (+((!(((((l_112 || ((safe_add_func_int16_t_s_s((safe_unary_minus_func_int32_t_s((p_40 & p_39))), g_100)) , 0x3046699C)) <= l_106) || 65535U) , &g_100) != &g_100)) , g_2))) > 0x80))));
        }
        else
        { /* block id: 19 */
            int32_t ***l_118 = &l_109;
            (*l_118) = g_116;
            /* statement id: 20 */
            assert (l_109 == &g_117);
        }
        /* facts after branching */
        assert (l_109 == &g_117 || l_109 == 0);
        for (p_40 = (-24); (p_40 > 50); p_40 = safe_add_func_int16_t_s_s(p_40, 6))
        { /* block id: 24 */
            int32_t *l_122 = &g_100;
            (*l_122) = (0x72B8ADFE >= (p_40 <= (g_121 != l_122)));
            (**g_116) = (**g_116);
            (*l_122) = ((p_39 , (((p_40 == ((65535U != (safe_sub_func_int16_t_s_s((safe_lshift_func_int16_t_s_u(9, 14)), g_2))) , p_38)) >= (safe_div_func_int8_t_s_s(1, p_39))) | (safe_rshift_func_uint16_t_u_u((safe_div_func_uint16_t_u_u(0xAC0C, l_105)), 0)))) & g_100);
        }
        return p_40;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_2
 * writes:
 */
static uint8_t  func_49(uint32_t  p_50, int32_t  p_51, const int8_t  p_52)
{ /* block id: 8 */
    const int32_t *l_101 = &g_100;
    const int32_t **l_102 = &l_101;
    (*l_102) = l_101;
    (*l_102) = &g_100;
    return g_2;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_32 g_100
 * writes: g_100
 */
static int16_t  func_55(uint32_t  p_56, int8_t  p_57, uint8_t  p_58, uint16_t  p_59)
{ /* block id: 3 */
    uint16_t l_82 = 65535U;
    int32_t *l_98 = (void*)0;
    int32_t *l_99 = &g_100;
    (*l_99) = (~func_74((((safe_rshift_func_int8_t_s_u((safe_add_func_uint8_t_u_u(l_82, (((((((safe_add_func_uint8_t_u_u((255U | (((safe_rshift_func_int16_t_s_s((g_2 > (safe_lshift_func_uint16_t_u_s((safe_unary_minus_func_uint32_t_u(0xF68020C2)), (((((p_59 || (((safe_lshift_func_int16_t_s_s((safe_mod_func_int32_t_s_s((l_82 == (safe_div_func_int8_t_s_s((p_59 < p_58), p_59))), p_58)), p_56)) > l_82) < 0x60AA0707)) < l_82) , l_82) < 4294967295U) < l_82)))), p_56)) || g_32) < 0x7732)), 8)) == p_57) , g_2) ^ p_56) && 0xCD8D27FD) | p_58) , l_82))), 1)) & p_56) >= (-6)), p_56, g_32));
    return (*l_99);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_74(int32_t  p_75, uint32_t  p_76, int32_t  p_77)
{ /* block id: 4 */
    return p_76;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_32, "g_32", print_hash_value);
    transparent_crc(g_100, "g_100", print_hash_value);
    transparent_crc(g_137, "g_137", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 27
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 3
   depth: 4, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 18, occurrence: 1
   depth: 27, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 26

XXX times a variable address is taken: 27
XXX times a pointer is dereferenced on RHS: 11
breakdown:
   depth: 1, occurrence: 6
   depth: 2, occurrence: 2
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 19
breakdown:
   depth: 1, occurrence: 16
   depth: 2, occurrence: 1
   depth: 3, occurrence: 1
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 2
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 55

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 27
   level: 2, occurrence: 6
   level: 3, occurrence: 1
   level: 4, occurrence: 1
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 13
XXX number of pointers point to scalars: 13
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.8
XXX average alias set size: 1.12

XXX times a non-volatile is read: 180
XXX times a non-volatile is write: 51
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 41
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 22
   depth: 1, occurrence: 14
   depth: 2, occurrence: 5

XXX percentage a fresh-made variable is used: 15.3
XXX percentage an existing variable is used: 84.7
********************* end of statistics **********************/

