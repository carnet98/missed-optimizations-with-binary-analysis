/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-jumps --longlong --no-force-non-uniform-arrays --math64 --no-muls --packed-struct --paranoid --pointers --structs --inline-function --return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      2199471768
 */

#include "csmith.h"

volatile uint64_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_8 = 0xA5C62E08L;
static int32_t g_45 = (-8L);
static const int32_t *g_72 = &g_45;
static const int32_t **g_71 = &g_72;
static uint8_t g_168 = 1UL;


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_1(void);
inline static int8_t  func_9(uint64_t  p_10, uint16_t  p_11, uint16_t  p_12);
inline static uint16_t  func_17(uint32_t  p_18, int16_t  p_19);
static uint8_t  func_20(uint32_t  p_21, uint64_t  p_22, uint64_t  p_23, uint16_t  p_24, uint32_t  p_25);
inline static uint32_t  func_26(const uint64_t  p_27);
static int64_t  func_30(int16_t  p_31);
inline static uint16_t  func_33(int32_t * p_34, int32_t * p_35, int8_t  p_36, uint32_t  p_37, int32_t * p_38);
inline static int32_t * func_39(int32_t  p_40, int8_t  p_41, uint8_t  p_42);
static int32_t * func_50(int16_t  p_51, int64_t  p_52, uint32_t  p_53, uint16_t  p_54, const int32_t * p_55);
inline static int8_t  func_58(int32_t ** p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_45 g_71 g_72 g_168
 * writes: g_45
 */
inline static uint32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_13 = 18446744073709551614UL;
    uint32_t l_305 = 0x76665DE6L;
    int32_t l_306 = (-1L);
    l_306 = (safe_sub_func_int32_t_s_s((safe_rshift_func_uint16_t_u_s((((safe_mod_func_int8_t_s_s(g_8, func_9(l_13, (g_8 == g_8), l_13))) > ((+(((g_168 , (((safe_div_func_int8_t_s_s((g_168 == (((safe_unary_minus_func_uint64_t_u((~(safe_sub_func_int16_t_s_s(l_13, l_13))))) ^ g_168) ^ l_305)), g_168)) > g_168) , 7L)) == l_305) ^ g_168)) | g_168)) , l_13), 2)), l_13));
    return g_8;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_45 g_71 g_72 g_168
 * writes: g_45
 */
inline static int8_t  func_9(uint64_t  p_10, uint16_t  p_11, uint16_t  p_12)
{ /* block id: 1 */
    int8_t l_16 = 0L;
    int64_t l_284 = 0xC9793804D9622DCELL;
    int32_t l_294 = 0L;
    int64_t l_297 = 0x9DBDDC878D31A1BCLL;
    l_294 = (safe_rshift_func_uint16_t_u_s(((l_16 , func_17((0x53L <= func_20(func_26((safe_rshift_func_int8_t_s_u((((g_8 >= func_30(l_16)) , (p_11 , ((p_11 || (l_16 | ((!(((safe_add_func_uint64_t_u_u(0x5FD3A0BC11C586F4LL, 0xABD0B17AAFE8A4A7LL)) <= p_11) ^ l_16)) != 3UL))) , g_45))) , p_12), 1))), l_16, g_8, g_8, g_8)), l_284)) , l_16), g_8));
    for (l_294 = (-29); (l_294 != (-20)); ++l_294)
    { /* block id: 71 */
        return l_297;
    }
    return l_297;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_45 g_168
 * writes: g_45
 */
inline static uint16_t  func_17(uint32_t  p_18, int16_t  p_19)
{ /* block id: 65 */
    int32_t l_285 = 0xF51DCF8AL;
    int32_t *l_293 = &g_45;
    int32_t **l_292 = &l_293;
    (*l_293) = (((((g_8 > 0xCFDDA602L) & l_285) <= ((l_285 & ((safe_lshift_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(0xCD8EL, ((safe_mod_func_int8_t_s_s((((9UL <= ((g_8 , l_292) == (void*)0)) ^ p_18) | g_8), 0xF3L)) , (*l_293)))), 1)) & g_8)) || p_18)) > 1UL) <= g_168);
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_168 g_71 g_72 g_8
 * writes: g_45
 */
static uint8_t  func_20(uint32_t  p_21, uint64_t  p_22, uint64_t  p_23, uint16_t  p_24, uint32_t  p_25)
{ /* block id: 42 */
    int32_t *l_172 = &g_45;
    int32_t **l_171 = &l_172;
    uint16_t l_281 = 8UL;
    uint8_t l_282 = 0x81L;
    int32_t *l_283 = &g_45;
    if ((((((safe_div_func_uint8_t_u_u((safe_lshift_func_uint16_t_u_s((safe_div_func_uint16_t_u_u((!(safe_lshift_func_uint8_t_u_s(((((safe_mod_func_uint8_t_u_u((g_45 < (g_168 , (((((safe_rshift_func_uint8_t_u_s((((void*)0 != l_171) , (((safe_mod_func_uint8_t_u_u(0xB9L, 2L)) < (~0x91B0L)) < ((((((safe_rshift_func_uint8_t_u_s((safe_div_func_int64_t_s_s(((safe_div_func_int16_t_s_s(((-6L) < (((((!((((**l_171) >= 247UL) && (*l_172)) || 5UL)) , p_25) < p_21) <= 246UL) | (*l_172))), g_168)) & 7L), p_25)), 6)) > 0xED02C9C021E97B72LL) || g_45) && p_25) < 0x1DB4L) > g_168))), 4)) , p_24) != (**l_171)) == p_21) < 0UL))), p_22)) < 0x8BL) < 0x2E39L) == 0x49C4L), g_168))), 0xBE78L)), 10)), 0xD8L)) || g_168) || p_24) , (void*)0) == &g_72))
    { /* block id: 43 */
        return (*l_172);
    }
    else
    { /* block id: 45 */
        int64_t l_195 = 0x5C09CCC0E6D3FFD8LL;
        uint32_t l_202 = 0UL;
        (**l_171) = (safe_lshift_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((((safe_sub_func_int64_t_s_s(((!((*g_71) == (void*)0)) && (*g_72)), g_45)) <= ((safe_rshift_func_int16_t_s_s((g_8 && ((~p_22) == ((**l_171) >= (l_195 > ((safe_mod_func_uint64_t_u_u((safe_sub_func_uint32_t_u_u((safe_lshift_func_uint8_t_u_u(((((void*)0 != (*l_171)) ^ p_25) > 0xDF78E13ECE3592EELL), g_45)), l_195)), (*l_172))) >= 0xDBCA6F5D40A597C7LL))))), 2)) , p_21)) || 0x4457L), 0x339AL)), l_202));
        for (p_23 = 0; (p_23 != 14); p_23 = safe_add_func_int8_t_s_s(p_23, 7))
        { /* block id: 49 */
            int32_t l_205 = 0xF213F8C4L;
            int32_t * const *l_213 = &l_172;
        }
    }
    l_283 = func_50((safe_add_func_uint8_t_u_u(((safe_lshift_func_int8_t_s_u(((g_8 , &g_72) == &l_172), (+(~(safe_sub_func_uint8_t_u_u((((void*)0 != &l_172) < ((safe_lshift_func_int16_t_s_s((safe_div_func_int32_t_s_s(((((((g_8 || (((*l_172) & (p_22 , ((((safe_add_func_uint32_t_u_u((safe_div_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u(p_24, (**l_171))), l_281)), p_22)) >= g_45) && g_168) > g_168))) , g_8)) , l_282) > 0x0DFEL) & p_24) ^ (**l_171)) <= 0L), g_8)), 1)) == (-1L))), g_168)))))) != 0L), 0xEBL)), (**l_171), g_168, p_25, (*l_171));
    (*l_283) = (-1L);
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_8
 * writes: g_45
 */
inline static uint32_t  func_26(const uint64_t  p_27)
{ /* block id: 38 */
    int16_t l_151 = 0x5692L;
    int32_t *l_156 = &g_45;
    l_151 = (-1L);
    (*l_156) = (safe_lshift_func_uint8_t_u_s(((l_151 > (g_45 , (safe_rshift_func_int8_t_s_s(l_151, 1)))) != 0xBBL), 6));
    return g_8;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_45 g_71 g_72
 * writes: g_45
 */
static int64_t  func_30(int16_t  p_31)
{ /* block id: 2 */
    int32_t *l_32 = &g_8;
    uint64_t l_108 = 0x06586993EB33379BLL;
    l_32 = l_32;
    if ((g_8 , (((((*l_32) == func_33(func_39((*l_32), p_31, g_8), l_32, p_31, (g_8 != g_8), &g_8)) < (*l_32)) , l_32) == l_32)))
    { /* block id: 9 */
        int32_t *l_47 = &g_45;
        (*l_47) = 0x6D9E96BBL;
        return (*l_32);
    }
    else
    { /* block id: 12 */
        int32_t *l_48 = &g_45;
        int32_t **l_49 = &l_32;
        int16_t l_143 = 0xD72CL;
        l_48 = l_32;
        /* statement id: 13 */
        assert (l_48 == &g_8);
        (*l_49) = (void*)0;
        /* statement id: 14 */
        assert (l_32 == 0);
        (*l_49) = func_50(g_8, (*l_48), ((((safe_sub_func_int8_t_s_s(func_58(&l_32), (-1L))) , &l_48) != (void*)0) >= p_31), g_8, l_32);
        /* statement id: 27 */
        assert (l_32 == &g_45);
        if (((0xAB3286B001120EACLL & (((safe_sub_func_int8_t_s_s((safe_div_func_int32_t_s_s((((l_108 < (safe_rshift_func_int16_t_s_s(0x12EDL, 5))) != ((void*)0 != (*l_49))) | ((safe_sub_func_int8_t_s_s((((safe_rshift_func_int16_t_s_s(g_8, 13)) && (((safe_add_func_int8_t_s_s(((((safe_sub_func_int32_t_s_s((0xC533L || ((!((safe_add_func_uint8_t_u_u((safe_mod_func_int8_t_s_s((&g_72 == (((((&l_48 != (void*)0) | 4294967287UL) & p_31) && (*l_48)) , &l_48)), p_31)), (*l_32))) , 0x96L)) > p_31)), g_8)) == p_31) && (**g_71)) & g_8), 0xA6L)) | g_45) < g_8)) <= (*l_32)), g_45)) && p_31)), p_31)), (*l_48))) && 0x54L) <= g_8)) ^ p_31))
        { /* block id: 28 */
            int8_t l_126 = 0x1FL;
            g_45 = (g_45 >= ((((((safe_mod_func_uint8_t_u_u(((((((l_126 <= ((safe_mod_func_uint32_t_u_u((((safe_add_func_uint8_t_u_u(((safe_mod_func_int8_t_s_s(p_31, (safe_rshift_func_uint16_t_u_u(0x9543L, (safe_sub_func_uint32_t_u_u((g_8 && (((void*)0 != &g_72) , (safe_lshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s(p_31, (((safe_div_func_int16_t_s_s((&g_72 == (void*)0), (-1L))) , l_126) , (*g_72)))), g_8)))), (*l_32))))))) <= 0x50EE726552C19797LL), (*l_32))) <= (**l_49)) , 4294967288UL), p_31)) , (**l_49))) || g_45) > 249UL) || (-3L)) >= l_126) && l_126), (*l_32))) , l_126) <= g_45) || l_143) | p_31) == p_31));
            (*l_32) = ((safe_lshift_func_uint8_t_u_u((safe_lshift_func_int8_t_s_u((*l_32), (0x13E0D8C1L || 0x16B54986L))), l_126)) > (*l_32));
            (*l_49) = (void*)0;
            /* statement id: 31 */
            assert (l_32 == 0);
        }
        else
        { /* block id: 32 */
            (**l_49) = 0xAA2CA710L;
            (*l_32) = (4294967295UL >= p_31);
        }
        /* facts after branching */
        assert (l_32 == &g_45 || l_32 == 0);
    }
    /* facts after branching */
    assert (l_32 == &g_45 || l_32 == 0);
    return g_8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_33(int32_t * p_34, int32_t * p_35, int8_t  p_36, uint32_t  p_37, int32_t * p_38)
{ /* block id: 7 */
    uint8_t l_46 = 6UL;
    return l_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_45
 */
inline static int32_t * func_39(int32_t  p_40, int8_t  p_41, uint8_t  p_42)
{ /* block id: 4 */
    const int64_t l_43 = 0x5300CE3D97867A7BLL;
    int32_t *l_44 = &g_45;
    (*l_44) = l_43;
    return l_44;
    /* statement id: 6 */
    //assert (func_39_rv == &g_45);
}


/* ------------------------------------------ */
/* 
 * reads : g_72 g_45 g_8 g_71
 * writes: g_45
 */
static int32_t * func_50(int16_t  p_51, int64_t  p_52, uint32_t  p_53, uint16_t  p_54, const int32_t * p_55)
{ /* block id: 19 */
    int32_t l_97 = 0x16A45A29L;
    int32_t l_99 = 0x76AF746AL;
    g_45 = (safe_sub_func_int32_t_s_s(((safe_rshift_func_uint16_t_u_u(p_54, 1)) && ((((safe_lshift_func_uint8_t_u_u((((*g_72) ^ (((((!((safe_sub_func_uint8_t_u_u(6UL, (safe_sub_func_uint32_t_u_u((((4294967293UL & ((g_8 , ((((void*)0 != p_55) != (safe_rshift_func_uint8_t_u_s(l_97, 0))) != (~g_8))) ^ 0xED797CFCBFA339BCLL)) >= 0xF0C8B8AFECA80087LL) | 0xE0D3L), (*g_72))))) >= l_99)) <= 255UL) || l_97) != p_52) | 0xEF108C6EC2A3D91DLL)) == 8UL), l_97)) && l_99) , (void*)0) == (void*)0)), p_51));
    for (p_54 = 0; (p_54 >= 1); p_54 = safe_add_func_int16_t_s_s(p_54, 5))
    { /* block id: 23 */
        if ((**g_71))
            break;
    }
    return &g_45;
    /* statement id: 26 */
    //assert (func_50_rv == &g_45);
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_71 g_8 g_72
 * writes: g_45
 */
inline static int8_t  func_58(int32_t ** p_59)
{ /* block id: 15 */
    int8_t l_62 = 0x0AL;
    const int32_t *l_65 = &g_8;
    int32_t *l_66 = &g_45;
    int32_t **l_79 = (void*)0;
    (*l_66) = ((((l_62 , g_45) | l_62) == (((safe_rshift_func_uint16_t_u_u(l_62, 0)) , &g_45) == l_65)) | 0x21L);
    (*l_66) = (safe_sub_func_int32_t_s_s((safe_div_func_int32_t_s_s(((((void*)0 == g_71) , ((((safe_lshift_func_uint16_t_u_s((*l_66), (safe_rshift_func_int8_t_s_u((((safe_div_func_int16_t_s_s(((((&g_72 == l_79) <= ((((safe_div_func_uint32_t_u_u((*l_65), (*l_65))) ^ (((*g_71) != (*g_71)) != (*l_65))) <= (*l_66)) & g_45)) , (*l_66)) ^ 0x3BB5L), (*l_65))) > g_45) , (*l_66)), 7)))) , (void*)0) != &g_72) , g_45)) || 0x6E27L), (*l_65))), 0x9B1000BAL));
    return g_8;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_8;
    csmith_sink_ = g_45;
    csmith_sink_ = g_168;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 36
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 15, occurrence: 1
   depth: 18, occurrence: 1
   depth: 21, occurrence: 2
   depth: 24, occurrence: 1
   depth: 26, occurrence: 2
   depth: 32, occurrence: 2
   depth: 35, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 23

XXX times a variable address is taken: 36
XXX times a pointer is dereferenced on RHS: 67
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 23
XXX times a pointer is dereferenced on LHS: 20
breakdown:
   depth: 1, occurrence: 16
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 112

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 68
   level: 2, occurrence: 36
XXX number of pointers point to pointers: 7
XXX number of pointers point to scalars: 16
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 17.4
XXX average alias set size: 1.22

XXX times a non-volatile is read: 388
XXX times a non-volatile is write: 55
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 42
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 11
   depth: 2, occurrence: 5

XXX percentage a fresh-made variable is used: 11
XXX percentage an existing variable is used: 89
********************* end of statistics **********************/

