/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-jumps --longlong --no-force-non-uniform-arrays --no-math64 --no-muls --no-packed-struct --paranoid --pointers --structs --inline-function --return-structs --arg-structs --dangling-global-pointers
 * Seed:      4281154568
 */

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const signed f0 : 18;
   uint16_t  f1;
   signed f2 : 23;
   signed f3 : 29;
   int32_t  f4;
};

struct S1 {
   struct S0  f0;
   const signed f1 : 17;
   struct S0  f2;
   uint32_t  f3;
   int32_t  f4;
   const uint32_t  f5;
   const uint32_t  f6;
   signed f7 : 30;
   uint16_t  f8;
};

/* --- GLOBAL VARIABLES --- */
static const struct S0 g_6[1] = {{460,0x4B54L,-2833,1416,0x14FFD814L}};
static struct S0 g_8 = {293,0x7C57L,-2415,17235,0xE24B2E80L};
static struct S0 g_11 = {-198,5UL,1502,-1375,-5L};
static struct S0 *g_10 = &g_11;
static int32_t g_41 = 0xA8E43404L;
static uint16_t g_65[5] = {0x9804L, 0x9804L, 0x9804L, 0x9804L, 0x9804L};
static int32_t g_73 = 0x15133AA3L;
static struct S0 g_77 = {101,0x7DF6L,643,14078,-1L};
static struct S0 *g_76 = &g_77;
static const struct S0 ***g_103 = (void*)0;
static struct S1 g_139 = {{240,0x503DL,-2403,21608,0xA2211D25L},246,{-354,65527UL,-2511,19368,-1L},0xEB220E44L,0L,18446744073709551608UL,0x6720C7BFL,2682,0xA99FL};
static struct S0 ***g_141 = (void*)0;
static int32_t *g_145 = &g_41;
static struct S0 **** const g_173 = (void*)0;
static struct S0 **** const *g_172 = &g_173;
static struct S1 g_225 = {{-160,0x8D7BL,-1629,-5821,0x4572CAAEL},23,{-193,0x6DD7L,1362,-6856,0L},4294967295UL,0xEB0A1AFBL,1UL,18446744073709551615UL,-17059,0x7945L};
static struct S1 *g_224[7] = {(void*)0, (void*)0, &g_225, (void*)0, (void*)0, &g_225, (void*)0};


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static const uint8_t  func_2(const struct S0  p_3, const struct S0  p_4);
inline static struct S0  func_21(uint16_t  p_22);
static uint16_t  func_25(uint32_t  p_26);
inline static uint32_t  func_27(uint32_t  p_28, uint16_t  p_29, struct S0  p_30);
static struct S0  func_35(const struct S0 * p_36, const uint16_t  p_37);
inline static const struct S0 * func_38(uint16_t  p_39);
static int32_t * func_44(uint32_t  p_45, struct S0  p_46, struct S0 * p_47);
inline static const struct S0  func_49(uint32_t  p_50);
inline static uint8_t  func_55(const uint32_t  p_56);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_10 g_8 g_11.f0 g_41 g_11.f4 g_65 g_76 g_11.f1 g_77.f4 g_103 g_77.f0 g_73 g_141 g_77.f1 g_139.f2.f1 g_145 g_139.f2.f4 g_139.f3 g_139.f1 g_139.f0.f4 g_139.f5 g_139.f6 g_139.f2.f3 g_139.f2.f0 g_139.f0.f1 g_225.f0.f0 g_139.f0.f3 g_11.f3
 * writes: g_10 g_41 g_8.f4 g_11.f4 g_8.f1 g_11.f1 g_77.f4 g_73 g_77.f1 g_145 g_139.f3 g_172 g_139.f0.f4 g_65 g_224 g_139.f0.f1 g_139.f2.f1
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    const struct S0 l_5 = {-43,65535UL,361,-2082,0x40874B28L};
    int32_t *l_279 = &g_41;
    (*l_279) = (func_2(l_5, g_6[0]) || (safe_add_func_uint32_t_u_u((safe_unary_minus_func_uint16_t_u((safe_sub_func_int32_t_s_s((safe_sub_func_uint16_t_u_u((safe_unary_minus_func_uint16_t_u(func_2(l_5, func_21(func_2((*g_10), (*g_10)))))), l_5.f4)), g_6[0].f0)))), 0x8AB34EFDL)));
    /* statement id: 168 */
    assert (g_10 == &g_8);
    assert (g_145 == &g_73 || g_145 == &g_41);
    //assert (g_172 == dangling || g_172 == &g_173);
    //assert (g_224[0] == &g_139 || g_224[0] == 0 || g_224[0] == &g_225);
    l_279 = l_279;
    for (g_139.f2.f1 = 0; (g_139.f2.f1 > 49); g_139.f2.f1++)
    { /* block id: 172 */
        return (*l_279);
    }
    return g_139.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_10
 */
static const uint8_t  func_2(const struct S0  p_3, const struct S0  p_4)
{ /* block id: 1 */
    struct S0 *l_7 = &g_8;
    struct S0 **l_9[3][4] = {{&l_7, &l_7, &l_7, &l_7}, {&l_7, &l_7, &l_7, &l_7}, {&l_7, &l_7, &l_7, &l_7}};
    const int32_t l_12 = 0x39F3C5A4L;
    int i, j;
    g_10 = l_7;
    /* statement id: 2 */
    assert (g_10 == &g_8);
    return l_12;
}


/* ------------------------------------------ */
/* 
 * reads : g_11.f0 g_6.f3 g_6.f4 g_8.f4 g_10 g_8 g_6.f2 g_41 g_11.f4 g_65 g_76 g_11.f1 g_77.f4 g_103 g_6.f1 g_77.f0 g_6.f0 g_73 g_141 g_77.f1 g_139.f2.f1 g_145 g_139.f2.f4 g_139.f3 g_139.f1 g_139.f0.f4 g_139.f5 g_139.f6 g_139.f2.f3 g_139.f2.f0 g_139.f0.f1 g_225.f0.f0 g_139.f0.f3 g_11.f3
 * writes: g_41 g_8.f4 g_10 g_11.f4 g_8.f1 g_11.f1 g_77.f4 g_73 g_77.f1 g_145 g_139.f3 g_172 g_139.f0.f4 g_65 g_224 g_139.f0.f1
 */
inline static struct S0  func_21(uint16_t  p_22)
{ /* block id: 4 */
    struct S0 **l_34 = &g_10;
    int32_t l_122 = (-1L);
    const struct S0 l_239 = {443,0UL,2241,6539,0xF02D27C7L};
    if ((((safe_rshift_func_uint16_t_u_u(func_25(func_27((safe_unary_minus_func_int32_t_s(((safe_mod_func_int32_t_s_s(g_11.f0, p_22)) != ((l_34 == (void*)0) && func_2(func_35(func_38(g_6[0].f3), (safe_lshift_func_int8_t_s_s((p_22 || (safe_add_func_uint16_t_u_u(p_22, (((&g_73 == &g_73) >= (-5L)) >= l_122)))), l_122))), l_239))))), l_239.f3, l_239)), p_22)) == p_22) == 0x7AL))
    { /* block id: 161 */
        int32_t * const l_260 = &g_41;
        int32_t **l_261 = &g_145;
        (*l_261) = l_260;
        /* statement id: 162 */
        assert (g_145 == &g_41);
    }
    else
    { /* block id: 163 */
        struct S0 **l_272 = &g_76;
        const int32_t l_277 = 0L;
        int32_t **l_278 = &g_145;
        (*g_145) = (((safe_sub_func_uint32_t_u_u(((safe_sub_func_uint32_t_u_u((safe_rshift_func_uint8_t_u_u((p_22 ^ (p_22 | (safe_mod_func_uint8_t_u_u((0x4537L && g_139.f5), (safe_sub_func_uint16_t_u_u(((void*)0 == l_272), (((0xDD83L ^ (((safe_mod_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s(((void*)0 == &g_224[4]), 0)), (-10L))) || 0xB47CL) && (*g_145))) >= 1UL) == (-1L)))))))), p_22)), (*g_145))) || g_139.f0.f3), p_22)) == 8UL) < l_277);
        (*l_278) = &g_73;
        /* statement id: 165 */
        assert (g_145 == &g_73);
    }
    /* facts after branching */
    assert (g_145 == &g_73 || g_145 == &g_41);
    //assert (g_172 == dangling || g_172 == &g_173);
    //assert (g_224[0] == &g_139 || g_224[0] == 0 || g_224[0] == &g_225);
    return (*g_10);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_25(uint32_t  p_26)
{ /* block id: 158 */
    uint32_t l_255 = 0x4D557F31L;
    struct S0 **** const *l_258 = &g_173;
    int32_t l_259 = 0x4825EF72L;
    l_259 = (l_255 && (safe_add_func_uint8_t_u_u(p_26, (((void*)0 == l_258) && 4294967295UL))));
    return l_255;
}


/* ------------------------------------------ */
/* 
 * reads : g_139.f0.f1 g_225.f0.f0 g_6.f4 g_139.f0.f3 g_11.f3 g_145
 * writes: g_139.f0.f1 g_73 g_41
 */
inline static uint32_t  func_27(uint32_t  p_28, uint16_t  p_29, struct S0  p_30)
{ /* block id: 151 */
    int8_t l_245 = (-8L);
    struct S0 **l_254 = &g_76;
    struct S0 ***l_253 = &l_254;
    for (g_139.f0.f1 = 5; (g_139.f0.f1 != 1); g_139.f0.f1--)
    { /* block id: 154 */
        int32_t l_244[9] = {0x4E493BE0L, 0x7235E590L, 0x4E493BE0L, 0x7235E590L, 0x4E493BE0L, 0x7235E590L, 0x4E493BE0L, 0x7235E590L, 0x4E493BE0L};
        int i;
        (*g_145) = (g_225.f0.f0 & (l_244[3] > ((l_245 != 0x1ABC1FECL) < (safe_mod_func_int32_t_s_s((((((safe_add_func_int16_t_s_s((((0xB29BL < (safe_rshift_func_uint16_t_u_s((safe_unary_minus_func_uint32_t_u((((((p_28 == ((l_253 != &l_254) != (((p_30.f4 | 0UL) >= g_6[0].f4) ^ l_244[3]))) & 0x34A2L) && l_244[3]) > l_245) & 1L))), l_244[3]))) > p_30.f2) == p_28), g_139.f0.f3)) == 0x5C54AC59L) < g_11.f3) | p_29) & l_244[6]), 1L)))));
    }
    return l_245;
}


/* ------------------------------------------ */
/* 
 * reads : g_77.f0 g_6.f0 g_65 g_73 g_8.f1 g_141 g_77.f1 g_139.f2.f1 g_145 g_139.f2.f4 g_11.f1 g_139.f3 g_139.f1 g_41 g_6.f4 g_6.f1 g_139.f0.f4 g_139.f5 g_139.f6 g_11.f4 g_139.f2.f3 g_139.f2.f0
 * writes: g_73 g_11.f1 g_77.f1 g_8.f1 g_41 g_145 g_139.f3 g_172 g_139.f0.f4 g_65 g_11.f4 g_77.f4 g_224
 */
static struct S0  func_35(const struct S0 * p_36, const uint16_t  p_37)
{ /* block id: 60 */
    struct S1 *l_138 = &g_139;
    int32_t l_157 = 0x798DF4D2L;
    uint32_t l_222[8] = {0x62232ECDL, 0x93D40E68L, 0x62232ECDL, 0x93D40E68L, 0x62232ECDL, 0x93D40E68L, 0x62232ECDL, 0x93D40E68L};
    int32_t *l_233 = &g_73;
    struct S0 l_238[2] = {{-473,2UL,-2792,-7202,-10L}, {-473,2UL,-2792,-7202,-10L}};
    int i;
    if ((g_77.f0 <= (safe_mod_func_int16_t_s_s(((p_37 & 0xEB048EBAL) > ((safe_rshift_func_uint16_t_u_s(65535UL, 15)) || ((safe_rshift_func_int16_t_s_s(p_37, 1)) || (0xE688B2FFL ^ ((0x2DL || 0xCAL) || p_37))))), g_6[0].f0))))
    { /* block id: 61 */
        int32_t *l_129 = &g_73;
        struct S0 **** const l_171[7] = {&g_141, &g_141, &g_141, &g_141, &g_141, &g_141, &g_141};
        struct S0 **** const *l_170 = &l_171[6];
        int i;
        (*l_129) = 0x8DA50500L;
        (*l_129) = (safe_add_func_int32_t_s_s((safe_add_func_int16_t_s_s((p_37 != g_77.f0), g_65[0])), (&p_36 != (void*)0)));
        for (g_73 = 0; (g_73 <= 14); g_73 = safe_add_func_int8_t_s_s(g_73, 1))
        { /* block id: 66 */
            int32_t l_169 = 0x101A31BCL;
            int32_t *l_176 = &l_157;
            for (g_11.f1 = 0; (g_11.f1 <= 26); g_11.f1++)
            { /* block id: 69 */
                uint16_t l_158 = 2UL;
                for (g_77.f1 = 0; (g_77.f1 <= 4); g_77.f1 += 1)
                { /* block id: 72 */
                    uint32_t l_168 = 1UL;
                    int i;
                    for (g_8.f1 = 0; (g_8.f1 <= 4); g_8.f1 += 1)
                    { /* block id: 75 */
                        struct S1 **l_140 = &l_138;
                        int32_t *l_142 = (void*)0;
                        int32_t *l_143 = &g_41;
                        int32_t **l_144 = (void*)0;
                        int32_t **l_146 = &g_145;
                        int i;
                        (*l_140) = l_138;
                        (*l_143) = (g_65[g_8.f1] <= (g_141 != g_141));
                        g_145 = &g_73;
                        /* statement id: 78 */
                        assert (g_145 == &g_73);
                        (*l_146) = &g_41;
                        /* statement id: 79 */
                        assert (g_145 == &g_41);
                    }
                    for (g_139.f3 = 0; (g_139.f3 <= 4); g_139.f3 += 1)
                    { /* block id: 83 */
                        int32_t *l_163 = (void*)0;
                        int32_t l_167 = (-2L);
                        int i;
                        (*g_145) = ((safe_lshift_func_int16_t_s_u(g_65[g_77.f1], 9)) | ((g_65[g_77.f1] && g_139.f2.f1) == 4294967295UL));
                        (*g_145) = (safe_sub_func_int8_t_s_s(((safe_lshift_func_uint16_t_u_u((safe_mod_func_uint8_t_u_u((((((((safe_mod_func_int16_t_s_s(l_157, l_158)) == (g_65[g_77.f1] <= (((((safe_add_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_s((&g_41 != l_163), 0)) > ((0x32L || (safe_add_func_uint32_t_u_u((safe_unary_minus_func_int8_t_s(l_157)), 1L))) | l_157)), l_167)) >= g_139.f2.f4) && 8L) != g_11.f1) ^ 0x3DE7L))) > l_158) & g_139.f3) == p_37) | l_168) ^ l_157), 0x98L)), l_169)) < g_139.f1), 0x57L));
                        (*g_145) = (*g_145);
                        g_172 = l_170;
                        /* statement id: 87 */
                        assert ((g_172 >= &l_171[0] && g_172 <= &l_171[6]));
                    }
                    (*g_145) = (g_65[g_77.f1] <= (~l_169));
                }
                if ((*g_145))
                { /* block id: 91 */
                    int32_t **l_175[10][2][2] = {{{(void*)0, (void*)0}, {(void*)0, (void*)0}}, {{(void*)0, (void*)0}, {(void*)0, (void*)0}}, {{(void*)0, (void*)0}, {(void*)0, (void*)0}}, {{(void*)0, (void*)0}, {(void*)0, (void*)0}}, {{(void*)0, (void*)0}, {(void*)0, (void*)0}}, {{(void*)0, (void*)0}, {(void*)0, (void*)0}}, {{(void*)0, (void*)0}, {(void*)0, (void*)0}}, {{(void*)0, (void*)0}, {(void*)0, (void*)0}}, {{(void*)0, (void*)0}, {(void*)0, (void*)0}}, {{(void*)0, (void*)0}, {(void*)0, (void*)0}}};
                    int i, j, k;
                    l_176 = &l_157;
                }
                else
                { /* block id: 93 */
                    int32_t l_195[9];
                    int i;
                    for (i = 0; i < 9; i++)
                        l_195[i] = (-1L);
                    (*g_145) = (((safe_rshift_func_int8_t_s_u((0xF720A13FL ^ ((g_6[0].f4 == (0x4AB7F0B0L & (safe_mod_func_int32_t_s_s(0x47551151L, 0xE89965A7L)))) | (safe_rshift_func_uint16_t_u_s(((safe_mod_func_int16_t_s_s(g_65[0], (safe_add_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s((p_37 > ((1L & ((safe_add_func_uint8_t_u_u((safe_mod_func_uint32_t_u_u(4294967295UL, (*g_145))), g_6[0].f1)) & (*l_176))) < 0x5AL)), 6)), 0x9168L)))) <= l_195[0]), g_73)))), (*l_129))) ^ 0UL) > l_157);
                }
            }
        }
        /* facts after for loop */
        assert ((g_172 >= &l_171[0] && g_172 <= &l_171[6]) || g_172 == &g_173);
        for (g_41 = 0; (g_41 == 11); g_41++)
        { /* block id: 100 */
            int16_t l_206 = 0xF10CL;
            for (g_139.f0.f4 = 1; (g_139.f0.f4 <= 4); g_139.f0.f4 += 1)
            { /* block id: 103 */
                int i;
                for (l_157 = 0; l_157 < 5; l_157 += 1)
                {
                    g_65[l_157] = 65531UL;
                }
                l_157 = g_65[g_139.f0.f4];
            }
            for (g_77.f1 = 0; (g_77.f1 == 50); g_77.f1 = safe_add_func_int16_t_s_s(g_77.f1, 9))
            { /* block id: 109 */
                int8_t l_219 = 0L;
                for (g_139.f3 = 1; (g_139.f3 <= 4); g_139.f3 += 1)
                { /* block id: 112 */
                    int32_t **l_200 = (void*)0;
                    int32_t **l_201 = &g_145;
                    (*l_129) = (*g_145);
                    (*l_201) = l_129;
                    /* statement id: 114 */
                    assert (g_145 == &g_73);
                    (*g_145) = p_37;
                    for (g_11.f4 = 3; (g_11.f4 >= 0); g_11.f4 -= 1)
                    { /* block id: 118 */
                        (*l_129) = (((*g_145) < ((safe_rshift_func_int16_t_s_u(((((safe_rshift_func_int16_t_s_u(l_206, 5)) | g_139.f5) || (safe_sub_func_uint8_t_u_u((safe_mod_func_uint16_t_u_u(p_37, (g_139.f6 || ((safe_add_func_uint16_t_u_u(p_37, (!(safe_rshift_func_int16_t_s_u(5L, (safe_unary_minus_func_int32_t_s((g_11.f4 == (safe_add_func_int8_t_s_s(g_139.f2.f3, (-5L))))))))))) ^ l_219)))), p_37))) && 3UL), p_37)) && g_139.f2.f0)) & p_37);
                    }
                }
            }
            if ((*g_145))
            { /* block id: 123 */
                struct S1 **l_223[5][4] = {{(void*)0, &l_138, &l_138, &l_138}, {(void*)0, &l_138, &l_138, &l_138}, {(void*)0, &l_138, &l_138, &l_138}, {(void*)0, &l_138, &l_138, &l_138}, {(void*)0, &l_138, &l_138, &l_138}};
                int32_t l_226 = 0x6FCFDC9AL;
                int i, j;
                for (g_77.f4 = (-25); (g_77.f4 < 10); g_77.f4++)
                { /* block id: 126 */
                    if (l_222[0])
                        break;
                }
                g_224[2] = &g_139;
                if (l_226)
                    break;
                for (l_157 = 0; (l_157 == (-23)); l_157--)
                { /* block id: 133 */
                    struct S0 l_234 = {318,9UL,957,18067,7L};
                    (*l_129) = (safe_sub_func_int8_t_s_s(0x52L, (safe_rshift_func_uint16_t_u_s(p_37, 6))));
                    l_233 = (void*)0;
                    /* statement id: 135 */
                    assert (l_233 == 0);
                    return l_234;
                    /* statement id: 136 */
                    //assert (g_172 == dangling || g_172 == &g_173);
                }
            }
            else
            { /* block id: 138 */
                for (l_206 = 0; (l_206 >= (-9)); --l_206)
                { /* block id: 141 */
                    struct S1 **l_237 = &g_224[2];
                    (*l_237) = &g_225;
                }
            }
            (*l_129) = (p_37 >= g_139.f5);
        }
        /* facts after for loop */
        assert (g_145 == &g_73 || g_145 == &g_41);
        //assert (g_224[0] == &g_139 || g_224[0] == 0 || g_224[0] == &g_225);
    }
    else
    { /* block id: 147 */
        (*g_145) = (&l_138 == (void*)0);
    }
    /* facts after branching */
    assert (g_145 == &g_73 || g_145 == &g_41);
    //assert (g_172 == dangling || g_172 == &g_173);
    //assert (g_224[0] == &g_139 || g_224[0] == 0 || g_224[0] == &g_225);
    return l_238[1];
}


/* ------------------------------------------ */
/* 
 * reads : g_6.f4 g_8.f4 g_10 g_8 g_6.f2 g_41 g_11.f4 g_6.f3 g_65 g_76 g_11.f1 g_11.f0 g_77.f4 g_103 g_6.f1
 * writes: g_41 g_8.f4 g_10 g_11.f4 g_8.f1 g_11.f1 g_77.f4
 */
inline static const struct S0 * func_38(uint16_t  p_39)
{ /* block id: 5 */
    int32_t *l_40 = &g_41;
    const struct S0 l_48 = {-379,0xDF12L,147,3183,-9L};
    const uint16_t l_57 = 0xCFD2L;
    int32_t **l_108 = &l_40;
    uint16_t l_117 = 0x54EDL;
    (*l_40) = g_6[0].f4;
    for (g_8.f4 = 0; (g_8.f4 == 7); g_8.f4 = safe_add_func_int32_t_s_s(g_8.f4, 2))
    { /* block id: 9 */
        int16_t l_62 = 4L;
        struct S0 l_75[4][4] = {{{-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}}, {{-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}}, {{-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}}, {{-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}, {-153,65535UL,2633,18784,0xDA34DBBDL}}};
        int32_t *l_100 = &g_73;
        int32_t **l_101 = (void*)0;
        int32_t **l_102 = &l_40;
        const struct S0 *l_107 = (void*)0;
        const struct S0 **l_106 = &l_107;
        const struct S0 ***l_105 = &l_106;
        int i, j;
        l_100 = func_44(func_2(l_48, func_49(((safe_mod_func_uint16_t_u_u(func_2((*g_10), l_48), ((safe_add_func_int16_t_s_s(g_6[0].f2, (((func_55(l_57) == l_62) & ((p_39 & p_39) == p_39)) > g_11.f4))) & p_39))) <= g_6[0].f3))), l_75[0][3], g_76);
        /* statement id: 48 */
        assert (l_100 == &g_41);
        (*l_102) = l_100;
        for (g_77.f4 = 0; (g_77.f4 <= 4); g_77.f4 += 1)
        { /* block id: 52 */
            const struct S0 ****l_104[7][9][4] = {{{&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}}, {{&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}}, {{&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}}, {{&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}}, {{&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}}, {{&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}}, {{&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}, {&g_103, &g_103, &g_103, &g_103}}};
            int i, j, k;
            l_105 = g_103;
            /* statement id: 53 */
            assert (l_105 == 0);
        }
        /* facts after for loop */
        assert (l_105 == 0 || l_105 == &l_106);
        return &g_6[0];
        /* statement id: 55 */
        //assert ((func_38_rv >= &g_6[0] && func_38_rv <= &g_6[0]));
    }
    (*l_108) = &g_41;
    (**l_108) = ((p_39 & (((safe_lshift_func_uint8_t_u_u((*l_40), ((safe_mod_func_int16_t_s_s((*l_40), (((safe_sub_func_uint16_t_u_u(g_6[0].f4, g_8.f3)) > (safe_add_func_int8_t_s_s(p_39, (&l_48 == &l_48)))) | ((((((3L != g_6[0].f1) && p_39) | (*l_40)) && (*l_40)) && l_117) <= g_65[2])))) & (-1L)))) ^ p_39) ^ (**l_108))) >= 6UL);
    return &g_77;
    /* statement id: 59 */
    //assert (func_38_rv == &g_77);
}


/* ------------------------------------------ */
/* 
 * reads : g_11.f4 g_11.f1 g_41 g_11.f0 g_77.f4
 * writes: g_11.f4 g_11.f1 g_41
 */
static int32_t * func_44(uint32_t  p_45, struct S0  p_46, struct S0 * p_47)
{ /* block id: 35 */
    uint8_t l_89[1][8][3] = {{{0xF1L, 0xD4L, 0xFEL}, {0xF1L, 0xD4L, 0xFEL}, {0xF1L, 0xD4L, 0xFEL}, {0xF1L, 0xD4L, 0xFEL}, {0xF1L, 0xD4L, 0xFEL}, {0xF1L, 0xD4L, 0xFEL}, {0xF1L, 0xD4L, 0xFEL}, {0xF1L, 0xD4L, 0xFEL}}};
    int32_t l_91[8] = {1L, (-1L), 1L, (-1L), 1L, (-1L), 1L, (-1L)};
    struct S0 *l_97 = &g_77;
    int32_t *l_98 = (void*)0;
    int32_t *l_99 = &l_91[7];
    int i, j, k;
    for (g_11.f4 = 0; (g_11.f4 >= 23); ++g_11.f4)
    { /* block id: 38 */
        uint8_t l_90 = 255UL;
        for (g_11.f1 = 4; (g_11.f1 < 44); g_11.f1 = safe_add_func_uint16_t_u_u(g_11.f1, 5))
        { /* block id: 41 */
            int32_t *l_82 = &g_41;
            (*l_82) = (-1L);
            (*l_82) = ((((safe_sub_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u(((safe_add_func_int16_t_s_s(((&g_76 == &p_47) >= l_89[0][2][0]), (*l_82))) != l_90), 2)), 0x39L)) ^ (((void*)0 != &g_77) < 0x1EL)) != p_46.f3) != l_91[7]);
        }
    }
    (*l_99) = (g_11.f0 < (((0x1ECA9F70L ^ 0x1A53783AL) < 0x1AL) >= (safe_lshift_func_uint16_t_u_s((~((((l_91[6] < (((!(safe_unary_minus_func_int16_t_s((l_91[4] != (l_97 == &g_8))))) ^ (l_91[7] != 2UL)) | l_91[7])) < g_77.f4) | 3L) || l_91[7])), 5))));
    return &g_41;
    /* statement id: 47 */
    //assert (func_44_rv == &g_41);
}


/* ------------------------------------------ */
/* 
 * reads : g_11.f4 g_8.f1 g_65 g_41
 * writes: g_11.f4 g_8.f1 g_41
 */
inline static const struct S0  func_49(uint32_t  p_50)
{ /* block id: 13 */
    const struct S0 l_66 = {-108,0x1528L,-1465,6539,1L};
    const int32_t *l_72 = &g_73;
    for (g_11.f4 = 0; (g_11.f4 > 8); g_11.f4 = safe_add_func_uint32_t_u_u(g_11.f4, 9))
    { /* block id: 16 */
        for (g_8.f1 = 0; (g_8.f1 <= 4); g_8.f1 += 1)
        { /* block id: 19 */
            int i;
            if (g_65[g_8.f1])
                break;
            for (p_50 = 0; (p_50 <= 4); p_50 += 1)
            { /* block id: 23 */
                return l_66;
            }
        }
        for (g_41 = 19; (g_41 < (-19)); g_41--)
        { /* block id: 29 */
            int32_t **l_69 = (void*)0;
            int32_t *l_71 = &g_41;
            int32_t **l_70[5][9][4] = {{{&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}}, {{&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}}, {{&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}}, {{&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}}, {{&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}, {&l_71, &l_71, &l_71, &l_71}}};
            const struct S0 l_74 = {-39,0x0A6AL,1792,7656,-7L};
            int i, j, k;
            l_72 = (void*)0;
            /* statement id: 30 */
            assert (l_72 == 0);
            return l_74;
        }
    }
    return l_66;
}


/* ------------------------------------------ */
/* 
 * reads : g_6.f4 g_41 g_8.f4 g_8.f1 g_8.f0
 * writes: g_41
 */
inline static uint8_t  func_55(const uint32_t  p_56)
{ /* block id: 10 */
    int32_t *l_60 = &g_41;
    struct S0 *l_61[3][4] = {{(void*)0, &g_11, &g_8, &g_11}, {(void*)0, &g_11, &g_8, &g_11}, {(void*)0, &g_11, &g_8, &g_11}};
    int i, j;
    (*l_60) = ((0L == ((safe_add_func_uint8_t_u_u((((l_60 == l_60) > (g_6[0].f4 < ((*l_60) & ((void*)0 != l_61[0][1])))) | (g_8.f4 > ((void*)0 == &l_61[1][2]))), p_56)) > g_8.f1)) != (*l_60));
    return g_8.f0;
}




/* ---------------------------------------- */
int main (void)
{
    int i;
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    for (i = 0; i < 1; i++)
    {

    }
    csmith_sink_ = g_8.f0;
    csmith_sink_ = g_8.f1;
    csmith_sink_ = g_8.f2;
    csmith_sink_ = g_8.f3;
    csmith_sink_ = g_8.f4;
    csmith_sink_ = g_11.f0;
    csmith_sink_ = g_11.f1;
    csmith_sink_ = g_11.f2;
    csmith_sink_ = g_11.f3;
    csmith_sink_ = g_11.f4;
    csmith_sink_ = g_41;
    for (i = 0; i < 5; i++)
    {
        csmith_sink_ = g_65[i];
    }
    csmith_sink_ = g_73;
    csmith_sink_ = g_77.f0;
    csmith_sink_ = g_77.f1;
    csmith_sink_ = g_77.f2;
    csmith_sink_ = g_77.f3;
    csmith_sink_ = g_77.f4;
    csmith_sink_ = g_139.f0.f0;
    csmith_sink_ = g_139.f0.f1;
    csmith_sink_ = g_139.f0.f2;
    csmith_sink_ = g_139.f0.f3;
    csmith_sink_ = g_139.f0.f4;
    csmith_sink_ = g_139.f1;
    csmith_sink_ = g_139.f2.f0;
    csmith_sink_ = g_139.f2.f1;
    csmith_sink_ = g_139.f2.f2;
    csmith_sink_ = g_139.f2.f3;
    csmith_sink_ = g_139.f2.f4;
    csmith_sink_ = g_139.f3;
    csmith_sink_ = g_139.f4;
    csmith_sink_ = g_139.f5;
    csmith_sink_ = g_139.f6;
    csmith_sink_ = g_139.f7;
    csmith_sink_ = g_139.f8;
    csmith_sink_ = g_225.f0.f0;
    csmith_sink_ = g_225.f0.f1;
    csmith_sink_ = g_225.f0.f2;
    csmith_sink_ = g_225.f0.f3;
    csmith_sink_ = g_225.f0.f4;
    csmith_sink_ = g_225.f1;
    csmith_sink_ = g_225.f2.f0;
    csmith_sink_ = g_225.f2.f1;
    csmith_sink_ = g_225.f2.f2;
    csmith_sink_ = g_225.f2.f3;
    csmith_sink_ = g_225.f2.f4;
    csmith_sink_ = g_225.f3;
    csmith_sink_ = g_225.f4;
    csmith_sink_ = g_225.f5;
    csmith_sink_ = g_225.f6;
    csmith_sink_ = g_225.f7;
    csmith_sink_ = g_225.f8;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 47
   depth: 1, occurrence: 9
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 25
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 0
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 19
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 22

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 88
   depth: 2, occurrence: 26
   depth: 3, occurrence: 2
   depth: 5, occurrence: 3
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 59

XXX times a variable address is taken: 178
XXX times a pointer is dereferenced on RHS: 23
breakdown:
   depth: 1, occurrence: 22
   depth: 2, occurrence: 1
XXX times a pointer is dereferenced on LHS: 31
breakdown:
   depth: 1, occurrence: 30
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 68

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 81
   level: 2, occurrence: 3
XXX number of pointers point to pointers: 30
XXX number of pointers point to scalars: 18
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 35.6
XXX average alias set size: 1.31

XXX times a non-volatile is read: 240
XXX times a non-volatile is write: 98
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 89
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 17
   depth: 2, occurrence: 12
   depth: 3, occurrence: 11
   depth: 4, occurrence: 14
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 23.5
XXX percentage an existing variable is used: 76.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

