/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --checksum --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --jumps --longlong --force-non-uniform-arrays --no-math64 --no-muls --no-packed-struct --paranoid --pointers --structs --inline-function --no-return-structs --no-arg-structs --no-dangling-global-pointers
 * Seed:      292043088
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = (-6L);
static int32_t *g_50 = &g_2;
static int32_t g_76 = (-1L);
static int32_t **g_79 = &g_50;
static int32_t ***g_78 = &g_79;
static int32_t ****g_77 = &g_78;
static int32_t g_102 = 0xB9AADFEDL;
static int16_t g_254 = 1L;
static int32_t *g_271 = &g_76;


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_1(void);
static uint32_t  func_8(uint8_t  p_9, uint32_t  p_10, int16_t  p_11, int32_t  p_12, int32_t  p_13);
inline static int16_t  func_21(uint8_t  p_22, int32_t  p_23, int16_t  p_24, uint16_t  p_25, int32_t  p_26);
inline static int32_t * func_29(uint8_t  p_30, uint8_t  p_31, int16_t  p_32, int32_t * p_33, int32_t * p_34);
inline static int32_t * func_36(int32_t  p_37, int32_t * p_38, int32_t * p_39, int16_t  p_40);
inline static int32_t * func_41(int16_t  p_42, int32_t * p_43, int16_t  p_44);
inline static uint8_t  func_45(int32_t * p_46, int8_t  p_47, int32_t  p_48, int32_t * p_49);
static uint16_t  func_52(int32_t * p_53, int32_t  p_54, uint16_t  p_55);
inline static int8_t  func_58(int32_t * p_59);
inline static int32_t  func_61(int32_t * p_62, int32_t * p_63, int8_t  p_64);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_50 g_77 g_76 g_78 g_79 g_102 g_254
 * writes: g_2 g_76 g_50 g_102 g_79 g_271
 */
inline static int16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_14 = 1L;
    int16_t l_28 = 0xB7E8L;
    int32_t *l_272 = &g_2;
    int32_t ****l_287 = &g_78;
    for (g_2 = 0; (g_2 == 29); ++g_2)
    { /* block id: 3 */
        uint32_t l_27 = 0x4EF66B17L;
        int32_t ****l_288 = &g_78;
        int32_t *l_289 = &g_76;
        if (((safe_mod_func_int8_t_s_s((!(func_8(l_14, g_2, g_2, (safe_mod_func_int32_t_s_s((safe_sub_func_int32_t_s_s(((safe_rshift_func_uint16_t_u_s(g_2, func_21((g_2 & l_14), g_2, g_2, l_27, l_28))) <= g_2), 0L)), l_28)), g_2) , l_27)), 8UL)) | (-4L)))
        { /* block id: 119 */
            g_271 = (**g_78);
            (***g_77) = l_272;
            /* statement id: 121 */
            assert (g_50 == &g_2);
        }
        else
        { /* block id: 122 */
            int32_t l_277 = 0x6E1E6A54L;
            int32_t ****l_282 = (void*)0;
            (**g_79) = ((0UL >= (0x10L < (((safe_add_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_u(0x29L, 3)), ((l_27 > (l_277 & (safe_lshift_func_uint16_t_u_s(0x9CB3L, (safe_lshift_func_int8_t_s_u(((l_282 == ((safe_add_func_uint32_t_u_u((((safe_mod_func_int8_t_s_s(((void*)0 == l_287), 0x2AL)) && g_76) > g_76), 0x80ABBFA4L)) , l_288)) & g_254), g_2)))))) <= 1UL))) && g_254) < 0x9984L))) == g_76);
        }
        l_289 = (***l_288);
        /* statement id: 125 */
        assert (l_289 == &g_76 || l_289 == &g_2);
    }
    /* facts after for loop */
    assert (g_50 == &g_76 || g_50 == &g_2);
    return (****l_287);
}


/* ------------------------------------------ */
/* 
 * reads : g_102 g_77 g_78 g_79 g_50 g_2 g_76 g_254
 * writes: g_102 g_76 g_50 g_79
 */
static uint32_t  func_8(uint8_t  p_9, uint32_t  p_10, int16_t  p_11, int32_t  p_12, int32_t  p_13)
{ /* block id: 76 */
    int32_t ****l_173 = (void*)0;
    int32_t l_189 = 0L;
    int32_t **l_266 = (void*)0;
    if ((l_173 == (void*)0))
    { /* block id: 77 */
        uint16_t l_184 = 65535UL;
        int32_t ***l_205 = &g_79;
        int32_t *****l_213 = &l_173;
        for (g_102 = (-12); (g_102 != (-28)); g_102 = safe_sub_func_int16_t_s_s(g_102, 1))
        { /* block id: 80 */
            int32_t ****l_178 = &g_78;
            int16_t l_206 = 0x0903L;
            (****g_77) = p_11;
            if ((safe_sub_func_uint32_t_u_u(((&g_78 == (p_13 , l_178)) < ((safe_sub_func_uint16_t_u_u(((((g_2 || ((((((((safe_lshift_func_int8_t_s_s((+(l_184 < l_184)), g_102)) <= ((safe_div_func_int8_t_s_s((((safe_rshift_func_int8_t_s_s(p_12, 1)) , (1UL | 0xADL)) >= g_2), 0x6FL)) <= (****l_178))) == (-3L)) , 0xA1L) >= l_189) <= 0xE9429D60L) && 1L) >= 0xADFA8AF1L)) < p_9) <= 0x87A3L) == 0x28L), 1L)) , g_102)), p_10)))
            { /* block id: 82 */
                uint16_t l_194 = 0x8BE2L;
                (****g_77) = ((safe_lshift_func_uint8_t_u_s(0x80L, 1)) >= (((**l_178) == (void*)0) > ((safe_rshift_func_int8_t_s_s(((0x5BL & l_194) | g_76), 0)) || ((-1L) < (((g_102 | ((safe_rshift_func_int8_t_s_u(1L, p_11)) , p_10)) | 4294967294UL) > g_76)))));
                (*g_79) = ((((safe_rshift_func_uint16_t_u_u((((-1L) == 0x3BL) & ((**g_79) | (((safe_add_func_uint8_t_u_u((((g_2 || (safe_div_func_uint8_t_u_u(g_102, (-1L)))) , g_2) < (((safe_lshift_func_uint8_t_u_u((((*g_77) != (g_102 , l_205)) > g_2), 0)) & (****l_178)) , 0x43L)), p_12)) , l_206) >= (****l_178)))), g_76)) , 247UL) >= p_10) , (*g_79));
                for (p_13 = 10; (p_13 == (-6)); p_13 = safe_sub_func_uint16_t_u_u(p_13, 3))
                { /* block id: 87 */
                    uint32_t l_209 = 4294967293UL;
                    if (l_209)
                        break;
                    (***l_178) = (**g_78);
                    return p_11;
                }
                return p_10;
            }
            else
            { /* block id: 93 */
                int32_t *l_224 = &l_189;
                (****l_178) = (0x093934F9L >= (safe_rshift_func_int8_t_s_u((((((~((0xF5L > ((void*)0 != l_213)) , ((((((((p_12 , g_76) < (safe_lshift_func_int8_t_s_s((safe_div_func_int32_t_s_s(((safe_div_func_int8_t_s_s((safe_mod_func_uint16_t_u_u(((((((((safe_mod_func_uint8_t_u_u(249UL, p_11)) < ((((**g_78) != l_224) || g_102) || 255UL)) >= g_102) , (*g_77)) == (void*)0) , p_10) , g_102) ^ 0xACL), p_11)), 0x4DL)) <= 0xF2E49928L), 1UL)), p_10))) || p_13) , (***g_78)) , (**g_79)) >= g_76) < p_10) , g_2))) , (*l_224)) <= (****l_178)) && g_76) != 0xF034L), 0)));
            }
        }
        (**g_77) = (*l_205);
        (**g_78) = ((((***l_205) ^ (safe_lshift_func_uint16_t_u_s((safe_mod_func_int32_t_s_s((safe_mod_func_int32_t_s_s(((safe_rshift_func_int16_t_s_s((((((((4L >= ((g_76 == (safe_rshift_func_uint16_t_u_u((((safe_mod_func_int16_t_s_s((safe_sub_func_int8_t_s_s(((safe_mod_func_int16_t_s_s((safe_rshift_func_uint8_t_u_s((safe_lshift_func_uint8_t_u_u(g_102, (safe_unary_minus_func_int8_t_s((0UL & (safe_add_func_uint16_t_u_u((l_189 , (safe_lshift_func_uint16_t_u_u(((safe_sub_func_uint32_t_u_u((((((((*g_79) == (*g_79)) == g_102) ^ g_76) ^ p_13) >= 0x62L) || g_102), g_76)) && p_12), (***l_205)))), g_102))))))), 4)), p_12)) & 0xFDL), 5UL)), p_13)) != p_13) >= 0xF1L), g_254))) > 0x11B6L)) != p_13) >= p_12) || 1L) , (***l_205)) , p_10) == 0xF9CDL), 1)) >= (***l_205)), p_13)), g_76)), 3))) & p_11) , (*g_79));
    }
    else
    { /* block id: 99 */
        return g_254;
    }
    if ((safe_mul_func_int8_t_s_s((-9L), (g_2 != l_189))))
    { /* block id: 102 */
        int32_t l_257 = (-1L);
        uint32_t l_258 = 18446744073709551615UL;
        l_258 = (l_257 != g_76);
    }
    else
    { /* block id: 104 */
        int16_t l_259 = 7L;
        return l_259;
    }
    (*g_79) = func_36(p_13, func_41(((l_189 , ((safe_sub_func_uint32_t_u_u(p_9, (g_102 , (***g_78)))) && ((safe_mod_func_uint16_t_u_u((safe_add_func_int8_t_s_s(((((((l_266 == (*g_78)) | p_12) , p_13) != g_102) > (-3L)) || 1L), (-3L))), p_10)) ^ p_10))) || g_102), &l_189, g_76), &l_189, p_13);
    for (l_189 = 28; (l_189 == (-6)); --l_189)
    { /* block id: 110 */
        (****g_77) = p_9;
        for (g_102 = 28; (g_102 <= 7); --g_102)
        { /* block id: 114 */
            (***g_77) = (***g_77);
        }
    }
    return p_9;
}


/* ------------------------------------------ */
/* 
 * reads : g_50 g_2 g_77 g_76 g_78 g_79 g_102
 * writes: g_76 g_50 g_102
 */
inline static int16_t  func_21(uint8_t  p_22, int32_t  p_23, int16_t  p_24, uint16_t  p_25, int32_t  p_26)
{ /* block id: 4 */
    uint32_t l_35 = 0xA5F27A41L;
    int32_t *l_51 = (void*)0;
    (***g_77) = func_29(l_35, ((p_22 ^ p_22) , p_24), p_24, (l_35 , func_36(p_24, func_41((((func_45((((void*)0 == g_50) , l_51), p_24, p_23, l_51) >= g_2) , g_2) && (-2L)), l_51, p_24), l_51, p_26)), l_51);
    /* statement id: 74 */
    assert (g_50 == &g_76);
    return l_35;
}


/* ------------------------------------------ */
/* 
 * reads : g_78 g_79 g_50
 * writes:
 */
inline static int32_t * func_29(uint8_t  p_30, uint8_t  p_31, int16_t  p_32, int32_t * p_33, int32_t * p_34)
{ /* block id: 72 */
    return (**g_78);
    /* statement id: 73 */
    //assert (func_29_rv == &g_76);
}


/* ------------------------------------------ */
/* 
 * reads : g_76 g_77 g_78 g_79 g_50 g_102 g_2
 * writes: g_76 g_102 g_50
 */
inline static int32_t * func_36(int32_t  p_37, int32_t * p_38, int32_t * p_39, int16_t  p_40)
{ /* block id: 46 */
    int16_t l_133 = 0x0543L;
    int32_t ****l_172 = &g_78;
    for (p_37 = 4; (p_37 != 12); p_37++)
    { /* block id: 49 */
        int32_t ****l_122 = &g_78;
        for (p_40 = 18; (p_40 <= (-4)); p_40--)
        { /* block id: 52 */
            int32_t *****l_123 = (void*)0;
            int32_t *****l_124 = &l_122;
            int32_t l_128 = 0x1667F30DL;
            (*l_124) = l_122;
            for (g_76 = 0; (g_76 <= (-22)); g_76--)
            { /* block id: 56 */
                int32_t ****l_127 = &g_78;
                l_128 = (((((****g_77) , l_127) != (void*)0) , (**l_127)) != (void*)0);
            }
            (****l_122) = (safe_div_func_uint32_t_u_u((((((((***g_78) >= ((*g_77) == (**l_124))) >= (g_102 < (((0UL && ((*g_77) != (**l_124))) > g_102) && (****l_122)))) <= p_40) , l_133) < 0x71L) || l_133), l_133));
            (**g_79) = 8L;
        }
        for (g_102 = 0; (g_102 != 8); ++g_102)
        { /* block id: 64 */
        }
    }
    (**g_78) = func_41(((+((*p_38) == ((((0UL && (safe_lshift_func_uint16_t_u_s((safe_sub_func_uint16_t_u_u(((p_40 == 250UL) && (1UL == (0UL == ((l_133 || (safe_lshift_func_uint8_t_u_u((((*g_79) == ((((safe_rshift_func_uint16_t_u_u(p_37, 1)) != g_2) == g_102) , (*g_79))) , p_37), 2))) != (*p_38))))), 0xFC91L)), g_102))) || l_133) || p_37) < p_40))) , l_133), p_39, l_133);
    (****g_77) = ((safe_div_func_int32_t_s_s((safe_lshift_func_int16_t_s_s(g_76, 0)), (+(safe_sub_func_int32_t_s_s(0x38BE2463L, (**g_79)))))) != (((safe_sub_func_int16_t_s_s((((3L == (0UL != g_76)) | (safe_mod_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u((((safe_div_func_int16_t_s_s((l_133 ^ (l_172 == l_172)), (****l_172))) || g_76) , 0xD8L), g_2)), p_37))) & (****l_172)), 0xE74DL)) ^ p_40) , (****l_172)));
    return (***l_172);
    /* statement id: 71 */
    //assert (func_36_rv == &g_76);
}


/* ------------------------------------------ */
/* 
 * reads : g_79 g_50
 * writes: g_50
 */
inline static int32_t * func_41(int16_t  p_42, int32_t * p_43, int16_t  p_44)
{ /* block id: 42 */
    int32_t *l_117 = &g_76;
    (*g_79) = p_43;
    /* statement id: 43 */
    //assert (g_50 == 0 || g_50 == &l_189);
    (*g_79) = l_117;
    /* statement id: 44 */
    assert (g_50 == &g_76);
    return (*g_79);
    /* statement id: 45 */
    //assert (func_41_rv == &g_76);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_77 g_76 g_78 g_79 g_50 g_102
 * writes: g_76 g_50 g_102
 */
inline static uint8_t  func_45(int32_t * p_46, int8_t  p_47, int32_t  p_48, int32_t * p_49)
{ /* block id: 5 */
    int32_t *l_60 = &g_2;
    int32_t ****l_95 = &g_78;
    int32_t *l_96 = &g_76;
    int32_t ****l_114 = &g_78;
    uint8_t l_115 = 253UL;
    (*l_96) = (func_52(&g_2, (safe_lshift_func_int16_t_s_s((((g_2 > (func_58(l_60) , ((*l_60) >= ((((safe_rshift_func_int8_t_s_u((safe_rshift_func_uint16_t_u_s((p_47 < (((p_48 == (+(l_95 == &g_78))) < (-9L)) == (*l_60))), 6)), (****l_95))) != 0x7944L) , (***l_95)) != &p_48)))) , 1L) , p_47), 15)), p_48) , (**g_79));
    for (g_76 = 0; (g_76 > (-26)); g_76 = safe_sub_func_int8_t_s_s(g_76, 6))
    { /* block id: 26 */
        (***l_95) = &p_48;
        /* statement id: 27 */
        assert (g_50 == &p_48);
        return p_47;
        /* statement id: 28 */
        //assert (g_50 == dangling);
    }
    for (g_76 = 6; (g_76 != (-22)); g_76 = safe_sub_func_uint16_t_u_u(g_76, 4))
    { /* block id: 32 */
        uint16_t l_101 = 7UL;
        g_102 = l_101;
    }
    if ((safe_sub_func_int8_t_s_s(((((**g_79) & (safe_div_func_int32_t_s_s(((safe_sub_func_int16_t_s_s((((((((((void*)0 == (*l_95)) , 0xB2A1L) & ((void*)0 == &g_78)) != (safe_mod_func_int8_t_s_s(0x6AL, (((*l_96) > (****l_95)) , g_2)))) , (*l_96)) || (*l_96)) && (**g_79)) , p_47), (-1L))) <= p_48), g_76))) , (void*)0) != (**l_95)), (*l_60))))
    { /* block id: 35 */
        uint32_t l_111 = 0x6D896CD2L;
        int32_t ****l_113 = (void*)0;
        (*g_79) = &p_48;
        /* statement id: 36 */
        assert (g_50 == &p_48);
        (***g_78) = (((8UL != (&g_78 != (void*)0)) | l_111) ^ (((p_48 == ((safe_unary_minus_func_uint8_t_u((l_113 == l_114))) < p_48)) | (((g_102 | l_115) != g_102) , (**g_79))) >= g_2));
    }
    else
    { /* block id: 38 */
        uint32_t l_116 = 0x62C87538L;
        l_116 = (0x2AL != p_47);
    }
    /* facts after branching */
    assert (g_50 == &g_2 || g_50 == &p_48 || g_50 == &g_76);
    return p_48;
    /* statement id: 41 */
    //assert (g_50 == &g_2 || g_50 == dangling || g_50 == &g_76);
}


/* ------------------------------------------ */
/* 
 * reads : g_77 g_78 g_79 g_50
 * writes: g_50
 */
static uint16_t  func_52(int32_t * p_53, int32_t  p_54, uint16_t  p_55)
{ /* block id: 20 */
    (**g_78) = (***g_77);
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_77 g_76 g_78 g_79 g_50
 * writes: g_76
 */
inline static int8_t  func_58(int32_t * p_59)
{ /* block id: 6 */
    int32_t *l_65 = &g_2;
    int32_t *l_89 = &g_76;
    p_59 = &g_2;
    (*l_89) = func_61(l_65, &g_2, (g_2 > (*l_65)));
    return (*l_89);
}


/* ------------------------------------------ */
/* 
 * reads : g_77 g_76 g_2 g_78 g_79 g_50
 * writes: g_76
 */
inline static int32_t  func_61(int32_t * p_62, int32_t * p_63, int8_t  p_64)
{ /* block id: 8 */
    int8_t l_68 = 0L;
    int32_t ***l_69 = (void*)0;
    int32_t **l_71 = &g_50;
    int32_t ***l_70 = &l_71;
    int32_t ****l_80 = (void*)0;
    int32_t l_88 = 0x9AA6B35EL;
    (*l_70) = ((4294967289UL <= ((l_68 <= (&p_63 != &g_50)) <= 0x28C040C8L)) , &g_50);
    for (p_64 = 0; (p_64 <= (-11)); --p_64)
    { /* block id: 12 */
        uint32_t l_74 = 18446744073709551615UL;
        int32_t *l_75 = &g_76;
        (*l_75) = (l_74 != (1UL >= l_74));
        l_80 = g_77;
        /* statement id: 14 */
        assert (l_80 == &g_78);
        (*l_75) = ((*l_75) , (safe_add_func_uint8_t_u_u(((((((0xEC37461BL <= ((0x8BF5L & (+((g_2 || (-2L)) != (g_76 || g_76)))) & (safe_mod_func_uint16_t_u_u((*l_75), (safe_div_func_uint16_t_u_u(((((g_76 <= p_64) | 0x03ACL) , &l_69) == (void*)0), l_88)))))) , g_76) , (void*)0) != (void*)0) | p_64) && g_76), g_76)));
    }
    /* facts after for loop */
    assert (l_80 == &g_78 || l_80 == 0);
    return (***g_78);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_76, "g_76", print_hash_value);
    transparent_crc(g_102, "g_102", print_hash_value);
    transparent_crc(g_254, "g_254", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 49
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 15
   depth: 3, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 2
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 34, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 47

XXX times a variable address is taken: 43
XXX times a pointer is dereferenced on RHS: 73
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 17
   depth: 3, occurrence: 13
   depth: 4, occurrence: 14
XXX times a pointer is dereferenced on LHS: 31
breakdown:
   depth: 1, occurrence: 11
   depth: 2, occurrence: 7
   depth: 3, occurrence: 7
   depth: 4, occurrence: 6
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 184

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 122
   level: 2, occurrence: 65
   level: 3, occurrence: 50
   level: 4, occurrence: 62
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 23
XXX number of pointers point to scalars: 24
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.7
XXX average alias set size: 1.19

XXX times a non-volatile is read: 457
XXX times a non-volatile is write: 121
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 70
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 21
   depth: 2, occurrence: 10
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3

XXX percentage a fresh-made variable is used: 13.4
XXX percentage an existing variable is used: 86.6
********************* end of statistics **********************/

