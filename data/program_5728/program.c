/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --jumps --longlong --no-force-non-uniform-arrays --math64 --muls --no-packed-struct --no-paranoid --pointers --structs --inline-function --return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      4383975449633274815
 */

#include "csmith.h"

volatile uint64_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   signed f1 : 3;
   uint8_t  f2;
   unsigned f3 : 19;
   unsigned f4 : 25;
   signed f5 : 24;
   signed f6 : 28;
   uint64_t  f7;
   signed f8 : 4;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = (-1L);
static int32_t g_15 = 0L;
static struct S0 g_71 = {0xB13F4B1AL,-0,0x00L,373,166,-397,-11431,0x30E5DEFA766E9B1CLL,-0};
static int32_t *g_100 = &g_15;
static int32_t **g_99 = &g_100;
static struct S0 g_108 = {1UL,1,1UL,290,59,-3775,-5613,0x6F57B8DD85FC26EALL,2};
static int32_t g_131 = 0L;
static int32_t g_139 = 2L;
static int32_t *g_232 = &g_139;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
inline static int32_t  func_5(int32_t  p_6, int16_t  p_7, uint16_t  p_8, uint8_t  p_9, uint16_t  p_10);
inline static int32_t * func_18(int32_t * p_19, int32_t * p_20, uint32_t  p_21, int32_t  p_22, int64_t  p_23);
inline static int32_t  func_27(uint32_t  p_28, int32_t * p_29, int8_t  p_30);
static int64_t  func_31(uint64_t  p_32);
static int32_t ** func_39(uint16_t  p_40);
static int32_t * func_42(int32_t ** const  p_43, uint16_t  p_44, uint32_t  p_45, int32_t  p_46, const uint64_t  p_47);
inline static const uint16_t  func_56(int64_t  p_57, int8_t  p_58, int32_t  p_59);
inline static int16_t  func_62(uint32_t  p_63, int32_t ** const  p_64);
inline static int16_t  func_69(int32_t * const * const  p_70);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_15 g_71 g_99 g_108.f2 g_108.f3 g_108.f0 g_131 g_100 g_108.f4 g_108.f1 g_108 g_139 g_232
 * writes: g_2 g_15 g_71 g_100 g_131 g_108.f0 g_108 g_139 g_99 g_232
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_12 = 0UL;
    uint32_t l_13 = 18446744073709551615UL;
    int32_t *l_24 = &g_15;
    int32_t l_317 = 1L;
    struct S0 *l_349 = &g_108;
    struct S0 * const *l_351 = &l_349;
    struct S0 * const **l_350 = &l_351;
    for (g_2 = 0; (g_2 != 26); g_2++)
    { /* block id: 3 */
        int64_t l_11 = 4L;
        int32_t *l_14 = &g_15;
        (*l_14) = func_5((l_11 ^ l_12), g_2, (g_2 && (l_13 <= g_2)), g_2, l_12);
    }
    for (l_12 = (-24); (l_12 < 38); l_12++)
    { /* block id: 10 */
        uint32_t l_255 = 0UL;
        int32_t **l_310 = &g_232;
        struct S0 *l_316 = &g_71;
        (*l_310) = func_18(&g_2, l_24, (((safe_add_func_int32_t_s_s(func_27(g_2, &g_15, func_5(func_5((func_31((((safe_sub_func_uint16_t_u_u(((*l_24) > ((safe_add_func_uint16_t_u_u((safe_sub_func_int8_t_s_s(g_15, (*l_24))), 1UL)) ^ 65535UL)), 0x95D7L)) && g_15) <= g_15)) & l_13), g_2, g_2, g_2, g_2), l_255, g_2, g_2, g_2)), 0x4DA8DAF7L)) && (*l_24)) && g_71.f0), l_255, l_255);
        for (g_15 = 0; (g_15 > 10); g_15 = safe_add_func_int32_t_s_s(g_15, 7))
        { /* block id: 153 */
            int32_t l_324 = 0x57234875L;
            (*g_99) = func_42(&g_100, ((**l_310) || (safe_unary_minus_func_uint32_t_u((**l_310)))), g_131, (*g_232), ((l_316 == &g_108) && ((void*)0 == (*g_99))));
            l_317 = ((*l_24) ^ (4UL ^ 5UL));
            for (g_139 = 0; (g_139 >= (-11)); g_139--)
            { /* block id: 158 */
                for (g_108.f7 = 3; (g_108.f7 <= 41); g_108.f7 = safe_add_func_int32_t_s_s(g_108.f7, 8))
                { /* block id: 161 */
                    if ((**g_99))
                        break;
                }
                if ((*g_100))
                    continue;
            }
            for (g_131 = 0; (g_131 >= (-13)); g_131 = safe_sub_func_int32_t_s_s(g_131, 6))
            { /* block id: 168 */
                return l_324;
            }
        }
        (**l_310) = ((safe_rshift_func_int8_t_s_s((*l_24), ((safe_lshift_func_int16_t_s_s((safe_add_func_uint64_t_u_u((**l_310), (safe_sub_func_int16_t_s_s((*l_24), (-8L))))), 7)) | ((((safe_mod_func_int8_t_s_s(((&g_232 == l_310) ^ (((safe_add_func_int16_t_s_s((g_71.f1 < (safe_mod_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u(7UL, (safe_unary_minus_func_int32_t_s((0x562BE3816ABE45C5LL <= 18446744073709551609UL))))), (**l_310)))), g_108.f0)) <= (*l_24)) || (*l_24))), g_108.f6)) | 0UL) <= (**l_310)) >= 0xE2BD8798L)))) | g_108.f3);
    }
    (*l_24) = ((*l_24) != (0xFE32FE1A19990F13LL != ((safe_mul_func_uint16_t_u_u(((((&g_100 != &g_232) >= (~(*l_24))) ^ (safe_rshift_func_int8_t_s_u(((&l_317 == (void*)0) | (safe_rshift_func_int8_t_s_u((*l_24), 1))), 3))) || ((void*)0 == l_349)), (*l_24))) || (*l_24))));
    (*l_350) = (void*)0;
    return g_71.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_2
 * writes:
 */
inline static int32_t  func_5(int32_t  p_6, int16_t  p_7, uint16_t  p_8, uint8_t  p_9, uint16_t  p_10)
{ /* block id: 4 */
    return g_2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_18(int32_t * p_19, int32_t * p_20, uint32_t  p_21, int32_t  p_22, int64_t  p_23)
{ /* block id: 148 */
    int32_t *l_309 = &g_15;
    return l_309;
}


/* ------------------------------------------ */
/* 
 * reads : g_15
 * writes:
 */
inline static int32_t  func_27(uint32_t  p_28, int32_t * p_29, int8_t  p_30)
{ /* block id: 119 */
    const uint32_t l_258 = 0x66B9BC0EL;
    int32_t ***l_269 = &g_99;
    int32_t ****l_306 = (void*)0;
    int32_t ****l_307 = &l_269;
    return (*p_29);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_15 g_71 g_99 g_108.f2 g_108.f3 g_108.f0 g_131 g_100 g_108.f4 g_108.f1 g_108 g_139 g_232
 * writes: g_71 g_100 g_131 g_108.f0 g_108 g_15 g_139 g_99
 */
static int64_t  func_31(uint64_t  p_32)
{ /* block id: 11 */
    uint8_t l_41 = 0x72L;
    int32_t ***l_238 = &g_99;
    (*l_238) = func_39(l_41);
    (*g_232) = ((safe_mod_func_int64_t_s_s(((((p_32 != ((g_108.f8 | ((safe_lshift_func_uint8_t_u_u(((safe_lshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s(((((safe_sub_func_uint8_t_u_u((p_32 && 0x1FDDA6B179F2A66DLL), ((***l_238) < p_32))) && ((safe_add_func_uint32_t_u_u((***l_238), (p_32 && ((safe_rshift_func_uint8_t_u_u((safe_mod_func_int32_t_s_s((g_108.f4 < 1UL), p_32)), p_32)) < 0x7CL)))) <= p_32)) ^ (***l_238)) >= 0x5C1137C9L), 13)), g_108.f2)) ^ p_32), 1)) != 0xC8A45E37A9842A2DLL)) | 0x8AE9C4D8L)) >= g_71.f7) && (*g_232)) == (***l_238)), 18446744073709551615UL)) | (***l_238));
    return (***l_238);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_15 g_71 g_99 g_108.f2 g_108.f3 g_108.f0 g_131 g_100 g_108.f4 g_108.f1 g_108 g_139 g_232
 * writes: g_71 g_100 g_131 g_108.f0 g_108 g_15 g_139
 */
static int32_t ** func_39(uint16_t  p_40)
{ /* block id: 12 */
    int32_t *l_49 = &g_2;
    int32_t ** const l_48 = &l_49;
    (*l_48) = func_42(l_48, p_40, (safe_add_func_int32_t_s_s(((safe_add_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u(func_56(((safe_mul_func_uint16_t_u_u(((((((((**l_48) <= g_2) >= (func_5(g_15, func_62((func_5(g_15, p_40, p_40, p_40, p_40) < 0x8743L), &l_49), (**l_48), g_108.f2, p_40) & g_108.f2)) | (*l_49)) >= (**l_48)) >= 18446744073709551606UL) == p_40) <= g_108.f1), g_2)) ^ 1L), (*l_49), p_40), (*l_49))), g_139)) >= (*l_49)), p_40)), p_40, p_40);
    for (g_108.f7 = 0; (g_108.f7 >= 58); g_108.f7 = safe_add_func_uint16_t_u_u(g_108.f7, 7))
    { /* block id: 111 */
        (*g_100) = (safe_rshift_func_int8_t_s_s(p_40, g_131));
    }
    (*g_99) = (*l_48);
    return &g_100;
}


/* ------------------------------------------ */
/* 
 * reads : g_99 g_232 g_100
 * writes: g_100 g_232
 */
static int32_t * func_42(int32_t ** const  p_43, uint16_t  p_44, uint32_t  p_45, int32_t  p_46, const uint64_t  p_47)
{ /* block id: 103 */
    int32_t *l_233 = &g_2;
    (*g_99) = (*p_43);
    (*g_99) = g_232;
    (*p_43) = (void*)0;
    return l_233;
}


/* ------------------------------------------ */
/* 
 * reads : g_108 g_99 g_100 g_15
 * writes: g_108 g_100 g_15
 */
inline static const uint16_t  func_56(int64_t  p_57, int8_t  p_58, int32_t  p_59)
{ /* block id: 84 */
    struct S0 *l_204 = &g_108;
    int32_t * const *l_209 = &g_100;
    uint8_t l_216 = 0xC1L;
    (*l_204) = g_108;
    if (((safe_add_func_uint16_t_u_u(0x36FDL, (safe_lshift_func_int16_t_s_s((l_209 == (void*)0), 8)))) ^ (&l_209 == (void*)0)))
    { /* block id: 86 */
        int32_t **l_210 = (void*)0;
        int32_t ***l_211 = &l_210;
        (*l_211) = l_210;
        (*g_99) = (void*)0;
        return g_108.f4;
    }
    else
    { /* block id: 90 */
        int64_t l_217 = 0xB52B2A35B8B2F709LL;
        int32_t *l_231 = &g_2;
        for (g_108.f0 = 0; (g_108.f0 >= 1); g_108.f0 = safe_add_func_uint32_t_u_u(g_108.f0, 5))
        { /* block id: 93 */
            struct S0 l_214 = {0x148778A6L,0,0xAEL,495,4425,-1607,14640,9UL,-0};
            struct S0 *l_215 = &l_214;
            int32_t *l_218 = &g_15;
            (*l_215) = l_214;
            if (l_216)
                continue;
            if (p_57)
                continue;
            (*l_218) = l_217;
        }
        (*g_99) = &g_15;
        (**g_99) = (safe_add_func_uint64_t_u_u((safe_add_func_uint16_t_u_u((p_57 >= (safe_add_func_int8_t_s_s((safe_add_func_int8_t_s_s(((safe_mul_func_uint8_t_u_u(p_57, l_217)) | (254UL >= (safe_sub_func_uint64_t_u_u(g_108.f3, ((*g_99) != l_231))))), 0x6BL)), (**l_209)))), 65529UL)), p_59));
    }
    return (**l_209);
}


/* ------------------------------------------ */
/* 
 * reads : g_71 g_99 g_15 g_108.f2 g_2 g_108.f3 g_108.f0 g_131 g_100 g_108.f4 g_108.f1
 * writes: g_71 g_100 g_131 g_108.f0
 */
inline static int16_t  func_62(uint32_t  p_63, int32_t ** const  p_64)
{ /* block id: 13 */
    int32_t *l_68 = &g_2;
    int32_t **l_67 = &l_68;
    struct S0 * const l_107 = &g_108;
    int8_t l_126 = 0x62L;
    int32_t *l_171 = &g_131;
    int32_t ***l_203 = &l_67;
    if (((safe_rshift_func_int8_t_s_u(func_5(((void*)0 == l_67), func_69(&l_68), (((l_107 == (void*)0) == (((safe_mod_func_int64_t_s_s((((safe_add_func_uint32_t_u_u(((((((safe_mod_func_int32_t_s_s(((g_108.f2 <= (safe_mod_func_uint64_t_u_u((safe_rshift_func_int16_t_s_s(p_63, (safe_mul_func_int16_t_s_s((safe_rshift_func_uint8_t_u_s((safe_add_func_int32_t_s_s((((+((**l_67) || (*l_68))) && (**l_67)) <= p_63), 1UL)), 1)), p_63)))), (*l_68)))) == 0x7F7B61520CAD1337LL), (**p_64))) != g_108.f3) < p_63) | g_108.f0) || (*l_68)) <= p_63), 0L)) > 0x1EL) < 4294967294UL), l_126)) == (*l_68)) >= p_63)) <= g_2), p_63, p_63), 5)) <= 0x6A0CL))
    { /* block id: 25 */
        int32_t *l_132 = (void*)0;
        int32_t *l_133 = &g_131;
        const struct S0 l_173 = {1UL,1,0x30L,696,2445,350,-10950,0x067309CB0568AF3DLL,3};
        (*l_133) = (safe_mod_func_int8_t_s_s(0xD2L, (((void*)0 != &g_71) || (safe_rshift_func_uint8_t_u_s(((0UL | p_63) < 1UL), ((g_131 | 0xF1L) || g_108.f3))))));
        (*g_99) = (*p_64);
        for (g_131 = 0; (g_131 == (-12)); g_131 = safe_sub_func_uint16_t_u_u(g_131, 9))
        { /* block id: 30 */
            int32_t *l_138 = &g_139;
            int32_t l_163 = 0x698991D7L;
            struct S0 l_172 = {0x7502D142L,-0,3UL,295,1189,-537,6887,0x29E39DADE5F6D2A8LL,1};
        }
        for (g_108.f0 = (-24); (g_108.f0 >= 47); g_108.f0 = safe_add_func_uint32_t_u_u(g_108.f0, 2))
        { /* block id: 64 */
            (*g_99) = (*g_99);
        }
    }
    else
    { /* block id: 67 */
        const struct S0 *l_181 = &g_108;
        int32_t l_184 = 0x8D028DA7L;
        if ((safe_lshift_func_int8_t_s_s((safe_sub_func_int64_t_s_s((0xE6340B5CEBA8194CLL == ((((((l_181 != &g_108) > 1L) | ((safe_rshift_func_uint8_t_u_u((0x39D1L > g_15), 2)) <= (g_108.f0 || l_184))) != 1L) && (*l_171)) | l_184)), g_71.f0)), 2)))
        { /* block id: 68 */
            int32_t *l_189 = &g_131;
            for (p_63 = (-9); (p_63 <= 40); p_63++)
            { /* block id: 71 */
                int32_t *l_188 = &g_2;
                (*l_171) = (((!(l_188 != l_189)) >= (l_107 == (void*)0)) == (safe_mod_func_uint64_t_u_u(((((((&g_71 != &g_71) > ((safe_add_func_int32_t_s_s((*l_189), p_63)) && ((safe_mul_func_int16_t_s_s(((safe_sub_func_uint32_t_u_u(((+((safe_rshift_func_int16_t_s_s(g_131, 6)) & (**p_64))) && 7UL), (*l_188))) <= (*l_189)), g_108.f4)) == 0x169FL))) != p_63) < (**l_67)) < (*l_189)) & (*l_68)), 1UL)));
            }
            return (*l_171);
        }
        else
        { /* block id: 75 */
            (*l_171) = (safe_lshift_func_uint8_t_u_s(g_108.f1, 0));
            (*l_67) = (*p_64);
        }
    }
    (*g_99) = (*p_64);
    (*l_203) = &g_100;
    (*l_67) = (*l_67);
    return (*l_171);
}


/* ------------------------------------------ */
/* 
 * reads : g_71 g_99 g_15
 * writes: g_71 g_100
 */
inline static int16_t  func_69(int32_t * const * const  p_70)
{ /* block id: 14 */
    struct S0 *l_72 = &g_71;
    int32_t l_93 = 8L;
    (*l_72) = g_71;
    for (g_71.f0 = 6; (g_71.f0 >= 8); ++g_71.f0)
    { /* block id: 18 */
        const int16_t l_81 = 0xA342L;
        uint32_t l_91 = 0UL;
        struct S0 *l_92 = (void*)0;
        int32_t l_94 = (-7L);
        l_94 = (safe_sub_func_uint8_t_u_u((((safe_sub_func_uint32_t_u_u((safe_mul_func_uint8_t_u_u((l_81 ^ (safe_rshift_func_int8_t_s_u(((safe_mod_func_int16_t_s_s((safe_rshift_func_int16_t_s_s(0xE389L, (safe_mul_func_int8_t_s_s(((-8L) && (safe_unary_minus_func_uint8_t_u(((((l_91 < g_71.f0) < ((2UL > ((void*)0 != l_92)) == l_93)) != g_71.f0) < g_71.f1)))), l_81)))), l_93)) <= l_91), l_81))), l_93)), g_71.f7)) < 0x7EF9B05DL) || g_71.f7), 0L));
        g_71.f8 = 0x8BB411E1L;
        l_94 = (safe_mul_func_uint16_t_u_u((0x8C2FCB8FL || ((((&g_71 == l_92) >= 0x572A9630A554F1F2LL) >= 0xDC7CBFABL) <= ((safe_add_func_int8_t_s_s((g_99 != &g_100), (safe_rshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s(l_91, (safe_sub_func_int64_t_s_s((l_93 ^ 6L), l_81)))), l_93)))) && g_15))), l_93));
    }
    (*g_99) = &l_93;
    return l_93;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_2;
    csmith_sink_ = g_15;
    csmith_sink_ = g_71.f0;
    csmith_sink_ = g_71.f1;
    csmith_sink_ = g_71.f2;
    csmith_sink_ = g_71.f3;
    csmith_sink_ = g_71.f4;
    csmith_sink_ = g_71.f5;
    csmith_sink_ = g_71.f6;
    csmith_sink_ = g_71.f7;
    csmith_sink_ = g_71.f8;
    csmith_sink_ = g_108.f0;
    csmith_sink_ = g_108.f1;
    csmith_sink_ = g_108.f2;
    csmith_sink_ = g_108.f3;
    csmith_sink_ = g_108.f4;
    csmith_sink_ = g_108.f5;
    csmith_sink_ = g_108.f6;
    csmith_sink_ = g_108.f7;
    csmith_sink_ = g_108.f8;
    csmith_sink_ = g_131;
    csmith_sink_ = g_139;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 47
   depth: 1, occurrence: 6
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 6
   indirect level: 1, occurrence: 7
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 18
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 16
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 24

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 15
   depth: 3, occurrence: 1
   depth: 6, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 14, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 27, occurrence: 1
   depth: 31, occurrence: 1
   depth: 35, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 53

XXX times a variable address is taken: 76
XXX times a pointer is dereferenced on RHS: 89
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 21
   depth: 3, occurrence: 7
XXX times a pointer is dereferenced on LHS: 54
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 236

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 210
   level: 2, occurrence: 70
   level: 3, occurrence: 23
XXX number of pointers point to pointers: 25
XXX number of pointers point to scalars: 18
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 22.6
XXX average alias set size: 1.28

XXX times a non-volatile is read: 435
XXX times a non-volatile is write: 133
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 68
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 19
   depth: 2, occurrence: 13
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1

XXX percentage a fresh-made variable is used: 14.2
XXX percentage an existing variable is used: 85.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

