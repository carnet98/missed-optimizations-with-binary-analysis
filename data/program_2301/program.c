/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --no-bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --jumps --longlong --force-non-uniform-arrays --math64 --muls --no-packed-struct --paranoid --pointers --structs --no-inline-function --no-return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      12411689480376692603
 */

#include "csmith.h"

volatile uint64_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_4 = 0x9F3690F1L;
static int32_t g_25 = 0xB57A67D9L;
static const int32_t *g_69 = &g_4;
static const int32_t **g_68 = &g_69;
static int32_t g_116 = 1L;
static int8_t g_209 = 1L;
static int32_t *g_282 = &g_116;
static int32_t * const *g_281 = &g_282;
static int32_t *g_295 = &g_25;
static int32_t **g_419 = &g_295;
static int32_t ***g_418 = &g_419;
static int32_t ****g_417 = &g_418;
static int32_t *****g_416 = &g_417;
static int32_t g_436 = 0L;
static uint64_t g_481 = 0xC541714DE6C499ABLL;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static int32_t * func_10(int32_t ** p_11, uint8_t  p_12, int32_t  p_13);
static uint16_t  func_15(uint64_t  p_16, int32_t * p_17, uint64_t  p_18);
static int32_t * func_19(uint8_t  p_20, int32_t * p_21);
static uint32_t  func_47(int32_t ** p_48, uint16_t  p_49, int32_t * p_50, uint16_t  p_51);
static int32_t ** func_52(int32_t  p_53);
static uint8_t  func_61(int32_t * p_62, uint16_t  p_63, int32_t * const * p_64);
static int32_t * func_65(int32_t * p_66, const int32_t ** p_67);
static uint8_t  func_75(int32_t * p_76, uint32_t  p_77);
static int32_t * func_78(int32_t * p_79, int32_t * p_80, int16_t  p_81);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4
 * writes: g_4
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    int8_t l_2 = 0x88L;
    int32_t *l_3 = &g_4;
    int32_t **l_5 = &l_3;
    int32_t *l_482 = &g_116;
    uint16_t l_484 = 65534UL;
    (*l_3) = l_2;
    (*l_5) = (void*)0;
    /* statement id: 2 */
    assert (l_3 == 0);
    for (g_4 = (-3); (g_4 > (-5)); g_4 = safe_sub_func_int8_t_s_s(g_4, 1))
    { /* block id: 5 */
        int32_t **l_14 = &l_3;
        int32_t l_480 = 0L;
        int8_t l_483 = 0L;
        for (l_2 = 0; (l_2 < (-27)); l_2 = safe_sub_func_uint64_t_u_u(l_2, 1))
        { /* block id: 8 */
            return g_4;
        }
    }
    return l_484;
}


/* ------------------------------------------ */
/* 
 * reads : g_281 g_282
 * writes: g_25 g_116
 */
static int32_t * func_10(int32_t ** p_11, uint8_t  p_12, int32_t  p_13)
{ /* block id: 198 */
    (**g_281) = 0L;
    return (*p_11);
    /* statement id: 200 */
    //assert (func_10_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_68 g_4 g_209 g_116 g_281 g_282 g_295 g_69 g_417 g_418 g_419 g_416 g_436
 * writes: g_25 g_69 g_116 g_282 g_209 g_295
 */
static uint16_t  func_15(uint64_t  p_16, int32_t * p_17, uint64_t  p_18)
{ /* block id: 15 */
    uint8_t l_40 = 0xC1L;
    const int32_t l_46 = 0x3E62C90AL;
    int32_t *l_454 = &g_4;
    int32_t l_474 = 1L;
    l_474 = ((safe_sub_func_uint16_t_u_u((18446744073709551612UL < (l_40 >= (safe_unary_minus_func_uint64_t_u(((safe_mod_func_uint16_t_u_u((safe_mod_func_uint8_t_u_u((l_40 >= l_46), (p_18 & (func_47(func_52(l_46), p_16, l_454, g_4) <= g_4)))), 0xCB3DL)) > g_4))))), (-1L))) & (*l_454));
    /* statement id: 196 */
    //assert (g_69 == dangling || g_69 == &g_25);
    assert (g_282 == &g_25 || g_282 == &g_116);
    //assert (g_295 == &g_4 || g_295 == dangling || g_295 == &g_25);
    return g_436;
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_4
 * writes: g_25
 */
static int32_t * func_19(uint8_t  p_20, int32_t * p_21)
{ /* block id: 11 */
    int32_t *l_22 = (void*)0;
    int32_t *l_23 = (void*)0;
    int32_t *l_24 = &g_25;
    int16_t l_35 = 0xCCCEL;
    (*l_24) = (-10L);
    (*l_24) = (((g_25 & 3UL) > (((0x273637828451D77FLL || (safe_lshift_func_uint16_t_u_s((safe_rshift_func_uint8_t_u_u(p_20, (safe_rshift_func_int8_t_s_s((safe_lshift_func_uint8_t_u_s((safe_unary_minus_func_uint32_t_u(g_25)), 1)), 5)))), 13))) != ((l_35 == (*l_24)) == (p_20 <= ((safe_sub_func_int32_t_s_s((*p_21), g_25)) | 249UL)))) != p_20)) && 0x1D0CL);
    return p_21;
    /* statement id: 14 */
    //assert (func_19_rv == &g_4 || func_19_rv == &g_25);
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_116 g_25 g_436 g_281 g_282
 * writes: g_25 g_116
 */
static uint32_t  func_47(int32_t ** p_48, uint16_t  p_49, int32_t * p_50, uint16_t  p_51)
{ /* block id: 192 */
    uint32_t l_455 = 0x5F38C485L;
    int8_t l_460 = 0xFEL;
    const int32_t ***l_468 = (void*)0;
    l_455 = (*p_50);
    (**g_281) = (safe_rshift_func_uint16_t_u_u(((safe_sub_func_uint8_t_u_u(l_460, ((safe_rshift_func_int16_t_s_s(l_455, g_116)) != (+((g_116 ^ (safe_sub_func_int32_t_s_s((safe_rshift_func_int8_t_s_s(((l_468 != &p_48) || 0xA4DF51F3BA3BC391LL), 3)), ((safe_rshift_func_uint8_t_u_s(0xD7L, (safe_mod_func_int32_t_s_s((safe_unary_minus_func_uint64_t_u(7UL)), g_25)))) && p_49)))) || g_436))))) == p_49), 14));
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_68 g_4 g_209 g_116 g_281 g_282 g_295 g_69 g_417 g_418 g_419 g_416
 * writes: g_25 g_69 g_116 g_282 g_209 g_295
 */
static int32_t ** func_52(int32_t  p_53)
{ /* block id: 16 */
    int32_t l_59 = 0x9FF40B36L;
    int32_t *l_278 = &g_4;
    int32_t **l_277 = &l_278;
    int32_t ***l_276 = &l_277;
    int32_t *****l_420 = (void*)0;
    const int32_t *l_450 = &l_59;
    int32_t **l_451 = &l_278;
    int32_t **l_452 = &l_278;
    int32_t **l_453 = &g_282;
lbl_345:
    for (p_53 = 0; (p_53 < (-7)); --p_53)
    { /* block id: 19 */
        int32_t *l_58 = (void*)0;
        int32_t **l_60 = &l_58;
        l_59 = (safe_rshift_func_int16_t_s_s(p_53, 2));
        (*l_60) = func_19(p_53, &g_25);
        /* statement id: 21 */
        assert (l_58 == &g_25);
    }
    if ((func_61(func_65(&l_59, g_68), (0x9892L > (((l_276 == &l_277) != ((safe_lshift_func_int8_t_s_u(g_209, 5)) > ((0xFF4CL == (((&l_277 != &l_277) || (***l_276)) >= p_53)) <= g_209))) <= g_116)), g_281) < 4UL))
    { /* block id: 89 */
        int32_t ** const l_287 = &g_282;
        const int32_t ***l_291 = &g_68;
        const int32_t ****l_290 = &l_291;
        int32_t **l_296 = &g_282;
lbl_346:
        (**g_281) = (1UL | ((-1L) > (((65535UL >= g_25) >= (safe_mul_func_uint8_t_u_u((0xBF8EEF4AL || p_53), 0x12L))) > (l_287 == (*l_276)))));
        for (p_53 = 27; (p_53 >= (-11)); p_53 = safe_sub_func_int32_t_s_s(p_53, 2))
        { /* block id: 93 */
            int32_t *l_292 = &l_59;
            if (((l_290 == &l_291) && (g_209 || ((void*)0 == l_292))))
            { /* block id: 94 */
                for (g_25 = (-21); (g_25 >= (-3)); g_25 = safe_add_func_uint32_t_u_u(g_25, 3))
                { /* block id: 97 */
                    (*l_277) = g_295;
                    /* statement id: 98 */
                    assert (l_278 == &g_25);
                    if ((**g_68))
                        continue;
                    (**l_291) = &p_53;
                    /* statement id: 100 */
                    assert (g_69 == &p_53);
                    return l_296;
                    /* statement id: 101 */
                    //assert (g_69 == dangling);
                    //assert (func_52_rv == &g_282);
                }
                /* facts after for loop */
                assert (l_278 == &g_25 || l_278 == &g_4);
            }
            else
            { /* block id: 103 */
                int8_t l_316 = 0xC3L;
                int32_t * const *l_325 = &l_278;
                if (((p_53 < ((void*)0 != l_292)) <= 0x67L))
                { /* block id: 104 */
                    uint8_t l_315 = 253UL;
                    (*l_277) = (*g_281);
                    /* statement id: 105 */
                    assert (l_278 == &g_25 || l_278 == &g_116);
                    (***l_276) = ((((0xC8DAA136FB27EF69LL <= 0x7BA142A30A2B9BF1LL) || ((safe_rshift_func_uint16_t_u_u(((safe_sub_func_uint8_t_u_u((&g_282 != (void*)0), (((((safe_rshift_func_uint16_t_u_u((safe_mod_func_int16_t_s_s((1UL && ((safe_mod_func_int64_t_s_s((safe_rshift_func_uint16_t_u_s(1UL, ((g_116 >= (safe_add_func_int64_t_s_s((p_53 && ((((safe_lshift_func_int8_t_s_s((((((safe_sub_func_uint64_t_u_u((****l_290), 0xF7601C10D48CD837LL)) >= g_209) && g_209) != 0L) < l_315), 7)) && (*l_278)) || p_53) >= (**g_68))), (*l_292)))) > p_53))), 0x6F0190DC860907BELL)) ^ p_53)), g_25)), 6)) > 0xAFB8AB7BL) >= 0xC9301DDF3D5DE6A0LL) && p_53) | p_53))) | p_53), (***l_276))) && 0x18F0C7B7L)) & l_316) || (*l_292));
                }
                else
                { /* block id: 107 */
                    (*l_287) = func_65(&g_4, &g_69);
                    /* statement id: 108 */
                    assert (g_282 == &g_25);
                    if ((((0L > ((safe_add_func_int32_t_s_s(((safe_add_func_uint16_t_u_u(0xB396L, (safe_mod_func_uint64_t_u_u(((safe_sub_func_int32_t_s_s(1L, ((void*)0 == l_325))) == ((((((0xA8L == (&l_276 != &l_291)) < ((p_53 >= g_25) > p_53)) <= g_25) < p_53) || 1L) > p_53)), 0xEE966703702CCE13LL)))) != (*l_292)), (**l_325))) ^ g_116)) <= g_209) <= 18446744073709551607UL))
                    { /* block id: 109 */
                        int32_t l_340 = 6L;
                        (*l_276) = (*l_276);
                        (*g_282) = ((safe_sub_func_int64_t_s_s((safe_unary_minus_func_int8_t_s((safe_unary_minus_func_uint16_t_u(((**l_296) > ((((safe_sub_func_uint16_t_u_u(((((safe_mul_func_uint16_t_u_u((**l_296), 2UL)) & 3L) && ((safe_add_func_uint64_t_u_u(((**l_325) == (((safe_rshift_func_int8_t_s_u((safe_mul_func_uint8_t_u_u(l_340, p_53)), 1)) ^ g_4) ^ (safe_rshift_func_int16_t_s_s((safe_sub_func_uint8_t_u_u(((***l_291) | (-1L)), g_25)), 9)))), (**l_287))) <= 0xE1F8L)) | p_53), (-9L))) >= (**l_325)) || 0x52D5E572L) & g_4)))))), p_53)) || 0x6AFEL);
                    }
                    else
                    { /* block id: 112 */
                        if (g_25)
                            goto lbl_345;
                        (**l_287) = 0x6E9007F4L;
                        if (g_25)
                            goto lbl_346;
                    }
                }
                /* facts after branching */
                assert (l_278 == &g_4 || l_278 == &g_25 || l_278 == &g_116);
            }
            /* facts after branching */
            assert (l_278 == &g_4 || l_278 == &g_25 || l_278 == &g_116);
            return l_296;
            /* statement id: 119 */
            //assert (func_52_rv == &g_282);
        }
    }
    else
    { /* block id: 121 */
        int32_t **l_368 = (void*)0;
        const int32_t **l_375 = &g_69;
        int32_t ****l_379 = &l_276;
        uint32_t l_389 = 0x71A36470L;
        uint32_t l_392 = 0UL;
        int32_t *l_393 = &g_4;
        if ((safe_lshift_func_uint8_t_u_s((safe_add_func_int32_t_s_s(((g_116 && ((void*)0 == &l_276)) ^ (-4L)), 0L)), 0)))
        { /* block id: 122 */
            uint32_t l_369 = 0x94B45958L;
            uint8_t l_384 = 255UL;
            const int32_t **l_396 = (void*)0;
            int32_t *** const *l_438 = &g_418;
            if (((safe_lshift_func_uint8_t_u_s(p_53, ((safe_mod_func_uint8_t_u_u((0UL >= (safe_add_func_uint32_t_u_u((safe_mod_func_uint32_t_u_u((safe_mod_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_u((p_53 >= ((**g_281) ^ ((+((safe_mod_func_int16_t_s_s(g_4, p_53)) > ((void*)0 != l_368))) | ((*l_278) <= 0xAA6AL)))), 10)) != 0xED88L), g_4)), g_209)), 0xB21AB28AL))), 0xF1L)) & l_369))) == g_4))
            { /* block id: 123 */
                uint8_t l_387 = 0x11L;
                uint32_t l_404 = 0xE79FB1DFL;
                int32_t l_437 = 0L;
                for (g_209 = 0; (g_209 <= (-24)); g_209--)
                { /* block id: 126 */
                    int32_t l_377 = (-9L);
                    int32_t ****l_378 = &l_276;
                    for (l_59 = 9; (l_59 == 23); ++l_59)
                    { /* block id: 129 */
                        int32_t l_374 = 1L;
                        const int32_t **l_376 = &g_69;
                        (*g_295) = l_374;
                        (*g_295) = p_53;
                        if ((*g_69))
                            break;
                        l_376 = l_375;
                    }
                    if ((g_25 == 0x14511D41L))
                    { /* block id: 135 */
                        (*g_295) = 0xF7FE5F9FL;
                    }
                    else
                    { /* block id: 137 */
                        uint8_t l_388 = 0x84L;
                        (*l_375) = (*g_68);
                        (*g_295) = (l_377 != (l_378 != l_379));
                        p_53 = ((4294967295UL >= 0x7BF6E9D8L) && ((0x0306D479L != (g_25 & ((safe_add_func_uint16_t_u_u(((safe_mod_func_uint32_t_u_u(l_384, ((0x1F446DA8L && (safe_sub_func_uint32_t_u_u(g_25, p_53))) | (((((&g_69 == (void*)0) <= l_387) < g_116) > 2L) >= l_388)))) || (*g_69)), l_389)) > (****l_378)))) || g_116));
                    }
                }
            }
            else
            { /* block id: 154 */
                return (**g_417);
                /* statement id: 155 */
                //assert (func_52_rv == &g_295);
            }
            for (l_59 = 0; (l_59 > (-4)); l_59--)
            { /* block id: 159 */
                int32_t *l_441 = &g_25;
                (**l_276) = l_441;
                /* statement id: 160 */
                assert (l_278 == &g_25);
            }
            /* facts after for loop */
            assert (l_278 == &g_25 || l_278 == &g_4);
            for (l_392 = 20; (l_392 == 38); l_392 = safe_add_func_int8_t_s_s(l_392, 7))
            { /* block id: 164 */
                int32_t *l_446 = &g_4;
                for (g_25 = (-27); (g_25 == (-26)); g_25 = safe_add_func_int32_t_s_s(g_25, 1))
                { /* block id: 167 */
                    int32_t l_447 = 3L;
                    if ((1L || 0L))
                    { /* block id: 168 */
                        (***g_417) = &p_53;
                        /* statement id: 169 */
                        assert (g_295 == &p_53);
                    }
                    else
                    { /* block id: 170 */
                        (*g_419) = l_446;
                        /* statement id: 171 */
                        assert (g_295 == &g_4);
                        return (**g_417);
                        /* statement id: 172 */
                        //assert (func_52_rv == &g_295);
                    }
                    /* facts after branching */
                    assert (g_295 == &p_53);
                    l_447 = (***l_276);
                }
                for (l_384 = 14; (l_384 >= 35); l_384++)
                { /* block id: 178 */
                    (*g_68) = (*l_375);
                }
            }
            /* facts after for loop */
            assert (g_295 == &p_53 || g_295 == &g_25);
        }
        else
        { /* block id: 182 */
            (*****g_416) = 0xB3064726L;
            l_450 = (*l_375);
            /* statement id: 184 */
            assert (l_450 == &g_25);
        }
        /* facts after branching */
        assert (g_295 == &p_53 || g_295 == &g_25);
        assert (l_278 == &g_25 || l_278 == &g_4);
        assert (l_450 == &g_25 || l_450 == &l_59);
        (*l_277) = func_65((*l_277), &g_69);
        /* statement id: 186 */
        assert (l_278 == &g_25);
        (*g_68) = func_65((****g_416), l_375);
    }
    /* facts after branching */
    assert (g_69 == &g_25);
    assert (l_278 == &g_25 || l_278 == &g_4);
    assert (g_295 == &p_53 || g_295 == &g_25);
    assert (l_450 == &g_25 || l_450 == &l_59);
    (**g_281) = (**g_419);
    (*g_282) = (&p_53 != (void*)0);
    return l_453;
    /* statement id: 191 */
    //assert (g_295 == dangling || g_295 == &g_25);
    //assert (func_52_rv == &g_282);
}


/* ------------------------------------------ */
/* 
 * reads : g_281 g_282 g_209
 * writes: g_116 g_25
 */
static uint8_t  func_61(int32_t * p_62, uint16_t  p_63, int32_t * const * p_64)
{ /* block id: 86 */
    int32_t **l_284 = (void*)0;
    int32_t ***l_283 = &l_284;
    (**g_281) = (l_283 != &l_284);
    return g_209;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_68 g_25
 * writes: g_25 g_69
 */
static int32_t * func_65(int32_t * p_66, const int32_t ** p_67)
{ /* block id: 23 */
    int32_t *l_88 = &g_25;
    uint16_t l_98 = 0x2CF0L;
    int16_t l_156 = 0xC36BL;
    int32_t *l_172 = (void*)0;
lbl_273:
    for (g_25 = 0; (g_25 <= 19); g_25++)
    { /* block id: 26 */
        const int64_t l_97 = 0x1A7E1F4FA7F9CD94LL;
        int32_t *l_157 = &g_25;
        const int32_t *l_160 = &g_25;
        const int16_t l_171 = 0L;
        uint32_t l_192 = 0UL;
        const int32_t ***l_270 = &g_68;
    }
    (*g_68) = func_78(&g_116, &g_25, g_4);
    /* statement id: 83 */
    assert (g_69 == &g_25);
    if (g_25)
        goto lbl_273;
    return &g_25;
    /* statement id: 85 */
    //assert (func_65_rv == &g_25);
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_4 g_116 g_68 g_69
 * writes: g_116
 */
static uint8_t  func_75(int32_t * p_76, uint32_t  p_77)
{ /* block id: 30 */
    int32_t *l_108 = &g_25;
    int32_t *l_115 = &g_116;
    uint16_t l_126 = 0xE096L;
    int64_t l_155 = 0x6D1AE2BAAC5CA816LL;
    (*l_115) = (((((safe_add_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u(((safe_mul_func_uint8_t_u_u((l_108 == (void*)0), p_77)) & (&g_69 != &g_69)), 5)), (safe_lshift_func_int16_t_s_u(g_25, 8)))) & (safe_sub_func_uint64_t_u_u((safe_lshift_func_int8_t_s_u(0L, 5)), (*l_108)))) && 0xDA1DL) > p_77) ^ (*l_108));
    (*l_115) = ((safe_sub_func_uint32_t_u_u(((safe_rshift_func_int8_t_s_s((g_4 ^ (safe_mod_func_uint64_t_u_u((+(((safe_mod_func_uint64_t_u_u(g_4, l_126)) <= (safe_rshift_func_int8_t_s_s((((((safe_lshift_func_uint8_t_u_u((1UL || ((safe_mod_func_int16_t_s_s(((18446744073709551614UL > p_77) == ((void*)0 != l_108)), (((p_76 == p_76) != g_4) && 0x2BFDL))) & p_77)), p_77)) && g_116) != (*p_76)) == (**g_68)) | p_77), 4))) >= (*l_115))), g_116))), (*l_115))) != g_25), 5L)) == p_77);
    (*l_115) = ((safe_mul_func_uint16_t_u_u((((*g_68) == (*g_68)) && (safe_sub_func_int64_t_s_s(g_25, (((0xBDE2A9FC04FBFD2ELL != (((safe_add_func_uint64_t_u_u((safe_mod_func_int64_t_s_s((l_108 == p_76), (safe_mod_func_uint32_t_u_u(((*l_115) && (safe_lshift_func_int8_t_s_s((*l_108), 7))), (safe_sub_func_uint64_t_u_u((safe_mod_func_uint64_t_u_u(p_77, p_77)), (-7L))))))), (*l_108))) | 18446744073709551610UL) ^ p_77)) <= 0xC9L) < 0x5CB8L)))), 0L)) >= (-5L));
    (*l_115) = ((safe_add_func_int16_t_s_s((safe_add_func_int64_t_s_s(((p_76 == p_76) <= p_77), ((((((*l_108) & (&l_108 != &p_76)) != (((*l_108) > (0UL & (((safe_mul_func_uint8_t_u_u(0UL, 0x75L)) || p_77) && p_77))) > (*l_115))) | (*l_115)) == l_155) & p_77))), 65531UL)) < 0x3AL);
    return g_25;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_59 g_116 g_25
 */
static int32_t * func_78(int32_t * p_79, int32_t * p_80, int16_t  p_81)
{ /* block id: 27 */
    int32_t *l_101 = &g_25;
    (*p_80) = (safe_lshift_func_uint8_t_u_s(((void*)0 == l_101), 3));
    return l_101;
    /* statement id: 29 */
    //assert (func_78_rv == &g_25);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_4;
    csmith_sink_ = g_25;
    csmith_sink_ = g_116;
    csmith_sink_ = g_209;
    csmith_sink_ = g_436;
    csmith_sink_ = g_481;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 87
XXX total union variables: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 87
   depth: 2, occurrence: 17
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 4
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 79

XXX times a variable address is taken: 91
XXX times a pointer is dereferenced on RHS: 114
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 21
   depth: 3, occurrence: 6
   depth: 4, occurrence: 5
XXX times a pointer is dereferenced on LHS: 58
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 347

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 277
   level: 2, occurrence: 68
   level: 3, occurrence: 22
   level: 4, occurrence: 15
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 42
XXX number of pointers point to scalars: 37
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.1
XXX average alias set size: 1.39

XXX times a non-volatile is read: 568
XXX times a non-volatile is write: 164
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 84
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 8
   depth: 2, occurrence: 8
   depth: 3, occurrence: 7
   depth: 4, occurrence: 13
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 16.7
XXX percentage an existing variable is used: 83.3
********************* end of statistics **********************/

