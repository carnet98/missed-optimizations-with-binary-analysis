/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --jumps --longlong --force-non-uniform-arrays --math64 --no-muls --no-packed-struct --paranoid --pointers --structs --inline-function --no-return-structs --arg-structs --dangling-global-pointers
 * Seed:      5923656930918923552
 */

#include "csmith.h"

volatile uint64_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 30;
   uint64_t  f1;
   int32_t  f2;
};

struct S1 {
   uint64_t  f0;
   int16_t  f1;
   uint16_t  f2;
   int32_t  f3;
   signed f4 : 20;
   unsigned f5 : 2;
   int32_t  f6;
   int16_t  f7;
   uint64_t  f8;
   int32_t  f9;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0x77AB3921L;
static struct S0 g_26 = {22425,18446744073709551607UL,0x440271DBL};
static struct S0 g_73 = {-15331,7UL,0x94933308L};
static struct S0 *g_72 = &g_73;
static int32_t *g_83 = &g_73.f2;
static int32_t **g_82 = &g_83;
static struct S0 **g_157 = &g_72;
static struct S1 g_185 = {0xAC000487FC378843LL,0xC375L,0x9580L,-1L,-44,0,0x9B46BF44L,-8L,8UL,0x377C8831L};


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_1(void);
inline static uint64_t  func_5(uint32_t  p_6, int64_t  p_7, uint16_t  p_8, uint8_t  p_9);
inline static int32_t * func_13(uint16_t  p_14, int16_t  p_15, int32_t * p_16);
inline static int32_t * func_17(int32_t * p_18, int32_t  p_19, uint32_t  p_20, int32_t * p_21);
static int32_t * func_30(struct S0  p_31, uint32_t  p_32, struct S0  p_33);
static int32_t ** func_36(int32_t * p_37, int32_t * p_38);
inline static int16_t  func_43(struct S0  p_44, int32_t * p_45);
inline static int32_t * func_47(int32_t * p_48, int32_t ** p_49, struct S0 * p_50, uint8_t  p_51);
static struct S0 ** func_53(int32_t * p_54, struct S0 * p_55, struct S0 * p_56);
static int32_t * func_57(uint64_t  p_58, int16_t  p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_157 g_72 g_73 g_185.f4
 * writes: g_2 g_73
 */
static uint8_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_12 = 0UL;
    int32_t *l_29 = &g_26.f2;
    int32_t ***l_202 = (void*)0;
    int32_t ****l_203 = (void*)0;
    int32_t ****l_204 = &l_202;
    for (g_2 = 0; (g_2 <= 28); g_2++)
    { /* block id: 3 */
        uint64_t l_24 = 6UL;
        int32_t *l_27 = &g_26.f2;
    }
    (*g_72) = (**g_157);
    (*l_204) = l_202;
    return g_185.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_2
 * writes:
 */
inline static uint64_t  func_5(uint32_t  p_6, int64_t  p_7, uint16_t  p_8, uint8_t  p_9)
{ /* block id: 4 */
    struct S0 l_10 = {-18450,18446744073709551614UL,0x00C4307EL};
    struct S0 *l_11 = &l_10;
    (*l_11) = l_10;
    return g_2;
}


/* ------------------------------------------ */
/* 
 * reads : g_185.f7 g_83 g_73.f2 g_82
 * writes: g_185.f7
 */
inline static int32_t * func_13(uint16_t  p_14, int16_t  p_15, int32_t * p_16)
{ /* block id: 93 */
    int32_t *l_196 = &g_26.f2;
    l_196 = (void*)0;
    /* statement id: 94 */
    assert (l_196 == 0);
    for (g_185.f7 = 0; (g_185.f7 != 0); g_185.f7++)
    { /* block id: 97 */
        if ((*g_83))
            break;
    }
    return (*g_82);
    /* statement id: 100 */
    //assert (func_13_rv == &g_73.f2);
}


/* ------------------------------------------ */
/* 
 * reads : g_82 g_83
 * writes:
 */
inline static int32_t * func_17(int32_t * p_18, int32_t  p_19, uint32_t  p_20, int32_t * p_21)
{ /* block id: 8 */
    struct S0 l_34 = {-24069,1UL,0xD761E7FFL};
    int32_t l_35 = 0x526954EBL;
    struct S1 *l_192 = &g_185;
    return (*g_82);
    /* statement id: 92 */
    //assert (func_17_rv == &g_73.f2 || func_17_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_26.f1 g_26.f0 g_2 g_26.f2 g_72 g_73.f1 g_82 g_73.f2 g_83 g_73.f0 g_73 g_157 g_185
 * writes: g_26.f2 g_73.f1 g_83 g_73.f2 g_73 g_26.f1 g_157
 */
static int32_t * func_30(struct S0  p_31, uint32_t  p_32, struct S0  p_33)
{ /* block id: 9 */
    uint16_t l_39 = 1UL;
    int32_t **l_46 = (void*)0;
    int32_t *l_52 = &g_2;
    l_46 = func_36(&g_2, ((l_39 , (g_26.f1 >= (+(g_26.f0 , func_5(g_26.f0, func_5(((func_5(func_5((safe_add_func_uint32_t_u_u((func_43((((void*)0 == l_46) , p_31), func_47(l_52, &l_52, &g_26, p_31.f0)) && 1UL), g_26.f1)), p_31.f0, p_31.f1, (*l_52)), p_31.f0, g_26.f0, g_2) , (*g_83)) ^ p_31.f0), p_32, g_2, g_26.f1), p_31.f1, g_26.f1))))) , l_52));
    /* statement id: 81 */
    assert (l_46 == &g_83);
    assert (g_83 == &g_2 || g_83 == &g_73.f2);
    (*g_82) = (*l_46);
    (*l_46) = (void*)0;
    /* statement id: 83 */
    assert (g_83 == 0);
    return (*g_82);
    /* statement id: 84 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_72 g_26.f1 g_26.f0 g_82 g_83 g_26.f2 g_2 g_73.f2 g_157 g_73.f1 g_73.f0 g_73 g_185
 * writes: g_73 g_26.f1 g_157 g_26.f2 g_83
 */
static int32_t ** func_36(int32_t * p_37, int32_t * p_38)
{ /* block id: 44 */
    struct S0 l_147 = {-8,0x3C5579058001A0E2LL,1L};
    struct S0 **l_156 = &g_72;
    int32_t **l_160 = &g_83;
    struct S0 ***l_181 = &l_156;
    uint64_t l_184 = 6UL;
lbl_158:
    (*g_72) = l_147;
    for (g_26.f1 = 23; (g_26.f1 <= 8); --g_26.f1)
    { /* block id: 48 */
        uint8_t l_155 = 3UL;
        int32_t *l_159 = (void*)0;
        if ((((((((safe_mod_func_int32_t_s_s(0x421460D0L, (safe_mod_func_uint64_t_u_u((l_147.f2 <= (~((g_26.f1 & (((0x1CC915B1L && (g_26.f0 ^ (g_26.f1 & ((*g_82) != p_38)))) & (0x1C95C5D0L ^ g_26.f2)) != (**g_82))) , 0xC1L))), l_147.f0)))) >= (-1L)) != l_155) > l_155) & l_155) && 1UL) && l_147.f1))
        { /* block id: 49 */
            g_157 = l_156;
            if (g_26.f2)
                goto lbl_158;
        }
        else
        { /* block id: 52 */
            uint16_t l_171 = 0x8653L;
            int32_t *l_172 = &g_73.f2;
            struct S0 l_180 = {1315,0x556249259ABB1F74LL,5L};
            (*g_82) = func_47(l_159, l_160, (*g_157), (6L == (((safe_sub_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s((safe_sub_func_uint8_t_u_u(0xF2L, (!(safe_lshift_func_uint16_t_u_u(g_26.f0, ((**l_160) == (safe_unary_minus_func_int8_t_s((l_171 <= (18446744073709551615UL < (**l_160))))))))))), 13)) >= l_171), l_171)) >= l_171) < (*g_83))));
            p_38 = l_172;
            /* statement id: 54 */
            assert (p_38 == &g_73.f2);
            for (l_171 = 0; (l_171 < 57); ++l_171)
            { /* block id: 57 */
                for (l_147.f1 = 0; (l_147.f1 <= 35); l_147.f1++)
                { /* block id: 60 */
                    for (g_26.f2 = 0; (g_26.f2 < 17); ++g_26.f2)
                    { /* block id: 63 */
                        int32_t **l_179 = &l_172;
                        return &g_83;
                        /* statement id: 64 */
                        //assert (func_36_rv == &g_83);
                    }
                    (**g_157) = l_180;
                }
                l_181 = &g_157;
                /* statement id: 68 */
                assert (l_181 == &g_157);
            }
            for (g_73.f1 = 29; (g_73.f1 > 34); g_73.f1 = safe_add_func_int8_t_s_s(g_73.f1, 1))
            { /* block id: 72 */
                int32_t **l_186 = &g_83;
                (*l_172) = (l_184 == ((0L >= ((((250UL || g_26.f1) , (g_185 , l_180)) , 0xB1CE7FF7L) && g_185.f6)) >= g_185.f7));
                (*l_172) = (*p_37);
                return l_186;
                /* statement id: 75 */
                //assert (func_36_rv == &g_83);
            }
        }
        if ((**g_82))
            continue;
    }
    return &g_83;
    /* statement id: 80 */
    //assert (func_36_rv == &g_83);
}


/* ------------------------------------------ */
/* 
 * reads : g_73.f2
 * writes: g_73.f2
 */
inline static int16_t  func_43(struct S0  p_44, int32_t * p_45)
{ /* block id: 37 */
    for (g_73.f2 = 0; (g_73.f2 != (-6)); g_73.f2--)
    { /* block id: 40 */
        int32_t l_146 = 0x0478C99DL;
        return l_146;
    }
    return p_44.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_26.f2 g_72 g_73.f1 g_26.f1 g_82 g_26.f0 g_73.f2 g_83 g_73.f0 g_73
 * writes: g_26.f2 g_73.f1 g_83 g_73.f2 g_73
 */
inline static int32_t * func_47(int32_t * p_48, int32_t ** p_49, struct S0 * p_50, uint8_t  p_51)
{ /* block id: 10 */
    struct S0 *l_63 = (void*)0;
    struct S0 **l_62 = &l_63;
    uint8_t l_64 = 0UL;
    uint64_t l_67 = 0xE0795B172C66C3C3LL;
    int8_t l_68 = 0x15L;
    struct S0 ***l_142 = (void*)0;
    struct S0 ***l_143 = &l_62;
    (*l_143) = func_53(func_57(((p_51 >= (safe_lshift_func_uint8_t_u_u(g_2, ((l_62 != (l_64 , &p_50)) < (((safe_mod_func_int64_t_s_s(p_51, (((((((void*)0 != &p_50) | ((p_50 == &g_26) <= l_67)) ^ 0xFB8AAA841158A35CLL) | g_2) | g_26.f2) , l_64))) | p_51) && l_68))))) && l_67), p_51), p_50, g_72);
    /* statement id: 35 */
    assert (l_62 == &g_72);
    return (*g_82);
    /* statement id: 36 */
    //assert (func_47_rv == &g_2 || func_47_rv == &g_73.f2);
}


/* ------------------------------------------ */
/* 
 * reads : g_26.f1 g_82 g_2 g_26.f0 g_26.f2 g_73.f2 g_73.f1 g_83 g_73.f0 g_73 g_72
 * writes: g_73.f1 g_26.f2 g_83 g_73.f2 g_73
 */
static struct S0 ** func_53(int32_t * p_54, struct S0 * p_55, struct S0 * p_56)
{ /* block id: 15 */
    int16_t l_81 = 0x263DL;
    int32_t *l_104 = (void*)0;
    struct S0 *l_108 = (void*)0;
    int64_t l_112 = (-8L);
    struct S1 l_139 = {18446744073709551615UL,0L,0UL,6L,494,1,-3L,1L,0x3E8534C0AFD8232ELL,-8L};
    struct S1 *l_140 = &l_139;
lbl_138:
    for (g_73.f1 = 16; (g_73.f1 > 12); g_73.f1 = safe_sub_func_uint64_t_u_u(g_73.f1, 3))
    { /* block id: 18 */
        struct S0 **l_76 = &g_72;
        int32_t l_84 = 0L;
        struct S0 *l_101 = (void*)0;
        int32_t *l_105 = &g_73.f2;
        (*g_82) = func_57((((void*)0 == p_55) | (&g_72 == l_76)), (safe_rshift_func_int8_t_s_u(((safe_add_func_uint16_t_u_u(((((((l_81 , l_81) < l_81) > ((g_26.f1 , g_82) != &g_83)) > l_84) , g_2) , g_26.f1), g_26.f0)) & 0xC5D0L), l_84)));
        /* statement id: 19 */
        assert (g_83 == &g_2);
        if (g_73.f1)
            goto lbl_138;
        (*l_105) = ((((0L > (~((safe_mod_func_uint8_t_u_u((safe_sub_func_int64_t_s_s((safe_lshift_func_int8_t_s_s((safe_sub_func_uint8_t_u_u((((safe_add_func_uint64_t_u_u((safe_rshift_func_int16_t_s_u((((safe_lshift_func_uint8_t_u_s(((((safe_unary_minus_func_uint64_t_u(l_84)) , l_101) != ((l_81 | (safe_lshift_func_uint16_t_u_s((l_104 == l_105), (l_81 <= (safe_add_func_uint8_t_u_u(((((void*)0 == l_108) > g_26.f2) == 0x9B98L), 251UL)))))) , (void*)0)) , 1UL), (*l_105))) & g_2) != 2UL), 2)), l_81)) && 0L) & g_26.f2), g_73.f1)), 3)), g_26.f1)), (-1L))) & g_26.f1))) || l_81) , 1UL) & (*l_105));
        (*g_82) = func_57(g_2, g_26.f1);
        (*l_105) = (+(((((safe_mod_func_uint16_t_u_u(g_26.f2, l_112)) < ((safe_unary_minus_func_uint8_t_u(((safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u((safe_add_func_uint64_t_u_u(((safe_rshift_func_int16_t_s_u((safe_rshift_func_uint8_t_u_s((safe_add_func_uint64_t_u_u((((g_26.f0 && ((((!((*l_105) & ((((((safe_mod_func_uint16_t_u_u((+((safe_sub_func_int32_t_s_s(((((((*g_82) == ((safe_sub_func_uint64_t_u_u((1UL & (0x9FL ^ ((*l_105) == ((safe_lshift_func_uint16_t_u_s(((g_26.f1 != (*p_54)) >= g_73.f1), g_26.f1)) & (*l_105))))), (*l_105))) , (*g_82))) , g_73.f2) , (void*)0) != &l_104) > 18446744073709551608UL), 0x867E7C57L)) > 0xC0L)), g_26.f2)) >= (*l_105)) < (*l_105)) ^ 0x60EB54A4L) | 0UL) && g_26.f0))) , (*l_105)) | (*l_105)) == (*l_105))) , 0UL) , 0xEBDD5AF5334EEAE8LL), 0xF23DC045D86B4661LL)), 7)), (*l_105))) && 2UL), 18446744073709551611UL)), 9)), 10)) <= (*l_105)))) && g_73.f2)) == l_81) <= g_73.f1) ^ g_73.f0));
    }
    (*g_72) = (*p_56);
    (*l_140) = l_139;
    if (((&g_73 != (void*)0) , (*p_54)))
    { /* block id: 27 */
        int32_t *l_141 = &l_139.f6;
        (*g_82) = (*g_82);
        (*l_141) = (*g_83);
    }
    else
    { /* block id: 30 */
        (*l_140) = (*l_140);
        (*g_82) = (*g_82);
    }
    return &g_72;
    /* statement id: 34 */
    //assert (func_53_rv == &g_72);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_26.f2
 */
static int32_t * func_57(uint64_t  p_58, int16_t  p_59)
{ /* block id: 11 */
    int32_t *l_69 = &g_26.f2;
    int32_t **l_70 = &l_69;
    struct S0 *l_71 = &g_26;
    (*l_70) = l_69;
    (*l_69) = (l_71 == (void*)0);
    return &g_2;
    /* statement id: 14 */
    //assert (func_57_rv == &g_2);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_2;
    csmith_sink_ = g_26.f0;
    csmith_sink_ = g_26.f1;
    csmith_sink_ = g_26.f2;
    csmith_sink_ = g_73.f0;
    csmith_sink_ = g_73.f1;
    csmith_sink_ = g_73.f2;
    csmith_sink_ = g_185.f0;
    csmith_sink_ = g_185.f1;
    csmith_sink_ = g_185.f2;
    csmith_sink_ = g_185.f3;
    csmith_sink_ = g_185.f4;
    csmith_sink_ = g_185.f5;
    csmith_sink_ = g_185.f6;
    csmith_sink_ = g_185.f7;
    csmith_sink_ = g_185.f8;
    csmith_sink_ = g_185.f9;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 41
   depth: 1, occurrence: 7
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 7
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 17
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 22

XXX max expression depth: 44
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 9, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 23, occurrence: 1
   depth: 29, occurrence: 1
   depth: 35, occurrence: 1
   depth: 44, occurrence: 1

XXX total number of pointers: 56

XXX times a variable address is taken: 46
XXX times a pointer is dereferenced on RHS: 45
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 30
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 91

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 166
   level: 2, occurrence: 16
XXX number of pointers point to pointers: 20
XXX number of pointers point to scalars: 25
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 26.8
XXX average alias set size: 1.21

XXX times a non-volatile is read: 263
XXX times a non-volatile is write: 76
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 56
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 13
   depth: 2, occurrence: 6
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1

XXX percentage a fresh-made variable is used: 18.2
XXX percentage an existing variable is used: 81.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

