/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --checksum --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-jumps --longlong --no-force-non-uniform-arrays --no-math64 --no-muls --no-packed-struct --paranoid --pointers --structs --no-inline-function --no-return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      3925578408
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_33 = 0L;
static int32_t g_60 = (-1L);
static struct S0 g_63 = {0xB296AD98L};
static struct S0 g_114 = {0xC4638B1AL};
static uint32_t g_120 = 18446744073709551615UL;
static uint32_t g_121 = 0xAE52E9ADL;
static uint32_t g_138 = 0x87245417L;
static struct S0 *g_161 = &g_63;
static struct S0 **g_160 = &g_161;
static int32_t ***g_178 = (void*)0;
static int32_t *g_206 = &g_60;
static struct S0 ***g_218 = &g_160;
static struct S0 ****g_217 = &g_218;
static int32_t *g_234 = &g_60;
static struct S0 g_323 = {1UL};


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static int8_t  func_10(uint32_t  p_11, int16_t  p_12, int32_t  p_13, uint32_t  p_14);
static uint32_t  func_16(uint32_t  p_17, uint8_t  p_18, uint8_t  p_19, uint32_t  p_20);
static uint8_t  func_26(int32_t  p_27, int16_t  p_28, int32_t  p_29, uint32_t  p_30);
static int8_t  func_34(int16_t  p_35, uint16_t  p_36, uint8_t  p_37, uint8_t  p_38);
static uint8_t  func_45(int8_t  p_46, uint32_t  p_47, uint32_t  p_48, uint8_t  p_49, int32_t  p_50);
static int32_t * func_51(uint16_t  p_52, uint32_t  p_53, int32_t * p_54, int16_t  p_55, int32_t * p_56);
static uint8_t  func_71(int32_t  p_72, int32_t * p_73, int32_t  p_74);
static int32_t  func_94(struct S0 * p_95, int32_t  p_96);
static struct S0 * func_97(struct S0 * p_98, uint32_t  p_99, int32_t  p_100, struct S0 * p_101, uint32_t  p_102);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_33 g_60 g_63 g_138 g_160 g_120 g_114 g_161 g_178 g_217 g_218 g_234 g_121 g_206 g_323
 * writes: g_63 g_114 g_60 g_120 g_121 g_138 g_206 g_160 g_234 g_218
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_15 = 0xD94B4B13L;
    int16_t l_223 = 6L;
    int8_t l_224 = 0x44L;
    uint8_t l_227 = 251UL;
    int32_t *l_325 = &g_60;
    int32_t **l_326 = (void*)0;
    int32_t *l_327 = &g_60;
    int32_t **l_328 = &l_325;
    (*l_325) = (safe_add_func_int16_t_s_s(((safe_div_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_u((safe_mod_func_int8_t_s_s(func_10(l_15, (l_15 <= (func_16(((safe_unary_minus_func_uint16_t_u((safe_mod_func_int8_t_s_s((safe_mod_func_int32_t_s_s((l_15 || func_26((safe_lshift_func_int16_t_s_s(g_33, 8)), l_15, (l_15 ^ func_34((safe_mod_func_uint16_t_u_u(((safe_mod_func_int8_t_s_s(0x53L, 0x57L)) & (safe_rshift_func_uint8_t_u_s((func_45(l_15, l_15, g_33, l_15, g_33) || l_223), g_33))), l_224)), g_33, l_15, l_224)), g_33)), 3UL)), l_227)))) >= l_223), l_223, g_33, g_33) | g_33)), g_33, g_33), l_227)), 0)), l_223)) > 0xB08C51EAL), 0x4678L));
    /* statement id: 194 */
    assert (g_160 == 0);
    //assert (g_206 == dangling || g_206 == &g_60);
    //assert (g_234 == dangling || g_234 == &g_60);
    g_234 = (void*)0;
    /* statement id: 195 */
    assert (g_234 == 0);
    (*l_328) = l_327;
    return g_60;
}


/* ------------------------------------------ */
/* 
 * reads : g_121 g_63.f0 g_138 g_217 g_218 g_206 g_161 g_120 g_60 g_33 g_323
 * writes: g_206 g_218 g_63
 */
static int8_t  func_10(uint32_t  p_11, int16_t  p_12, int32_t  p_13, uint32_t  p_14)
{ /* block id: 174 */
    struct S0 ***l_269 = &g_160;
    struct S0 *l_286 = (void*)0;
    int32_t l_287 = 0x5FCD0D6BL;
    struct S0 l_324 = {4294967295UL};
    if ((((void*)0 == l_269) | (p_13 & ((((safe_lshift_func_int8_t_s_s(((safe_rshift_func_int16_t_s_u(((safe_rshift_func_uint16_t_u_u((p_11 & (p_11 > p_11)), 15)) && (0UL <= (safe_div_func_int8_t_s_s(p_14, (safe_div_func_int8_t_s_s((safe_mod_func_int16_t_s_s(((safe_div_func_uint32_t_u_u((((((void*)0 == l_286) >= l_287) < 0L) & l_287), 1UL)) <= 0xE363L), g_121)), g_63.f0)))))), 1)) >= l_287), g_138)) | 0xD9B9L) || p_14) < l_287))))
    { /* block id: 175 */
        struct S0 l_288 = {4294967295UL};
        l_288 = l_288;
    }
    else
    { /* block id: 177 */
        struct S0 **l_298 = &l_286;
        int32_t l_299 = 0xE685772BL;
        int32_t **l_300 = &g_206;
        struct S0 *****l_321 = &g_217;
        p_13 = ((((safe_mod_func_int32_t_s_s((p_12 > (g_121 && (safe_sub_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_u((p_13 ^ (safe_unary_minus_func_uint8_t_u((safe_lshift_func_int16_t_s_s(((void*)0 != l_298), l_299))))), 8)) == (g_121 || 255UL)) == l_287), g_63.f0)))), p_11)) < 0x93L) != p_14) ^ l_287);
        (*l_300) = &p_13;
        /* statement id: 179 */
        assert (g_206 == &p_13);
        if (p_13)
        { /* block id: 180 */
            (*g_217) = (*g_217);
            (*g_206) = (!0xB393D079L);
        }
        else
        { /* block id: 183 */
            struct S0 l_302 = {0xFB38901DL};
            struct S0 *****l_322 = &g_217;
            (*g_161) = l_302;
            if ((((safe_lshift_func_int8_t_s_s((safe_sub_func_int16_t_s_s((safe_rshift_func_int8_t_s_u((l_298 != (void*)0), 4)), ((safe_sub_func_int16_t_s_s(0x15A4L, 0x5336L)) == (0x76L != g_120)))), ((safe_lshift_func_uint8_t_u_u(((safe_unary_minus_func_int16_t_s((safe_add_func_int32_t_s_s(((safe_unary_minus_func_uint16_t_u(0x21BBL)) < ((!(0UL == ((safe_add_func_int32_t_s_s(((safe_unary_minus_func_int16_t_s(((p_14 < l_302.f0) && g_121))) ^ l_287), g_60)) || 1UL))) == 0x5BD4L)), (**l_300))))) | 0xB4L), (**l_300))) != g_138))) == g_33) & (-1L)))
            { /* block id: 185 */
                (*l_300) = &g_60;
                /* statement id: 186 */
                assert (g_206 == &g_60);
            }
            else
            { /* block id: 187 */
                l_322 = l_321;
            }
            /* facts after branching */
            assert (g_206 == &p_13 || g_206 == &g_60);
            l_324 = g_323;
        }
        /* facts after branching */
        assert (g_206 == &p_13 || g_206 == &g_60);
    }
    /* facts after branching */
    //assert (g_206 == &p_13 || g_206 == &g_60 || g_206 == dangling);
    return l_287;
    /* statement id: 193 */
    //assert (g_206 == &g_60 || g_206 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_218 g_234 g_60 g_138 g_217 g_160 g_33 g_121 g_114.f0 g_63.f0
 * writes: g_160 g_234 g_60
 */
static uint32_t  func_16(uint32_t  p_17, uint8_t  p_18, uint8_t  p_19, uint32_t  p_20)
{ /* block id: 152 */
    int32_t l_230 = 0xB99A68D6L;
    int32_t *l_238 = &g_60;
    (*g_218) = (void*)0;
    /* statement id: 153 */
    assert (g_160 == 0);
    if ((((0x04C1L & p_19) ^ (safe_mod_func_uint8_t_u_u(l_230, l_230))) & (safe_mul_func_uint16_t_u_u(0UL, (p_20 == 9L)))))
    { /* block id: 154 */
        int32_t l_233 = (-1L);
        int32_t **l_235 = (void*)0;
        int32_t **l_236 = (void*)0;
        struct S0 **l_240 = &g_161;
        g_234 = g_234;
        if ((*g_234))
        { /* block id: 156 */
            int32_t *l_237 = &l_230;
            l_237 = &g_60;
            /* statement id: 157 */
            assert (l_237 == &g_60);
        }
        else
        { /* block id: 158 */
            uint32_t l_241 = 4294967294UL;
            if ((*g_234))
            { /* block id: 159 */
                return g_138;
            }
            else
            { /* block id: 161 */
                int32_t *l_239 = (void*)0;
                l_238 = &l_230;
                /* statement id: 162 */
                assert (l_238 == &l_230);
                l_239 = &g_60;
                /* statement id: 163 */
                assert (l_239 == &g_60);
                (*l_239) = (l_240 != (void*)0);
                (*l_238) = ((*g_234) == l_241);
            }
            /* facts after branching */
            assert (l_238 == &l_230);
        }
        /* facts after branching */
        assert (l_238 == &l_230 || l_238 == &g_60);
        (*g_234) = (safe_sub_func_uint8_t_u_u((safe_div_func_uint32_t_u_u((!((safe_div_func_int8_t_s_s((((p_19 >= ((safe_mod_func_int32_t_s_s((*l_238), (safe_div_func_int8_t_s_s((safe_rshift_func_uint16_t_u_u(((~(safe_add_func_int8_t_s_s(((**g_217) != (*g_218)), (safe_div_func_int8_t_s_s((safe_rshift_func_int8_t_s_u(((7UL >= ((safe_add_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u((*l_238), 3)), (p_20 > (safe_rshift_func_int16_t_s_s((p_18 ^ ((p_18 >= g_33) | p_18)), 11))))) < g_121)) ^ p_17), (*l_238))), g_60))))) == g_33), 2)), 0x13L)))) && g_114.f0)) || (*l_238)) >= p_18), g_63.f0)) & l_233)), p_20)), 0UL));
    }
    else
    { /* block id: 169 */
        int32_t *l_268 = &g_60;
        g_234 = &l_230;
        /* statement id: 170 */
        assert (g_234 == &l_230);
        l_268 = &g_60;
    }
    /* facts after branching */
    assert (g_234 == &l_230 || g_234 == &g_60);
    assert (l_238 == &l_230 || l_238 == &g_60);
    return p_18;
    /* statement id: 173 */
    //assert (g_234 == dangling || g_234 == &g_60);
}


/* ------------------------------------------ */
/* 
 * reads : g_138
 * writes:
 */
static uint8_t  func_26(int32_t  p_27, int16_t  p_28, int32_t  p_29, uint32_t  p_30)
{ /* block id: 150 */
    return g_138;
}


/* ------------------------------------------ */
/* 
 * reads : g_218 g_160 g_161 g_120
 * writes: g_60 g_63
 */
static int8_t  func_34(int16_t  p_35, uint16_t  p_36, uint8_t  p_37, uint8_t  p_38)
{ /* block id: 146 */
    int32_t *l_225 = &g_60;
    struct S0 l_226 = {0xF85E4FF7L};
    (*l_225) = 5L;
    (***g_218) = l_226;
    return g_120;
}


/* ------------------------------------------ */
/* 
 * reads : g_60 g_63 g_138 g_33 g_160 g_120 g_114 g_161 g_178 g_217 g_218
 * writes: g_63 g_114 g_60 g_120 g_121 g_138 g_206
 */
static uint8_t  func_45(int8_t  p_46, uint32_t  p_47, uint32_t  p_48, uint8_t  p_49, int32_t  p_50)
{ /* block id: 1 */
    int32_t *l_59 = &g_60;
    struct S0 l_222 = {0x08D736B7L};
    l_59 = func_51((p_50 && ((p_48 < (((safe_sub_func_int32_t_s_s(0L, (l_59 == l_59))) & (safe_mod_func_int8_t_s_s(g_60, (p_49 && 0x33D73C12L)))) <= ((&g_60 != l_59) != (*l_59)))) < (-1L))), p_47, l_59, g_60, l_59);
    /* statement id: 142 */
    //assert (g_206 == dangling || g_206 == &g_60);
    (*l_59) = (0x0FL | p_49);
    (****g_217) = l_222;
    return (*l_59);
}


/* ------------------------------------------ */
/* 
 * reads : g_63 g_60 g_138 g_33 g_160 g_120 g_114 g_161 g_178 g_217
 * writes: g_63 g_114 g_60 g_120 g_121 g_138 g_206
 */
static int32_t * func_51(uint16_t  p_52, uint32_t  p_53, int32_t * p_54, int16_t  p_55, int32_t * p_56)
{ /* block id: 2 */
    struct S0 *l_64 = &g_63;
    int32_t l_93 = (-10L);
    (*l_64) = g_63;
    for (p_53 = 5; (p_53 <= 3); --p_53)
    { /* block id: 6 */
        uint8_t l_79 = 0xE3L;
        struct S0 *l_103 = &g_63;
        int32_t *l_212 = (void*)0;
        struct S0 ***l_216 = &g_160;
        struct S0 ****l_215 = &l_216;
        if ((safe_lshift_func_uint8_t_u_s((safe_rshift_func_uint8_t_u_s(func_71((safe_mod_func_int16_t_s_s((safe_mod_func_int16_t_s_s(p_52, l_79)), (safe_add_func_int16_t_s_s((safe_rshift_func_uint8_t_u_u((l_79 >= p_55), (safe_mod_func_uint8_t_u_u((safe_add_func_uint16_t_u_u((!251UL), ((safe_rshift_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(((l_93 ^ p_55) || 0x1AL), func_94(func_97(&g_63, p_52, (*p_54), l_103, p_52), l_93))), 6)) == l_79))), p_55)))), 1L)))), &l_93, l_79), 4)), 2)))
        { /* block id: 128 */
            (**g_160) = (*g_161);
        }
        else
        { /* block id: 130 */
            (**g_160) = (*g_161);
            l_212 = p_54;
            /* statement id: 132 */
            assert (l_212 == &g_60);
            (*l_212) = (g_60 == ((l_215 != g_217) > p_53));
        }
        /* facts after branching */
        //assert (g_206 == dangling);
        assert (l_212 == &g_60 || l_212 == 0);
    }
    /* facts after for loop */
    //assert (g_206 == dangling || g_206 == &g_60);
    for (g_63.f0 = 4; (g_63.f0 > 28); ++g_63.f0)
    { /* block id: 138 */
        int32_t **l_221 = &g_206;
        (*l_221) = &g_60;
        /* statement id: 139 */
        assert (g_206 == &g_60);
    }
    return &g_60;
    /* statement id: 141 */
    //assert (func_51_rv == &g_60);
}


/* ------------------------------------------ */
/* 
 * reads : g_121 g_120 g_33 g_114.f0
 * writes: g_206 g_121 g_120
 */
static uint8_t  func_71(int32_t  p_72, int32_t * p_73, int32_t  p_74)
{ /* block id: 115 */
    int32_t **l_207 = &g_206;
    (*l_207) = &p_72;
    /* statement id: 116 */
    assert (g_206 == &p_72);
    for (g_121 = 23; (g_121 <= 49); g_121 = safe_add_func_int16_t_s_s(g_121, 5))
    { /* block id: 119 */
        for (g_120 = 0; (g_120 >= 34); g_120 = safe_add_func_uint32_t_u_u(g_120, 3))
        { /* block id: 122 */
            return g_33;
            /* statement id: 123 */
            //assert (g_206 == dangling);
        }
        return g_114.f0;
        /* statement id: 125 */
        //assert (g_206 == dangling);
    }
    return p_74;
    /* statement id: 127 */
    //assert (g_206 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_60 g_138 g_33 g_160 g_120 g_63.f0 g_114 g_63 g_161 g_178
 * writes: g_60 g_114 g_63 g_120 g_138
 */
static int32_t  func_94(struct S0 * p_95, int32_t  p_96)
{ /* block id: 42 */
    int32_t *l_124 = (void*)0;
    int32_t *l_125 = &g_60;
    int32_t **l_127 = &l_125;
    int32_t ***l_126 = &l_127;
    struct S0 ***l_190 = &g_160;
    struct S0 ****l_189 = &l_190;
    struct S0 *****l_188 = &l_189;
    int16_t l_200 = (-5L);
    (*l_125) = 0x474372BBL;
    (*l_126) = &l_125;
    (**l_127) = ((*l_126) != (*l_126));
    if ((safe_rshift_func_int8_t_s_u((((safe_rshift_func_uint8_t_u_s((((safe_lshift_func_int8_t_s_s(p_96, (safe_mul_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s(g_60, g_138)), (p_96 >= ((0x38899A86L <= ((&l_127 == &l_127) ^ (safe_lshift_func_int8_t_s_s(((void*)0 == &g_60), p_96)))) ^ 65535UL)))))) == 0x11B6L) == (***l_126)), 3)) & p_96) == g_138), (**l_127))))
    { /* block id: 46 */
        struct S0 l_145 = {9UL};
        (***l_126) = (safe_lshift_func_uint8_t_u_s((&g_60 != &g_60), 4));
        for (p_96 = 0; (p_96 > 4); p_96 = safe_add_func_uint8_t_u_u(p_96, 8))
        { /* block id: 50 */
            (*p_95) = l_145;
        }
    }
    else
    { /* block id: 53 */
        struct S0 *l_148 = (void*)0;
        struct S0 **l_147 = &l_148;
        struct S0 ***l_146 = &l_147;
        int32_t l_153 = 0x72B8ADFEL;
        struct S0 *****l_186 = (void*)0;
        (*l_146) = (void*)0;
        /* statement id: 54 */
        assert (l_147 == 0);
        if (((safe_rshift_func_uint16_t_u_u(0x4DBBL, l_153)) < (((safe_div_func_int16_t_s_s(l_153, (safe_sub_func_int32_t_s_s(g_33, ((safe_mod_func_uint16_t_u_u((g_160 != (void*)0), p_96)) >= (safe_rshift_func_uint16_t_u_s(g_120, 12))))))) > (!(g_60 >= g_138))) != g_60)))
        { /* block id: 55 */
            struct S0 ****l_169 = &l_146;
            struct S0 *****l_168 = &l_169;
            for (g_63.f0 = 28; (g_63.f0 != 23); --g_63.f0)
            { /* block id: 58 */
                uint32_t l_167 = 0x2E8431F4L;
                if (p_96)
                    break;
                return l_167;
            }
            (**g_160) = (*p_95);
            (*l_168) = &l_146;
        }
        else
        { /* block id: 64 */
            struct S0 ****l_180 = &l_146;
            struct S0 *****l_179 = &l_180;
            for (g_60 = 0; (g_60 >= (-24)); g_60 = safe_sub_func_int32_t_s_s(g_60, 5))
            { /* block id: 67 */
                uint16_t l_174 = 0x3939L;
                int32_t ***l_177 = &l_127;
                struct S0 *****l_187 = &l_180;
                for (g_120 = 0; (g_120 <= 53); ++g_120)
                { /* block id: 70 */
                    if (g_63.f0)
                        break;
                    (*g_161) = (**g_160);
                    if (g_33)
                    { /* block id: 73 */
                        (*l_127) = &g_60;
                        /* statement id: 74 */
                        assert (l_125 == &g_60);
                        (*l_127) = &p_96;
                        /* statement id: 75 */
                        assert (l_125 == &p_96);
                    }
                    else
                    { /* block id: 76 */
                        int32_t l_182 = 0xE88EED36L;
                        (*l_127) = &p_96;
                        /* statement id: 77 */
                        assert (l_125 == &p_96);
                        (**l_127) = (0x6F9336AEL != l_174);
                        if (p_96)
                            break;
                        (***l_177) = (l_153 & (((safe_add_func_uint8_t_u_u(g_33, 0L)) ^ (l_177 != g_178)) != ((((((l_179 != (void*)0) && (65535UL >= (((safe_unary_minus_func_uint8_t_u(p_96)) > l_182) ^ 0L))) < g_33) > l_153) < g_63.f0) > l_182)));
                    }
                    /* facts after branching */
                    assert (l_125 == &p_96);
                    (**l_177) = &p_96;
                }
                p_96 = ((safe_div_func_int32_t_s_s((((***l_177) && ((g_120 != (g_60 != (~((((g_33 ^ (l_186 != l_187)) == (((l_186 == l_188) && g_63.f0) & g_138)) >= p_96) < 0L)))) > g_120)) == g_60), 0xC824337CL)) >= p_96);
                p_96 = l_153;
            }
            /* facts after for loop */
            assert (l_125 == &p_96 || l_125 == &g_60);
        }
        /* facts after branching */
        assert (l_125 == &p_96 || l_125 == &g_60);
        for (g_138 = (-20); (g_138 > 42); g_138++)
        { /* block id: 90 */
            int32_t l_193 = 5L;
            int32_t l_205 = 0L;
        }
    }
    /* facts after branching */
    assert (l_125 == &p_96 || l_125 == &g_60);
    return p_96;
}


/* ------------------------------------------ */
/* 
 * reads : g_60 g_63.f0 g_63
 * writes: g_63 g_114 g_60 g_120 g_121
 */
static struct S0 * func_97(struct S0 * p_98, uint32_t  p_99, int32_t  p_100, struct S0 * p_101, uint32_t  p_102)
{ /* block id: 7 */
    int32_t *l_104 = &g_60;
    int32_t **l_105 = &l_104;
    struct S0 l_108 = {4294967295UL};
    (*l_105) = l_104;
    for (p_100 = 0; (p_100 < 12); p_100 = safe_add_func_int8_t_s_s(p_100, 3))
    { /* block id: 11 */
        struct S0 l_113 = {0xC36DE1F2L};
        if ((*l_104))
            break;
        (*p_98) = l_108;
        for (g_63.f0 = 0; (g_63.f0 != 44); g_63.f0++)
        { /* block id: 16 */
            int32_t *l_117 = &g_60;
            for (l_108.f0 = 10; (l_108.f0 > 45); l_108.f0 = safe_add_func_int8_t_s_s(l_108.f0, 3))
            { /* block id: 19 */
                g_114 = l_113;
                for (g_60 = 21; (g_60 > (-5)); --g_60)
                { /* block id: 23 */
                    (*l_105) = l_117;
                    g_120 = (safe_add_func_int8_t_s_s((*l_117), (&g_114 != (void*)0)));
                    g_121 = 2L;
                }
            }
            (*l_105) = (void*)0;
            /* statement id: 29 */
            assert (l_104 == 0);
            (*l_105) = &g_60;
            /* statement id: 30 */
            assert (l_104 == &g_60);
            for (g_60 = (-5); (g_60 != 5); ++g_60)
            { /* block id: 33 */
                g_114 = (*p_98);
                return &g_114;
                /* statement id: 35 */
                //assert (func_97_rv == &g_114);
            }
        }
        if (p_102)
            break;
    }
    (**l_105) = (-9L);
    return p_101;
    /* statement id: 41 */
    //assert (func_97_rv == &g_63);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_33, "g_33", print_hash_value);
    transparent_crc(g_60, "g_60", print_hash_value);
    transparent_crc(g_63.f0, "g_63.f0", print_hash_value);
    transparent_crc(g_114.f0, "g_114.f0", print_hash_value);
    transparent_crc(g_120, "g_120", print_hash_value);
    transparent_crc(g_121, "g_121", print_hash_value);
    transparent_crc(g_138, "g_138", print_hash_value);
    transparent_crc(g_323.f0, "g_323.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 53
   depth: 1, occurrence: 11
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 132
   depth: 2, occurrence: 19
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 7, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 65

XXX times a variable address is taken: 80
XXX times a pointer is dereferenced on RHS: 30
breakdown:
   depth: 1, occurrence: 20
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 48
breakdown:
   depth: 1, occurrence: 34
   depth: 2, occurrence: 9
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 136

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 106
   level: 2, occurrence: 33
   level: 3, occurrence: 22
   level: 4, occurrence: 5
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 33
XXX number of pointers point to scalars: 23
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 24.6
XXX average alias set size: 1.26

XXX times a non-volatile is read: 308
XXX times a non-volatile is write: 154
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 105
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 22
   depth: 2, occurrence: 21
   depth: 3, occurrence: 16
   depth: 4, occurrence: 7
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 17.4
XXX percentage an existing variable is used: 82.6
********************* end of statistics **********************/

