/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --no-bitfields --no-checksum --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --jumps --longlong --no-force-non-uniform-arrays --no-math64 --no-muls --no-packed-struct --paranoid --pointers --structs --inline-function --return-structs --no-arg-structs --no-dangling-global-pointers
 * Seed:      6465002071452823834
 */

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint16_t g_5 = 0xB457L;
static int32_t g_38 = 0xF8F9ED02L;
static int32_t g_60 = 0x615B38D6L;
static int32_t * const *g_65 = (void*)0;
static int32_t *g_137 = &g_38;


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_1(void);
inline static int32_t  func_2(int16_t  p_3, uint32_t  p_4);
inline static uint32_t  func_6(int8_t  p_7, int16_t  p_8);
inline static uint16_t  func_13(int32_t  p_14, uint32_t  p_15, int16_t  p_16);
inline static int16_t  func_18(int32_t  p_19);
inline static int32_t * func_20(const int32_t * p_21, int32_t * p_22);
inline static const int32_t * func_23(const int8_t  p_24, uint32_t  p_25, uint16_t  p_26);
inline static int32_t * func_30(uint32_t  p_31);
static int8_t  func_32(int16_t  p_33, int32_t * p_34, int32_t  p_35, uint16_t  p_36);
inline static uint16_t  func_39(int32_t * p_40, const int32_t  p_41, uint32_t  p_42);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_38 g_60 g_65 g_137
 * writes: g_38 g_137
 */
inline static uint16_t  func_1(void)
{ /* block id: 0 */
    int16_t l_17 = (-4L);
    int32_t *l_147 = (void*)0;
    int32_t *l_150 = &g_38;
    int32_t *l_151 = &g_38;
    int32_t **l_152 = &l_147;
    if (func_2(g_5, func_6((safe_lshift_func_uint16_t_u_u((safe_lshift_func_int8_t_s_s(((g_5 > func_13(l_17, ((func_18(g_5) > (g_5 & l_17)) , l_17), l_17)) & g_60), l_17)), l_17)), l_17)))
    { /* block id: 61 */
        int32_t **l_148 = &g_137;
        (*l_148) = l_147;
        /* statement id: 62 */
        assert (g_137 == 0);
    }
    else
    { /* block id: 63 */
        uint8_t l_149 = 253UL;
        g_38 = l_149;
    }
    /* facts after branching */
    assert (g_137 == &g_38 || g_137 == 0);
    (*l_150) = 0x5938EECFL;
    (*l_152) = l_151;
    /* statement id: 67 */
    assert (l_147 == &g_38);
    return g_60;
}


/* ------------------------------------------ */
/* 
 * reads : g_137 g_38
 * writes: g_137 g_38
 */
inline static int32_t  func_2(int16_t  p_3, uint32_t  p_4)
{ /* block id: 50 */
    int32_t * const l_143 = &g_38;
    int32_t **l_144 = &g_137;
    (*l_144) = l_143;
    /* statement id: 51 */
    assert (g_137 == &g_38);
    for (p_3 = 0; (p_3 < 11); p_3++)
    { /* block id: 54 */
        (*l_143) = (*g_137);
        return (*l_143);
    }
    (*l_144) = (void*)0;
    /* statement id: 58 */
    assert (g_137 == 0);
    (*l_143) = p_4;
    return (*l_143);
}


/* ------------------------------------------ */
/* 
 * reads : g_5
 * writes: g_38
 */
inline static uint32_t  func_6(int8_t  p_7, int16_t  p_8)
{ /* block id: 47 */
    int32_t **l_139 = &g_137;
    int32_t *** const l_138 = &l_139;
    int32_t *l_142 = &g_38;
    (*l_142) = ((((void*)0 != l_138) != g_5) && (3L ^ (!(((~p_7) , &g_137) == (void*)0))));
    return g_5;
}


/* ------------------------------------------ */
/* 
 * reads : g_5
 * writes: g_137
 */
inline static uint16_t  func_13(int32_t  p_14, uint32_t  p_15, int16_t  p_16)
{ /* block id: 44 */
    g_137 = (void*)0;
    /* statement id: 45 */
    assert (g_137 == 0);
    return g_5;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_38 g_60 g_65
 * writes: g_38
 */
inline static int16_t  func_18(int32_t  p_19)
{ /* block id: 1 */
    int16_t l_27 = 0x8807L;
    int32_t *l_104 = (void*)0;
    int32_t **l_134 = &l_104;
    (*l_134) = func_20(func_23(g_5, l_27, l_27), ((!65535UL) , l_104));
    /* statement id: 41 */
    assert (l_104 == &g_38);
    (*l_104) = ((((safe_rshift_func_uint16_t_u_s((g_65 == (g_38 , (void*)0)), 7)) == (-1L)) , p_19) , ((*l_134) != &g_38));
    return g_38;
}


/* ------------------------------------------ */
/* 
 * reads : g_38 g_60 g_5
 * writes: g_38
 */
inline static int32_t * func_20(const int32_t * p_21, int32_t * p_22)
{ /* block id: 38 */
    const int32_t *l_108 = (void*)0;
    const int32_t **l_107 = &l_108;
    int32_t l_131 = 6L;
    int32_t *l_132 = (void*)0;
    int32_t *l_133 = &g_38;
    (*l_133) = (((((void*)0 != &g_65) | (((g_38 , (safe_rshift_func_int8_t_s_u((((((void*)0 == l_107) == (g_60 && (((((safe_lshift_func_uint16_t_u_s((g_5 != ((safe_rshift_func_int16_t_s_u((safe_sub_func_uint8_t_u_u((g_5 , (((safe_mod_func_int8_t_s_s((safe_sub_func_uint16_t_u_u(((((((safe_sub_func_uint32_t_u_u(((safe_mod_func_int16_t_s_s((safe_add_func_int8_t_s_s((safe_lshift_func_int16_t_s_u((safe_lshift_func_int8_t_s_s(((safe_rshift_func_int8_t_s_s((&g_38 == p_22), 6)) , 0L), g_60)), g_38)), l_131)), 65535UL)) > 0x88CBL), (*p_21))) | (-8L)) >= 0x85CFL) , (*p_21)) ^ g_5) , 0UL), 0xB3D8L)), l_131)) , (void*)0) == &p_22)), 0xEAL)), g_60)) , g_38)), g_38)) || g_5) != g_38) & g_38) & l_131))) & 0x82L) != 0xDE94L), g_60))) , g_38) | g_60)) , 0xF7L) | g_38);
    return &g_38;
    /* statement id: 40 */
    //assert (func_20_rv == &g_38);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_23(const int8_t  p_24, uint32_t  p_25, uint16_t  p_26)
{ /* block id: 2 */
    int32_t *l_37 = &g_38;
    uint32_t l_86 = 4294967295UL;
    for (p_26 = 0; (p_26 <= 15); ++p_26)
    { /* block id: 5 */
        int32_t ** const l_66 = &l_37;
    }
    return l_37;
    /* statement id: 37 */
    //assert (func_23_rv == &g_38);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_38 g_60
 * writes: g_38
 */
inline static int32_t * func_30(uint32_t  p_31)
{ /* block id: 18 */
    uint8_t l_73 = 254UL;
    uint16_t l_78 = 6UL;
    int32_t *l_79 = (void*)0;
    int32_t *l_80 = &g_38;
    (*l_80) = (((((p_31 <= p_31) != (safe_rshift_func_uint8_t_u_s(((((safe_sub_func_int16_t_s_s(1L, p_31)) , (safe_lshift_func_uint8_t_u_s(l_73, 4))) == ((((safe_rshift_func_int16_t_s_s((((p_31 , (safe_mod_func_uint32_t_u_u(l_78, (((p_31 | ((g_5 && p_31) ^ 0xEAA97CADL)) , 1L) || g_38)))) > (-1L)) || 2UL), l_78)) , l_73) , l_73) == g_38)) <= 0x8280L), 7))) > g_5) == g_60) <= l_73);
    return l_79;
    /* statement id: 20 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_38 g_60
 * writes: g_38
 */
static int8_t  func_32(int16_t  p_33, int32_t * p_34, int32_t  p_35, uint16_t  p_36)
{ /* block id: 6 */
    int16_t l_47 = 0x04D4L;
    int32_t **l_57 = (void*)0;
    int32_t *l_59 = &g_38;
    int32_t **l_58 = &l_59;
    (*l_58) = (((func_39(&g_38, g_5, ((((((safe_sub_func_int8_t_s_s(((safe_rshift_func_uint16_t_u_u(((p_35 == ((0L < 4UL) <= (((l_47 <= (l_47 , (safe_sub_func_uint32_t_u_u(((((p_35 ^ (((safe_lshift_func_uint8_t_u_s(0UL, 2)) < 3L) , g_38)) | 0xD0863E87L) , g_5) , g_38), 0x251ABE71L)))) != 247UL) || 0xDA1E1CF2L))) | 8L), 11)) | 0xE00B46F9L), 0x11L)) , g_38) && 0x8AL) <= 0x2DL) , g_38) | 0x746AC1DEL)) ^ g_5) <= 0xD8L) , &g_38);
    return g_60;
}


/* ------------------------------------------ */
/* 
 * reads : g_38 g_5
 * writes: g_38
 */
inline static uint16_t  func_39(int32_t * p_40, const int32_t  p_41, uint32_t  p_42)
{ /* block id: 7 */
    int32_t *l_53 = &g_38;
    int32_t **l_52 = &l_53;
    int32_t ***l_56 = &l_52;
    (*l_52) = &g_38;
    for (g_38 = 12; (g_38 <= (-20)); g_38--)
    { /* block id: 11 */
        return (**l_52);
    }
    (*l_56) = &p_40;
    /* statement id: 14 */
    assert (l_52 == &p_40);
    return g_5;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_5;
    csmith_sink_ = g_38;
    csmith_sink_ = g_60;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 21
XXX total union variables: 0

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 3
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 16, occurrence: 1
   depth: 25, occurrence: 1
   depth: 31, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 37

XXX times a variable address is taken: 36
XXX times a pointer is dereferenced on RHS: 9
breakdown:
   depth: 1, occurrence: 8
   depth: 2, occurrence: 1
XXX times a pointer is dereferenced on LHS: 19
breakdown:
   depth: 1, occurrence: 19
XXX times a pointer is compared with null: 3
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 62

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 28
   level: 2, occurrence: 17
   level: 3, occurrence: 2
XXX number of pointers point to pointers: 13
XXX number of pointers point to scalars: 24
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27
XXX average alias set size: 1.11

XXX times a non-volatile is read: 145
XXX times a non-volatile is write: 46
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 33
XXX max block depth: 1
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 5

XXX percentage a fresh-made variable is used: 11.7
XXX percentage an existing variable is used: 88.3
********************* end of statistics **********************/

