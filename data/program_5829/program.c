/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --jumps --longlong --no-force-non-uniform-arrays --no-math64 --muls --packed-struct --paranoid --pointers --no-structs --inline-function --no-return-structs --arg-structs --dangling-global-pointers
 * Seed:      2302041832
 */

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0xE8CFF0EAL;
static int32_t *g_30 = (void*)0;
static int32_t **g_29 = &g_30;
static int32_t g_44 = 0xC4EB0A11L;
static int32_t g_46 = 0xF29C214FL;
static int32_t g_118 = 0x0322C85EL;
static int32_t ***g_144 = &g_29;
static int32_t ****g_143 = &g_144;
static int32_t g_149 = 0xFC8C377FL;
static uint32_t g_183 = 18446744073709551611UL;


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
static int32_t * func_6(int32_t * p_7, uint16_t  p_8, int32_t  p_9, int8_t  p_10);
inline static int32_t * func_11(int32_t * p_12);
inline static int32_t * func_13(int32_t * p_14);
static int32_t * func_15(int16_t  p_16);
static int32_t  func_22(int32_t * p_23);
static int32_t  func_26(int32_t ** p_27, uint32_t  p_28);
inline static int8_t  func_31(int32_t * const * p_32, uint8_t  p_33, int32_t * p_34, int8_t  p_35, int32_t  p_36);
inline static int32_t * func_37(int16_t  p_38);
inline static int32_t * func_40(int32_t ** p_41);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_29 g_44 g_46 g_30 g_118 g_149 g_143 g_144 g_183
 * writes: g_2 g_30 g_46 g_44 g_118
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_5 = 0x108F8256L;
    for (g_2 = (-13); (g_2 != (-18)); --g_2)
    { /* block id: 3 */
        return l_5;
    }
    (***g_143) = func_6(func_11(func_13(func_15((+(0x285CE96BL != ((void*)0 == &g_2)))))), ((&l_5 != &l_5) > (!(((safe_rshift_func_int8_t_s_u((safe_mul_func_int8_t_s_s((((void*)0 != (*g_143)) && g_149), 0xD9L)), l_5)) > l_5) ^ g_149))), g_183, l_5);
    /* statement id: 99 */
    assert (g_30 == &g_149);
    return g_2;
}


/* ------------------------------------------ */
/* 
 * reads : g_118 g_149 g_143 g_144 g_29 g_46 g_2 g_30
 * writes: g_2 g_30
 */
static int32_t * func_6(int32_t * p_7, uint16_t  p_8, int32_t  p_9, int8_t  p_10)
{ /* block id: 94 */
    const uint8_t l_187 = 0UL;
    uint16_t l_194 = 0UL;
    int32_t *l_200 = &g_149;
    (***g_144) = (safe_add_func_int8_t_s_s((!l_187), (safe_rshift_func_uint16_t_u_u(g_118, (safe_mod_func_uint32_t_u_u(((safe_mul_func_uint16_t_u_u(g_149, 0x2D6AL)) > ((((void*)0 == (**g_143)) || ((l_194 > (!(safe_lshift_func_int8_t_s_s(((((safe_sub_func_int16_t_s_s(((l_194 | (1UL || 0x52EEL)) < 0xA217L), 0x0A85L)) <= p_9) >= l_194) || g_46), g_149)))) > 0x2E64DF40L)) | l_187)), (*p_7)))))));
    (***g_143) = (**g_144);
    (**g_144) = l_200;
    /* statement id: 97 */
    assert (g_30 == &g_149);
    return (***g_143);
    /* statement id: 98 */
    //assert (func_6_rv == &g_149);
}


/* ------------------------------------------ */
/* 
 * reads : g_118 g_44 g_29 g_30 g_2 g_46 g_149 g_143 g_144
 * writes: g_118 g_44 g_2
 */
inline static int32_t * func_11(int32_t * p_12)
{ /* block id: 61 */
    int32_t ** const *l_142 = &g_29;
    int32_t ** const **l_141 = &l_142;
    for (g_118 = (-15); (g_118 >= (-27)); g_118 = safe_sub_func_uint16_t_u_u(g_118, 7))
    { /* block id: 64 */
        int32_t *l_150 = &g_149;
        int32_t ****l_153 = &g_144;
        for (g_44 = 7; (g_44 != (-30)); g_44--)
        { /* block id: 67 */
            uint32_t l_147 = 0UL;
        }
    }
    (***l_142) = ((safe_add_func_int32_t_s_s(0x9B685049L, (***l_142))) == (((safe_div_func_uint16_t_u_u(((safe_mul_func_uint16_t_u_u((((g_46 & ((safe_add_func_uint32_t_u_u((safe_div_func_uint16_t_u_u((safe_div_func_int32_t_s_s(((g_2 < (safe_div_func_int16_t_s_s((!(((safe_add_func_int32_t_s_s((safe_sub_func_uint32_t_u_u(0x602C2F6DL, (((&l_142 != &g_144) != (****l_141)) < (safe_mod_func_int16_t_s_s((****l_141), (***l_142)))))), 1UL)) | 0xBF81L) >= 4294967290UL)), g_149))) || 0xC97804E3L), (****g_143))), 0xE6C2L)), 0UL)) || (***l_142))) ^ (*p_12)) >= g_118), 0x8B9BL)) != 0x51E9L), (****l_141))) > 0x4A799C40L) > 0L));
    (**g_29) = (((safe_lshift_func_uint8_t_u_s((g_44 > (((void*)0 == p_12) > ((((((((((void*)0 == p_12) ^ 0xD118L) | ((*l_141) == (*l_141))) || (g_2 & (****l_141))) == 0x93L) || 0x4D50L) & (****l_141)) < 0x9D1CL) || (*p_12)))), 5)) > (*p_12)) && 0x3C8D9F3EL);
    return (**g_144);
    /* statement id: 93 */
    //assert (func_11_rv == &g_2);
}


/* ------------------------------------------ */
/* 
 * reads : g_30 g_2 g_29 g_118
 * writes: g_118 g_2
 */
inline static int32_t * func_13(int32_t * p_14)
{ /* block id: 50 */
    const uint8_t l_122 = 0x1FL;
    int32_t **l_126 = &g_30;
    int32_t ***l_134 = &l_126;
    int32_t ****l_133 = &l_134;
lbl_123:
    for (g_118 = 0; (g_118 >= 16); g_118 = safe_add_func_int16_t_s_s(g_118, 6))
    { /* block id: 53 */
        p_14 = (void*)0;
        /* statement id: 54 */
        assert (p_14 == 0);
        if (g_118)
            goto lbl_123;
        if (l_122)
            continue;
    }
    (**l_126) = (((safe_div_func_uint8_t_u_u(((&g_30 != l_126) && ((safe_sub_func_int32_t_s_s((**l_126), (**l_126))) ^ (**l_126))), (((safe_rshift_func_uint16_t_u_s((((**l_126) > (safe_sub_func_uint32_t_u_u(((*l_126) == (void*)0), 4294967286UL))) >= (**l_126)), (**l_126))) >= (**l_126)) & (**l_126)))) & (**l_126)) != 0L);
    (*l_133) = &g_29;
    /* statement id: 59 */
    assert (l_134 == &g_29);
    return (**l_134);
    /* statement id: 60 */
    //assert (func_13_rv == &g_2);
}


/* ------------------------------------------ */
/* 
 * reads : g_29 g_2 g_44 g_46 g_30 g_118
 * writes: g_2 g_30 g_46 g_44
 */
static int32_t * func_15(int16_t  p_16)
{ /* block id: 6 */
    int32_t l_20 = 0x56890C54L;
    int32_t *l_21 = &g_2;
    (*l_21) = l_20;
    (*l_21) = func_22(&g_2);
    /* statement id: 48 */
    assert (g_30 == &g_2);
    return l_21;
    /* statement id: 49 */
    //assert (func_15_rv == &g_2);
}


/* ------------------------------------------ */
/* 
 * reads : g_29 g_2 g_44 g_46 g_30 g_118
 * writes: g_2 g_30 g_46 g_44
 */
static int32_t  func_22(int32_t * p_23)
{ /* block id: 8 */
    int32_t *l_25 = &g_2;
    int32_t **l_24 = &l_25;
    uint16_t l_39 = 65532UL;
    (*l_24) = (void*)0;
    /* statement id: 9 */
    assert (l_25 == 0);
    (*p_23) = 0x41145714L;
    (*p_23) = func_26(g_29, (func_31(&l_25, g_2, func_37(l_39), g_44, ((safe_unary_minus_func_int32_t_s((((0x6C4CL ^ g_44) == 0L) || 0x8ED0E11BL))) < g_44)) != g_118));
    /* statement id: 46 */
    assert (g_30 == &g_2);
    return (**g_29);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_26(int32_t ** p_27, uint32_t  p_28)
{ /* block id: 44 */
    int32_t l_119 = (-1L);
    return l_119;
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_46 g_30 g_2 g_29
 * writes: g_44 g_2
 */
inline static int8_t  func_31(int32_t * const * p_32, uint8_t  p_33, int32_t * p_34, int8_t  p_35, int32_t  p_36)
{ /* block id: 35 */
    const int32_t *l_110 = &g_46;
    const int32_t **l_109 = &l_110;
    const int32_t ***l_108 = &l_109;
    int32_t l_116 = 3L;
    for (g_44 = (-18); (g_44 <= (-3)); g_44 = safe_add_func_int16_t_s_s(g_44, 6))
    { /* block id: 38 */
        uint16_t l_115 = 0xB137L;
        int32_t *l_117 = &g_46;
        (**g_29) = ((&g_29 != l_108) & (((*l_110) > p_35) || ((safe_lshift_func_int16_t_s_s(((*p_32) != (void*)0), ((((safe_add_func_int32_t_s_s(0xAD585B88L, l_115)) ^ g_44) <= (*g_30)) || l_116))) || 4L)));
        (*l_109) = l_117;
        if ((*l_117))
            continue;
    }
    return g_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_29 g_44 g_46 g_30 g_2
 * writes: g_30 g_46
 */
inline static int32_t * func_37(int16_t  p_38)
{ /* block id: 11 */
    int32_t **l_42 = (void*)0;
    int32_t *l_45 = &g_46;
    int8_t l_65 = 0xC7L;
    (*g_29) = func_40(l_42);
    /* statement id: 15 */
    assert (g_30 == &g_2);
    (*l_45) = g_44;
    if ((safe_sub_func_uint8_t_u_u((l_45 == l_45), (&l_45 != &g_30))))
    { /* block id: 17 */
        uint16_t l_58 = 5UL;
        (*l_45) = ((safe_div_func_int16_t_s_s((((g_44 >= (((~(safe_mod_func_int16_t_s_s((0x49D9L && (((((safe_sub_func_int32_t_s_s(((safe_sub_func_uint32_t_u_u(g_46, (p_38 < ((0xF8EFL ^ l_58) && ((+(safe_lshift_func_uint8_t_u_u((~((safe_add_func_int32_t_s_s((p_38 >= (((0x91B1L && 0L) <= 4L) ^ p_38)), 0x54C62B41L)) < p_38)), p_38))) > 0x101BC642L))))) <= l_65), g_46)) && p_38) == 0x2DL) >= 0xBEL) | g_44)), l_58))) | (*l_45)) <= 0x00L)) == p_38) == 65535UL), 3L)) ^ 0x99CF48B0L);
        return (*g_29);
        /* statement id: 19 */
        //assert (func_37_rv == &g_2);
    }
    else
    { /* block id: 20 */
        int8_t l_83 = 0x90L;
        int32_t *l_101 = &g_46;
        int32_t ***l_102 = &l_42;
        (*g_29) = func_40(&l_45);
        if ((safe_add_func_int16_t_s_s(((g_44 && (+(safe_rshift_func_int8_t_s_u((safe_add_func_uint8_t_u_u((safe_mul_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(g_46, (safe_div_func_uint16_t_u_u((((**g_29) == g_44) | (p_38 >= 0x5039L)), (safe_lshift_func_uint16_t_u_u((p_38 > ((safe_lshift_func_uint8_t_u_u((0x38L ^ (0xD24BL != p_38)), 0)) && g_44)), (*l_45))))))), l_83)), p_38)), g_2)))) >= l_83), l_83)))
        { /* block id: 22 */
            (*l_45) = (((((safe_lshift_func_int16_t_s_s(0L, ((safe_mod_func_int32_t_s_s((-5L), (safe_rshift_func_int8_t_s_u(((p_38 >= 0xCA6AL) | ((((safe_sub_func_uint8_t_u_u(((safe_add_func_uint32_t_u_u((4294967294UL == 5L), (p_38 != l_83))) > (~(safe_lshift_func_uint16_t_u_u((safe_lshift_func_int8_t_s_u((safe_rshift_func_int16_t_s_s(l_83, g_2)), 1)), p_38)))), l_83)) || 0UL) || 4294967292UL) | g_44)), 2)))) == 65534UL))) >= p_38) & p_38) != (*l_45)) != 6UL);
        }
        else
        { /* block id: 24 */
            return l_101;
            /* statement id: 25 */
            //assert (func_37_rv == &g_46);
        }
        (*l_102) = &l_101;
        /* statement id: 27 */
        assert (l_42 == &l_101);
    }
    /* facts after branching */
    //assert (l_42 == dangling);
    for (g_46 = 9; (g_46 < 9); g_46 = safe_add_func_uint16_t_u_u(g_46, 7))
    { /* block id: 31 */
        return (*g_29);
        /* statement id: 32 */
        //assert (func_37_rv == &g_2);
    }
    return l_45;
    /* statement id: 34 */
    //assert (func_37_rv == &g_46);
}


/* ------------------------------------------ */
/* 
 * reads : g_29
 * writes: g_30
 */
inline static int32_t * func_40(int32_t ** p_41)
{ /* block id: 12 */
    int32_t *l_43 = &g_2;
    (*g_29) = l_43;
    /* statement id: 13 */
    assert (g_30 == &g_2);
    return l_43;
    /* statement id: 14 */
    //assert (func_40_rv == &g_2);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_2;
    csmith_sink_ = g_44;
    csmith_sink_ = g_46;
    csmith_sink_ = g_118;
    csmith_sink_ = g_149;
    csmith_sink_ = g_183;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 29
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 9
   depth: 4, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 39

XXX times a variable address is taken: 38
XXX times a pointer is dereferenced on RHS: 46
breakdown:
   depth: 1, occurrence: 19
   depth: 2, occurrence: 15
   depth: 3, occurrence: 5
   depth: 4, occurrence: 7
XXX times a pointer is dereferenced on LHS: 26
breakdown:
   depth: 1, occurrence: 15
   depth: 2, occurrence: 4
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 101

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 42
   level: 2, occurrence: 28
   level: 3, occurrence: 15
   level: 4, occurrence: 13
XXX number of pointers point to pointers: 16
XXX number of pointers point to scalars: 23
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 12.8
XXX average alias set size: 1.28

XXX times a non-volatile is read: 248
XXX times a non-volatile is write: 83
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 48
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 14
   depth: 2, occurrence: 2

XXX percentage a fresh-made variable is used: 16.4
XXX percentage an existing variable is used: 83.6
********************* end of statistics **********************/

