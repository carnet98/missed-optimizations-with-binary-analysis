/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --no-bitfields --checksum --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-jumps --no-longlong --no-force-non-uniform-arrays --math64 --no-muls --no-packed-struct --paranoid --pointers --structs --no-inline-function --no-return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      3035072360
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   int16_t  f1;
   int8_t  f2;
   uint16_t  f3;
   uint8_t  f4;
   uint32_t  f5;
   int8_t  f6;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 5;
static int32_t g_52 = 0xACD6BA8D;
static int32_t **g_86 = (void*)0;
static int32_t g_93 = 0x6420880F;
static struct S0 g_113 = {0,0x80A6,0,0x46E7,9U,0x129D736D,0xDF};
static struct S0 *g_294 = &g_113;
static struct S0 **g_293 = &g_294;
static struct S0 ***g_292 = &g_293;
static struct S0 ****g_299 = (void*)0;
static struct S0 *****g_298 = &g_299;
static int32_t *g_356 = &g_52;
static int8_t g_406 = 0xAA;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static int32_t * func_5(int32_t * p_6, uint32_t  p_7);
static int32_t * func_8(uint8_t  p_9);
static uint8_t  func_19(int8_t  p_20, uint32_t  p_21);
static int32_t  func_22(int32_t * p_23, uint16_t  p_24, int32_t  p_25, int32_t * p_26);
static int32_t  func_31(int32_t  p_32, int32_t * p_33, int8_t  p_34);
static int16_t  func_37(int32_t  p_38, uint16_t  p_39);
static uint16_t  func_41(int16_t  p_42, int32_t * p_43, int32_t * p_44, int8_t  p_45);
static int32_t  func_48(int8_t  p_49, int16_t  p_50);
static int32_t  func_53(int32_t  p_54);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_52 g_86 g_113.f1 g_93 g_113.f6 g_113.f5 g_113.f3 g_113.f2 g_113.f0 g_113.f4 g_113 g_292 g_293 g_294 g_356 g_406
 * writes: g_2 g_52 g_86 g_113 g_298 g_93 g_356
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_30 = (void*)0;
    int16_t l_40 = 0xAE3D;
    int8_t l_422 = 0x0B;
    struct S0 l_429 = {-1,0xB726,0xD1,0x3DDF,0x8A,0x54B93C2A,0x43};
    for (g_2 = 0; (g_2 == 22); g_2 = safe_add_func_uint32_t_u_u(g_2, 1))
    { /* block id: 3 */
        uint16_t l_15 = 0x5B05;
        int32_t *l_27 = (void*)0;
        int16_t l_407 = (-8);
        uint16_t l_409 = 1U;
        int32_t **l_423 = &g_356;
        (*l_423) = func_5(func_8((((safe_sub_func_uint32_t_u_u((((safe_mod_func_int16_t_s_s((+l_15), ((l_15 <= ((safe_sub_func_int32_t_s_s((((~func_19(g_2, (((func_22(l_27, (safe_sub_func_uint8_t_u_u(g_2, (l_30 == &g_2))), func_31((safe_sub_func_int16_t_s_s(func_37(l_40, func_41(((safe_lshift_func_uint16_t_u_u((func_48((9 != g_2), l_40) != 0x5B4C5A25), 12)) == g_113.f1), l_27, l_27, g_93)), g_113.f3)), &g_93, g_2), &g_2) & l_407) >= 0xEE6D12B4) | 0x53))) | g_2) && l_409), g_406)) & g_406)) & g_2))) ^ l_15) > g_406), l_40)) ^ g_406) == 0x2005)), l_422);
        /* statement id: 225 */
        assert (g_356 == &g_93);
        (*l_423) = func_8(g_113.f3);
    }
    /* facts after for loop */
    //assert (g_298 == dangling || g_298 == &g_299);
    assert (g_356 == &g_93 || g_356 == &g_52);
    for (g_93 = 0; (g_93 == 26); g_93 = safe_add_func_int8_t_s_s(g_93, 4))
    { /* block id: 230 */
        int32_t *l_426 = &g_93;
        int32_t **l_427 = (void*)0;
        int32_t **l_428 = &l_426;
        (*l_428) = l_426;
        (***g_292) = l_429;
    }
    return g_113.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_5(int32_t * p_6, uint32_t  p_7)
{ /* block id: 223 */
    return p_6;
    /* statement id: 224 */
    //assert (func_5_rv == &g_93);
}


/* ------------------------------------------ */
/* 
 * reads : g_113.f5 g_93 g_2 g_113.f2 g_113.f4
 * writes: g_93
 */
static int32_t * func_8(uint8_t  p_9)
{ /* block id: 219 */
    int32_t *l_410 = &g_93;
    int32_t **l_411 = &l_410;
    (*l_411) = l_410;
    (*l_410) = ((safe_lshift_func_int16_t_s_s(((safe_add_func_int32_t_s_s((safe_mod_func_uint32_t_u_u((g_113.f5 != ((&l_410 == &l_410) | (safe_lshift_func_uint16_t_u_s(g_93, 11)))), ((g_93 == p_9) | (**l_411)))), ((((((*l_410) <= (((safe_sub_func_uint8_t_u_u(255U, (*l_410))) >= p_9) != (*l_410))) != (**l_411)) > 0) || g_2) || g_113.f2))) & g_113.f4), 13)) | p_9);
    return &g_93;
    /* statement id: 222 */
    //assert (func_8_rv == &g_93);
}


/* ------------------------------------------ */
/* 
 * reads : g_294 g_113 g_293
 * writes: g_113
 */
static uint8_t  func_19(int8_t  p_20, uint32_t  p_21)
{ /* block id: 216 */
    uint16_t l_408 = 65535U;
    (**g_293) = (*g_294);
    return l_408;
}


/* ------------------------------------------ */
/* 
 * reads : g_93 g_113.f3 g_113.f1 g_113 g_52 g_2 g_292 g_86 g_293 g_294 g_356 g_406
 * writes: g_52 g_113 g_298 g_86 g_93 g_356
 */
static int32_t  func_22(int32_t * p_23, uint16_t  p_24, int32_t  p_25, int32_t * p_26)
{ /* block id: 111 */
    int16_t l_266 = 0x7317;
    struct S0 *l_277 = (void*)0;
    struct S0 **l_276 = &l_277;
    struct S0 ***l_275 = &l_276;
    int32_t *l_328 = &g_52;
    int32_t ***l_352 = &g_86;
    if ((safe_sub_func_uint8_t_u_u(g_93, ((&p_25 != &g_93) > ((safe_sub_func_int16_t_s_s(0x58E4, ((safe_sub_func_uint8_t_u_u(0xB7, p_25)) || (((g_113.f3 == (((!g_113.f1) || l_266) && l_266)) > 0xB56D) < (-1))))) < (-1))))))
    { /* block id: 112 */
        struct S0 *l_274 = &g_113;
        struct S0 **l_273 = &l_274;
        struct S0 ***l_272 = &l_273;
        int32_t l_280 = 0xCC2CD189;
        int32_t ***l_351 = &g_86;
        struct S0 *****l_361 = &g_299;
        struct S0 l_364 = {0x41124B31,-8,-9,0x431A,0xF8,4294967295U,-1};
        uint16_t l_374 = 0x3579;
        if ((g_113.f1 > ((safe_lshift_func_int8_t_s_u((safe_rshift_func_int8_t_s_u(((safe_unary_minus_func_int16_t_s((((void*)0 == l_272) > ((void*)0 != l_275)))) && (&l_276 == (void*)0)), (((safe_rshift_func_int16_t_s_s(l_280, 12)) != l_280) <= p_24))), 5)) != p_24)))
        { /* block id: 113 */
            uint8_t l_281 = 0xD2;
            struct S0 ***l_284 = &l_273;
            int32_t l_312 = 7;
            if (l_281)
            { /* block id: 114 */
                for (l_281 = 0; (l_281 <= 12); l_281 = safe_add_func_uint16_t_u_u(l_281, 3))
                { /* block id: 117 */
                    g_52 = (((l_284 != l_284) >= l_266) <= p_24);
                }
                (**l_273) = (***l_284);
            }
            else
            { /* block id: 121 */
                int32_t l_287 = 0xE547552E;
                int32_t **l_329 = &l_328;
                for (g_52 = (-11); (g_52 <= 2); g_52 = safe_add_func_int16_t_s_s(g_52, 3))
                { /* block id: 124 */
                    if ((*p_26))
                        break;
                    (***l_284) = g_113;
                    return l_287;
                }
                if (l_280)
                { /* block id: 129 */
                    struct S0 ****l_297 = (void*)0;
                    struct S0 *****l_296 = &l_297;
                    int32_t *l_313 = (void*)0;
                    for (g_113.f2 = 0; (g_113.f2 <= 10); g_113.f2 = safe_add_func_int32_t_s_s(g_113.f2, 5))
                    { /* block id: 132 */
                        struct S0 ****l_291 = &l_275;
                        struct S0 *****l_290 = &l_291;
                        int32_t l_295 = (-3);
                        (*l_290) = &l_284;
                        /* statement id: 133 */
                        assert (l_291 == &l_284);
                        (**l_290) = g_292;
                        /* statement id: 134 */
                        assert (l_284 == &g_293);
                        l_280 = l_295;
                        g_298 = l_296;
                        /* statement id: 136 */
                        assert (g_298 == &l_297);
                    }
                    /* facts after for loop */
                    assert (l_284 == &g_293 || l_284 == &l_273);
                    //assert (g_298 == &l_297 || g_298 == &g_299 || g_298 == dangling);
                    for (p_24 = 0; (p_24 < 33); p_24++)
                    { /* block id: 140 */
                        int32_t ***l_302 = &g_86;
                        (*l_302) = g_86;
                    }
                    l_312 = ((safe_rshift_func_int16_t_s_u((safe_add_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s(((((safe_lshift_func_int8_t_s_s(0x01, (1U != (0x35540F05 <= (((l_280 != ((**l_284) == (void*)0)) >= 0) == (!(g_113.f2 & (l_266 ^ p_25)))))))) > 0x95B1CF15) && 0x01) <= g_113.f4), 7)), 0U)), 4)) | p_25);
                    p_25 = (&g_93 == &p_25);
                }
                else
                { /* block id: 145 */
                    struct S0 *l_314 = &g_113;
                    int32_t l_321 = 0x7AD8558D;
                    struct S0 ***l_322 = &l_273;
                    struct S0 l_327 = {-9,0xDB47,0xDA,65533U,250U,7U,1};
                    if (((l_314 == (**l_275)) || ((safe_lshift_func_uint16_t_u_u(((safe_sub_func_uint16_t_u_u(((void*)0 == (*l_273)), ((safe_mod_func_int32_t_s_s((l_321 == ((l_284 == l_322) | (safe_add_func_int8_t_s_s(g_113.f6, l_266)))), p_24)) >= 1U))) & 0x545C), p_25)) || 0xA71A296F)))
                    { /* block id: 146 */
                        int32_t *l_326 = &g_52;
                        int32_t **l_325 = &l_326;
                        (*l_325) = &l_321;
                        /* statement id: 147 */
                        assert (l_326 == &l_321);
                        (*l_325) = &g_93;
                        /* statement id: 148 */
                        assert (l_326 == &g_93);
                    }
                    else
                    { /* block id: 149 */
                        (**l_273) = l_327;
                    }
                }
                /* facts after branching */
                assert (l_284 == &g_293 || l_284 == &l_273);
                (*l_329) = l_328;
            }
            /* facts after branching */
            assert (l_284 == &g_293 || l_284 == &l_273);
            (*l_328) = (safe_unary_minus_func_int8_t_s((safe_add_func_uint8_t_u_u(g_113.f4, ((0x92D8 ^ 1U) <= ((void*)0 != g_86))))));
            return (*p_26);
        }
        else
        { /* block id: 157 */
            struct S0 ***l_345 = &l_276;
            int32_t l_346 = (-10);
            int32_t *l_359 = (void*)0;
            int8_t l_375 = 2;
            for (g_93 = 26; (g_93 < (-16)); g_93--)
            { /* block id: 160 */
                int32_t l_358 = 1;
                struct S0 *****l_360 = &g_299;
                for (g_113.f4 = 9; (g_113.f4 > 55); ++g_113.f4)
                { /* block id: 163 */
                    int32_t **l_339 = (void*)0;
                    p_26 = &l_280;
                    /* statement id: 164 */
                    assert (p_26 == &l_280);
                    if ((safe_add_func_int8_t_s_s((!(safe_sub_func_int8_t_s_s((l_345 != l_345), ((g_113.f6 > l_346) || (l_280 > g_113.f6))))), 0U)))
                    { /* block id: 165 */
                        (*p_26) = (((safe_sub_func_int16_t_s_s((g_52 <= ((safe_add_func_int32_t_s_s(((l_351 != l_352) >= ((p_25 && (p_25 || p_24)) ^ (+((void*)0 != &g_299)))), ((safe_add_func_uint8_t_u_u(g_113.f0, g_113.f4)) >= g_113.f0))) ^ p_24)), g_2)) ^ 0x00) > (*p_26));
                        (*p_26) = g_52;
                        g_356 = &p_25;
                        /* statement id: 168 */
                        assert (g_356 == &p_25);
                    }
                    else
                    { /* block id: 169 */
                        int32_t **l_357 = &g_356;
                        (*l_357) = &g_52;
                        /* statement id: 170 */
                        assert (g_356 == &g_52);
                        (*g_356) = l_358;
                    }
                    /* facts after branching */
                    assert (g_356 == &g_52 || g_356 == &p_25);
                }
                (*g_294) = (*g_294);
                l_359 = &p_25;
                /* statement id: 175 */
                assert (l_359 == &p_25);
                if ((0x1734 <= (l_360 == l_361)))
                { /* block id: 176 */
                    struct S0 ***l_373 = &l_273;
                    for (g_113.f0 = (-29); (g_113.f0 != 26); g_113.f0 = safe_add_func_uint8_t_u_u(g_113.f0, 5))
                    { /* block id: 179 */
                        l_364 = (*g_294);
                    }
                    for (l_364.f3 = 10; (l_364.f3 > 57); l_364.f3++)
                    { /* block id: 184 */
                        p_23 = &l_346;
                        /* statement id: 185 */
                        assert (p_23 == &l_346);
                        p_26 = &p_25;
                        /* statement id: 186 */
                        assert (p_26 == &p_25);
                        (*l_359) = (*l_359);
                        (*l_328) = ((safe_lshift_func_uint8_t_u_u((((g_93 <= 0xFB86) >= (safe_add_func_int8_t_s_s(6, (safe_rshift_func_int8_t_s_s(g_113.f6, 4))))) != (*g_356)), p_25)) || (l_373 == l_373));
                    }
                    (***g_292) = (*g_294);
                }
                else
                { /* block id: 191 */
                    return l_374;
                    /* statement id: 192 */
                    //assert (g_356 == &g_52 || g_356 == dangling || g_356 == &g_93);
                }
            }
            /* facts after for loop */
            assert (p_23 == &l_346 || p_23 == 0);
            assert (p_26 == &p_25 || p_26 == &l_280 || p_26 == &g_2);
            assert (g_356 == &g_52 || g_356 == &p_25 || g_356 == &g_93);
            assert (l_359 == &p_25 || l_359 == 0);
            return l_375;
            /* statement id: 195 */
            //assert (g_356 == &g_52 || g_356 == dangling || g_356 == &g_93);
        }
    }
    else
    { /* block id: 197 */
        int32_t l_376 = 0x8A3E8C22;
        int16_t l_392 = 0;
        int32_t *l_393 = &g_93;
        int32_t **l_394 = &g_356;
        (*g_356) = ((l_376 < (safe_sub_func_int32_t_s_s((safe_add_func_int32_t_s_s((safe_add_func_uint16_t_u_u((safe_sub_func_int32_t_s_s((l_376 >= (safe_add_func_uint8_t_u_u(((g_2 < ((((+3U) != (((void*)0 != &g_86) <= p_25)) && (safe_mod_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(65534U, 7)), l_376))) >= g_113.f2)) != l_392), p_24))), (*g_356))), p_24)), l_392)), (*p_26)))) != (-7));
        (*l_394) = l_393;
        /* statement id: 199 */
        assert (g_356 == &g_93);
    }
    /* facts after branching */
    assert (g_356 == &g_93);
    for (g_113.f3 = 0; (g_113.f3 == 48); g_113.f3 = safe_add_func_int32_t_s_s(g_113.f3, 4))
    { /* block id: 203 */
        int32_t *l_397 = &g_93;
        if ((*p_26))
        { /* block id: 204 */
            struct S0 l_398 = {0xFD3BF148,0x92DC,0x27,0xF18D,0xC3,0x8C494CCD,0x8A};
            p_26 = l_397;
            /* statement id: 205 */
            assert (p_26 == &g_93);
            l_397 = l_397;
            (*p_26) = (g_113.f5 | 0x9549);
            l_398 = (**g_293);
        }
        else
        { /* block id: 209 */
            uint8_t l_401 = 8U;
            (*g_356) = (safe_mod_func_int8_t_s_s(7, (*l_397)));
            return l_401;
        }
        /* facts after branching */
        assert (p_26 == &g_93);
        (*l_397) = ((-1) == ((((*l_397) ^ (safe_mod_func_uint32_t_u_u((0x7C >= (*l_328)), (safe_mod_func_uint16_t_u_u((l_397 == (void*)0), ((g_2 & (((0x8BF0036B < (*l_397)) & p_24) && (*g_356))) && 0x17)))))) ^ 0x48) ^ g_406));
    }
    /* facts after for loop */
    assert (p_26 == &g_93 || p_26 == &g_2);
    return (*p_26);
}


/* ------------------------------------------ */
/* 
 * reads : g_113
 * writes: g_113
 */
static int32_t  func_31(int32_t  p_32, int32_t * p_33, int8_t  p_34)
{ /* block id: 108 */
    struct S0 *l_257 = &g_113;
    int32_t l_258 = (-1);
    (*l_257) = g_113;
    return l_258;
}


/* ------------------------------------------ */
/* 
 * reads : g_52 g_113.f3
 * writes: g_52
 */
static int16_t  func_37(int32_t  p_38, uint16_t  p_39)
{ /* block id: 101 */
    for (g_52 = 0; (g_52 < 22); g_52 = safe_add_func_uint16_t_u_u(g_52, 8))
    { /* block id: 104 */
        return p_39;
    }
    return g_113.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_113.f6 g_113.f5 g_52 g_113.f0 g_113.f4 g_93
 * writes:
 */
static uint16_t  func_41(int16_t  p_42, int32_t * p_43, int32_t * p_44, int8_t  p_45)
{ /* block id: 90 */
    int32_t l_223 = (-6);
    uint32_t l_224 = 0x1151F3E8;
    struct S0 l_242 = {1,-3,0,3U,4U,0x8E1F302E,0x20};
    l_224 = l_223;
    if (l_223)
    { /* block id: 92 */
        int32_t l_235 = (-2);
        struct S0 *l_243 = &l_242;
        int32_t *l_245 = &g_93;
        int32_t **l_244 = &l_245;
        l_235 = (((safe_mod_func_uint32_t_u_u((0x1C && ((safe_rshift_func_uint16_t_u_s(p_45, ((((safe_add_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(((0x95 && (((p_45 <= (3U < (l_235 || (safe_mod_func_uint32_t_u_u(((safe_sub_func_uint8_t_u_u(((safe_rshift_func_int16_t_s_s(p_45, l_235)) || 0xD4AA), (-1))) || 0x9D89), p_42))))) <= 0x2C) && g_2)) ^ l_223), 0)), 9)), (-3))) | p_42) >= 0xCBE35802) >= 0x626AAE36))) != p_45)), g_113.f6)) & (-1)) && g_113.f5);
        (*l_243) = l_242;
        (*l_244) = &l_223;
        /* statement id: 95 */
        assert (l_245 == &l_223);
    }
    else
    { /* block id: 96 */
        int32_t *l_247 = &l_223;
        int32_t **l_246 = &l_247;
        (*l_246) = &l_223;
        (*l_247) = ((((g_52 || ((g_113.f0 == (**l_246)) != (0xBE & ((safe_sub_func_uint16_t_u_u(l_242.f1, (0x8EEE2E21 && ((safe_unary_minus_func_uint16_t_u(g_113.f4)) & 4294967291U)))) != (safe_rshift_func_int16_t_s_u(g_52, 10)))))) > p_45) | g_93) && g_52);
    }
    return l_223;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_52 g_86 g_113.f1 g_93 g_113.f6 g_113.f5 g_113.f3 g_113.f2 g_113.f0
 * writes: g_52 g_86
 */
static int32_t  func_48(int8_t  p_49, int16_t  p_50)
{ /* block id: 4 */
    int32_t *l_51 = &g_52;
    uint32_t l_198 = 1U;
    struct S0 l_206 = {0xA27C4603,0xE333,0,65529U,0U,4294967289U,0x0B};
    int32_t **l_209 = &l_51;
    struct S0 *l_215 = &l_206;
    struct S0 **l_214 = &l_215;
    (*l_51) = p_50;
    if (func_53(g_2))
    { /* block id: 8 */
        uint16_t l_80 = 0x421A;
        uint32_t l_81 = 0x9045039A;
        int16_t l_82 = 0x3599;
        int32_t *l_96 = &g_93;
        struct S0 *l_126 = (void*)0;
        if ((((void*)0 != &g_52) != ((safe_unary_minus_func_int16_t_s((((0 && ((((safe_lshift_func_uint16_t_u_s(((g_52 != (safe_sub_func_int8_t_s_s((-5), (+(safe_add_func_int16_t_s_s((safe_add_func_uint16_t_u_u((safe_sub_func_int8_t_s_s((safe_add_func_int16_t_s_s((((((safe_lshift_func_int8_t_s_s((+5U), 6)) | ((((((p_49 > (safe_rshift_func_int8_t_s_s((((((safe_sub_func_int32_t_s_s((((0x23 > ((((safe_add_func_int16_t_s_s((safe_add_func_uint8_t_u_u((p_49 < l_80), p_50)), (*l_51))) > (*l_51)) && (*l_51)) || g_2)) <= 0x6A) == 0x66), l_80)) & 0U) || g_2) <= p_50) == l_81), (*l_51)))) >= p_50) < 0) | g_2) & (*l_51)) > g_52)) || p_49) < l_80) >= g_2), l_81)), p_49)), p_49)), l_81)))))) <= p_49), 12)) && (*l_51)) < l_80) & g_52)) ^ g_2) > l_82))) && g_52)))
        { /* block id: 9 */
            for (p_49 = 0; (p_49 < (-5)); --p_49)
            { /* block id: 12 */
                int32_t *l_85 = (void*)0;
                l_85 = (void*)0;
                g_86 = g_86;
            }
        }
        else
        { /* block id: 16 */
            int32_t **l_101 = &l_51;
            int32_t l_137 = 0x70EF1A53;
            struct S0 **l_183 = &l_126;
            for (g_52 = 13; (g_52 > 3); g_52--)
            { /* block id: 19 */
                struct S0 *l_102 = (void*)0;
                int32_t *l_119 = (void*)0;
            }
        }
        (*l_51) = (safe_sub_func_uint32_t_u_u(p_50, (safe_add_func_uint8_t_u_u((((((((void*)0 == g_86) <= 1U) < 0x8701) != ((p_49 > 1U) & p_49)) & ((((safe_rshift_func_uint8_t_u_s(7U, 5)) && 0x65) ^ g_113.f1) || g_93)) || p_49), p_50))));
        l_51 = &g_52;
        (*l_51) = 0xB76923BB;
    }
    else
    { /* block id: 71 */
        int32_t **l_197 = &l_51;
        if ((((((safe_add_func_uint8_t_u_u(255U, (safe_add_func_int16_t_s_s((safe_rshift_func_uint8_t_u_s(g_113.f6, g_2)), (&l_51 != l_197))))) >= (l_198 != (((((safe_unary_minus_func_uint16_t_u(p_49)) > g_113.f5) || ((safe_mod_func_int16_t_s_s(((safe_add_func_uint16_t_u_u((safe_lshift_func_int8_t_s_u(p_49, (**l_197))), 0x99A6)) > 0x9DEFF53B), 0x9365)) <= p_50)) > (**l_197)) < 0x5B))) && g_113.f3) < 65535U) > g_113.f1))
        { /* block id: 72 */
            struct S0 *l_207 = &l_206;
            (*l_207) = l_206;
        }
        else
        { /* block id: 74 */
            int32_t *l_208 = (void*)0;
            (*l_197) = l_51;
            (*l_197) = l_208;
            /* statement id: 76 */
            assert (l_51 == 0);
            return p_50;
        }
    }
    (*l_209) = l_51;
    if ((((safe_mod_func_int32_t_s_s((**l_209), ((safe_sub_func_int16_t_s_s(((void*)0 == l_214), (*l_51))) && g_113.f2))) | 0x67) || (*l_51)))
    { /* block id: 81 */
        int32_t *l_216 = &g_93;
        (*l_51) = p_49;
        (*l_209) = (*l_209);
        (*l_209) = l_216;
        /* statement id: 84 */
        assert (l_51 == &g_93);
    }
    else
    { /* block id: 85 */
        int32_t **l_217 = &l_51;
        (**l_217) = (g_52 ^ (1U | (((l_217 == (void*)0) >= (p_50 ^ (~0x57))) & ((((**l_217) | (((((safe_add_func_uint32_t_u_u(g_113.f0, g_52)) < (*l_51)) >= (*l_51)) || 0xE5BD) != (**l_209))) > 9) & p_49))));
        (**l_217) = (0xDF10BACB > 0);
    }
    /* facts after branching */
    assert (l_51 == &g_52 || l_51 == &g_93);
    return (*l_51);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_53(int32_t  p_54)
{ /* block id: 6 */
    return p_54;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_52, "g_52", print_hash_value);
    transparent_crc(g_93, "g_93", print_hash_value);
    transparent_crc(g_113.f0, "g_113.f0", print_hash_value);
    transparent_crc(g_113.f1, "g_113.f1", print_hash_value);
    transparent_crc(g_113.f2, "g_113.f2", print_hash_value);
    transparent_crc(g_113.f3, "g_113.f3", print_hash_value);
    transparent_crc(g_113.f4, "g_113.f4", print_hash_value);
    transparent_crc(g_113.f5, "g_113.f5", print_hash_value);
    transparent_crc(g_113.f6, "g_113.f6", print_hash_value);
    transparent_crc(g_406, "g_406", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 75
   depth: 1, occurrence: 8
XXX total union variables: 0

XXX max expression depth: 44
breakdown:
   depth: 1, occurrence: 136
   depth: 2, occurrence: 20
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 7, occurrence: 2
   depth: 9, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 25, occurrence: 1
   depth: 43, occurrence: 1
   depth: 44, occurrence: 1

XXX total number of pointers: 91

XXX times a variable address is taken: 96
XXX times a pointer is dereferenced on RHS: 54
breakdown:
   depth: 1, occurrence: 42
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 63
breakdown:
   depth: 1, occurrence: 54
   depth: 2, occurrence: 6
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 253

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 223
   level: 2, occurrence: 65
   level: 3, occurrence: 24
   level: 4, occurrence: 2
   level: 5, occurrence: 7
XXX number of pointers point to pointers: 43
XXX number of pointers point to scalars: 35
XXX number of pointers point to structs: 13
XXX percent of pointers has null in alias set: 29.7
XXX average alias set size: 1.23

XXX times a non-volatile is read: 439
XXX times a non-volatile is write: 180
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 111
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 25
   depth: 2, occurrence: 17
   depth: 3, occurrence: 11
   depth: 4, occurrence: 15
   depth: 5, occurrence: 18

XXX percentage a fresh-made variable is used: 16.2
XXX percentage an existing variable is used: 83.8
********************* end of statistics **********************/

