/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --jumps --no-longlong --no-force-non-uniform-arrays --no-math64 --muls --no-packed-struct --paranoid --pointers --no-structs --inline-function --no-return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      15767281926754627552
 */


#define NO_LONGLONG

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint32_t g_9 = 1U;
static uint8_t g_19 = 0x8E;
static int32_t g_28 = 5;
static uint8_t g_61 = 0x5A;
static uint8_t * const g_60 = &g_61;
static uint8_t * const g_63 = (void*)0;
static uint8_t * const *g_62 = &g_63;
static uint16_t g_79 = 1U;
static int32_t * const g_81 = (void*)0;
static int32_t g_101 = 0x5BDF5444;
static int32_t **g_108 = (void*)0;
static int32_t *g_114 = &g_28;
static uint16_t *g_124 = &g_79;
static uint16_t **g_123 = &g_124;
static int32_t g_126 = (-9);
static int32_t *g_125 = &g_126;
static uint32_t g_145 = 0U;
static uint32_t g_150 = 9U;
static uint32_t g_153 = 4294967294U;
static uint16_t g_155 = 0x9A86;
static uint32_t g_167 = 0xBD61F34F;
static int8_t g_168 = 1;


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_1(void);
static const int16_t  func_13(int32_t  p_14, int8_t  p_15, uint8_t  p_16, uint32_t  p_17);
static uint8_t  func_20(uint32_t  p_21, const int32_t  p_22, uint32_t  p_23);
static const int32_t  func_25(int32_t  p_26);
inline static const int32_t  func_31(const int32_t * const  p_32, int32_t  p_33, uint32_t  p_34);
static const int32_t * const  func_35(int32_t  p_36, uint8_t * p_37, uint8_t * p_38, int32_t * p_39);
inline static uint8_t * func_40(uint32_t  p_41, uint8_t * p_42, int32_t  p_43);
inline static uint32_t  func_44(uint32_t  p_45, const uint8_t * p_46, int16_t  p_47);
inline static uint32_t  func_48(uint32_t  p_49, uint16_t  p_50, int16_t  p_51, int32_t * const  p_52);
inline static uint16_t  func_57(uint8_t * const  p_58, uint32_t  p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_9 g_28 g_60 g_153 g_101 g_124 g_79 g_123 g_168 g_114
 * writes: g_19 g_28 g_125 g_61 g_167 g_114
 */
inline static uint16_t  func_1(void)
{ /* block id: 0 */
    uint8_t *l_18 = &g_19;
    int32_t *l_27 = &g_28;
    int32_t l_161 = 0xBAC90574;
    int32_t **l_169 = (void*)0;
    int32_t **l_170 = &g_114;
    (*g_114) = (safe_div_func_int32_t_s_s(((safe_add_func_int32_t_s_s((+(safe_mul_func_int16_t_s_s(g_9, (g_167 = (((!(safe_mod_func_int16_t_s_s(func_13((g_9 && g_9), (((*l_18) = 0xC3) == ((*g_60) = func_20((+(-9)), func_25(((*l_27) = g_9)), ((safe_rshift_func_uint8_t_u_u(l_161, (((safe_mod_func_int16_t_s_s(g_9, l_161)) >= g_9) || 0xCEA799AD))) == 9U)))), g_153, g_101), (*g_124)))) == (**g_123)) <= 4294967295U))))), g_168)) > g_9), l_161));
    (*l_170) = &l_161;
    /* statement id: 78 */
    assert (g_114 == &l_161);
    return (*l_27);
    /* statement id: 79 */
    //assert (g_114 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_13(int32_t  p_14, int8_t  p_15, uint8_t  p_16, uint32_t  p_17)
{ /* block id: 74 */
    const uint8_t l_166 = 0x3F;
    return l_166;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_125
 */
static uint8_t  func_20(uint32_t  p_21, const int32_t  p_22, uint32_t  p_23)
{ /* block id: 70 */
    int32_t *l_164 = &g_126;
    int32_t **l_165 = &g_125;
    (*l_165) = l_164;
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads : g_28
 * writes: g_28
 */
static const int32_t  func_25(int32_t  p_26)
{ /* block id: 3 */
    int8_t l_29 = 0xB9;
    int32_t *l_30 = &g_28;
    uint16_t *l_78 = &g_79;
    uint32_t l_80 = 0x265D6326;
    const uint8_t *l_115 = &g_61;
    uint8_t *l_118 = &g_61;
    (*l_30) = (l_29 = p_26);
    return (*l_30);
}


/* ------------------------------------------ */
/* 
 * reads : g_125 g_126 g_124 g_60 g_61 g_28 g_114
 * writes: g_145 g_150 g_79 g_153 g_155 g_114
 */
inline static const int32_t  func_31(const int32_t * const  p_32, int32_t  p_33, uint32_t  p_34)
{ /* block id: 50 */
    int32_t ** const l_143 = &g_114;
    uint32_t *l_144 = &g_145;
    uint32_t *l_148 = (void*)0;
    uint32_t *l_149 = &g_150;
    uint32_t *l_151 = (void*)0;
    uint32_t *l_152 = &g_153;
    uint16_t *l_154 = &g_155;
    int32_t *l_156 = &g_126;
    if ((safe_sub_func_uint32_t_u_u(((safe_mod_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s(((*l_154) = (safe_sub_func_uint32_t_u_u(p_34, (+(safe_rshift_func_uint8_t_u_u(((safe_add_func_int32_t_s_s((!0x93F2), ((*l_152) = (((*g_124) = ((safe_rshift_func_uint16_t_u_u(65534U, (((*l_144) = ((void*)0 == l_143)) ^ ((*l_149) = (safe_add_func_uint8_t_u_u(0x35, 8)))))) <= (*g_125))) == 0xB981)))) >= 8), (*g_60))))))), p_34)), 0x8462BD54)) >= (*p_32)), p_33)))
    { /* block id: 56 */
        if ((**l_143))
        { /* block id: 57 */
            (*l_143) = l_156;
            /* statement id: 58 */
            assert (g_114 == &g_126);
        }
        else
        { /* block id: 59 */
            return (*p_32);
        }
        /* facts after branching */
        assert (g_114 == &g_126);
    }
    else
    { /* block id: 62 */
        int32_t *l_157 = &g_28;
        (*l_143) = l_157;
    }
    /* facts after branching */
    assert (g_114 == &g_28 || g_114 == &g_126);
    return (*g_125);
}


/* ------------------------------------------ */
/* 
 * reads : g_114
 * writes: g_28 g_126
 */
static const int32_t * const  func_35(int32_t  p_36, uint8_t * p_37, uint8_t * p_38, int32_t * p_39)
{ /* block id: 46 */
    (*p_39) = ((*g_114) = 0x77BDFF10);
    return &g_28;
    /* statement id: 49 */
    //assert (func_35_rv == &g_28);
}


/* ------------------------------------------ */
/* 
 * reads : g_114 g_123
 * writes: g_28 g_123 g_126
 */
inline static uint8_t * func_40(uint32_t  p_41, uint8_t * p_42, int32_t  p_43)
{ /* block id: 37 */
    (*g_114) = (safe_sub_func_uint32_t_u_u(0x455642E0, 0xA29C5D07));
    for (p_41 = (-20); (p_41 > 47); ++p_41)
    { /* block id: 41 */
        g_123 = g_123;
        if (p_43)
            continue;
    }
    return p_42;
    /* statement id: 45 */
    //assert (func_40_rv == &g_61);
}


/* ------------------------------------------ */
/* 
 * reads : g_101
 * writes: g_101
 */
inline static uint32_t  func_44(uint32_t  p_45, const uint8_t * p_46, int16_t  p_47)
{ /* block id: 30 */
    for (g_101 = 0; (g_101 != (-17)); g_101--)
    { /* block id: 33 */
        return p_47;
    }
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads : g_28 g_9 g_61 g_79 g_108
 * writes: g_101 g_28 g_114
 */
inline static uint32_t  func_48(uint32_t  p_49, uint16_t  p_50, int16_t  p_51, int32_t * const  p_52)
{ /* block id: 12 */
    const uint32_t l_84 = 4294967288U;
    int32_t *l_110 = (void*)0;
    int32_t **l_109 = &l_110;
    int32_t *l_113 = &g_28;
    for (p_50 = (-24); (p_50 <= 52); p_50 = safe_add_func_uint8_t_u_u(p_50, 1))
    { /* block id: 15 */
        int32_t *l_100 = &g_101;
        int16_t l_102 = 0x5C01;
        const int16_t l_111 = 0x0EC4;
        if (((p_51 = ((l_84 ^ (-1)) & (0x82E7 < (0xD4DC == (p_49 || ((safe_rshift_func_uint8_t_u_s((safe_rshift_func_int8_t_s_s((safe_mod_func_int32_t_s_s((safe_sub_func_int8_t_s_s((((safe_mod_func_uint16_t_u_u(g_28, l_84)) | (((+0xC1) & (((*l_100) = ((safe_lshift_func_int16_t_s_u((((safe_div_func_uint16_t_u_u(g_9, l_84)) >= g_61) | l_84), 3)) >= g_79)) & p_51)) && l_102)) ^ g_28), l_102)), p_51)), p_49)), p_50)) > 4294967291U)))))) > p_50))
        { /* block id: 18 */
            int32_t **l_104 = &l_100;
            (*l_100) = (~p_50);
            (*l_104) = &g_28;
            /* statement id: 20 */
            assert (l_100 == &g_28);
        }
        else
        { /* block id: 21 */
            uint8_t l_105 = 0xA5;
            int32_t *l_112 = &g_28;
            (*l_112) = ((0 | ((((((*l_100) = l_105) == (0U > (safe_sub_func_int8_t_s_s(((((l_109 = g_108) == &p_52) >= ((void*)0 != &l_105)) & ((g_61 == l_111) >= (-7))), 0U)))) & 0x1E) != p_49) ^ 4294967293U)) != p_49);
            /* statement id: 24 */
            assert (l_109 == 0);
        }
        /* facts after branching */
        assert (l_100 == &g_101 || l_100 == &g_28);
        g_114 = l_113;
        /* statement id: 26 */
        assert (g_114 == &g_28);
        if ((*l_113))
            continue;
    }
    /* facts after for loop */
    assert (l_109 == 0 || l_109 == &l_110);
    return g_9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_62 g_28
 */
inline static uint16_t  func_57(uint8_t * const  p_58, uint32_t  p_59)
{ /* block id: 6 */
    uint32_t l_67 = 0U;
    int32_t l_68 = 0x1606DC06;
    int32_t *l_69 = &g_28;
    g_62 = &g_60;
    /* statement id: 7 */
    assert (g_62 == &g_60);
    (*l_69) = (p_59 < ((safe_mul_func_uint16_t_u_u(0x4D71, 0x6C93)) || (!(l_68 = l_67))));
    return p_59;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_9;
    csmith_sink_ = g_19;
    csmith_sink_ = g_28;
    csmith_sink_ = g_61;
    csmith_sink_ = g_79;
    csmith_sink_ = g_101;
    csmith_sink_ = g_126;
    csmith_sink_ = g_145;
    csmith_sink_ = g_150;
    csmith_sink_ = g_153;
    csmith_sink_ = g_155;
    csmith_sink_ = g_167;
    csmith_sink_ = g_168;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 28
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 39
   depth: 2, occurrence: 6
   depth: 5, occurrence: 1
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 45

XXX times a variable address is taken: 36
XXX times a pointer is dereferenced on RHS: 11
breakdown:
   depth: 1, occurrence: 9
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 26
breakdown:
   depth: 1, occurrence: 26
XXX times a pointer is compared with null: 3
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 101

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 85
   level: 2, occurrence: 6
XXX number of pointers point to pointers: 9
XXX number of pointers point to scalars: 36
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 20
XXX average alias set size: 1.13

XXX times a non-volatile is read: 105
XXX times a non-volatile is write: 63
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 35
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 22
   depth: 1, occurrence: 8
   depth: 2, occurrence: 5

XXX percentage a fresh-made variable is used: 19.6
XXX percentage an existing variable is used: 80.4
********************* end of statistics **********************/

