/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --jumps --no-longlong --no-force-non-uniform-arrays --math64 --muls --no-packed-struct --no-paranoid --pointers --structs --no-inline-function --return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      3133989784
 */


#define NO_LONGLONG

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
   int32_t  f1;
   uint32_t  f2;
   uint8_t  f3;
   uint16_t  f4;
   int32_t  f5;
   signed f6 : 23;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0xADE2167F;
static struct S0 g_40 = {0xB64D,0x7DDBF4DF,3U,0x66,0xC3A6,-1,-2467};
static struct S0 g_89 = {0x8DFE,-2,1U,247U,65535U,0xAB70486D,-1028};
static uint32_t g_97 = 0xD8B12ACF;
static struct S0 *g_125 = (void*)0;
static int32_t *g_137 = &g_40.f5;
static int32_t **g_136 = &g_137;
static int32_t ***g_158 = &g_136;
static int32_t ****g_157 = &g_158;
static uint16_t g_245 = 0x576A;
static struct S0 **g_299 = &g_125;
static struct S0 ***g_298 = &g_299;
static uint16_t g_343 = 4U;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static struct S0 * func_5(struct S0 * p_6, int32_t  p_7, struct S0 * p_8, int32_t  p_9, uint16_t  p_10);
static struct S0 * func_11(int32_t  p_12, int16_t  p_13, int32_t  p_14, uint32_t  p_15, struct S0 * p_16);
static int16_t  func_30(uint32_t  p_31, struct S0 * p_32, struct S0 * p_33, uint8_t  p_34, struct S0 * p_35);
static struct S0 * func_36(struct S0 * p_37, uint32_t  p_38);
static struct S0  func_41(struct S0 * p_42);
static uint8_t  func_49(struct S0 * p_50, uint32_t  p_51);
static struct S0 * func_52(uint16_t  p_53, struct S0 * p_54);
static uint16_t  func_55(uint16_t  p_56, uint32_t  p_57, int16_t  p_58, uint32_t  p_59);
static int8_t  func_62(struct S0 * p_63, int32_t  p_64);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_40.f1 g_40.f4 g_40.f0 g_40.f5 g_40 g_97 g_89.f1 g_89.f4 g_89 g_125 g_136 g_137 g_157 g_158 g_245 g_298 g_299 g_343
 * writes: g_2 g_40.f1 g_40.f5 g_89 g_40 g_137 g_125 g_158 g_245
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int16_t l_17 = 0x8F0D;
    struct S0 *l_132 = (void*)0;
    for (g_2 = 0; (g_2 > 11); ++g_2)
    { /* block id: 3 */
        struct S0 *l_39 = &g_40;
        int32_t l_131 = 0x2804CE6F;
        (*g_299) = func_5(func_11(l_17, (safe_mod_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_s((g_2 || (safe_mod_func_int8_t_s_s((safe_rshift_func_uint16_t_u_s((0x1AC3DC99 & (safe_mul_func_uint16_t_u_u(65529U, (safe_mod_func_int16_t_s_s(func_30(g_2, func_36(l_39, ((void*)0 != &g_40)), l_39, g_97, g_125), g_97))))), g_97)), 248U))), l_131)), 1)), g_2, g_97, l_132), g_2, l_132, l_131, g_97);
        return g_40.f4;
    }
    (**g_136) = (((l_17 && (((g_89.f4 < ((*g_136) != (*g_136))) >= (safe_sub_func_int8_t_s_s((((g_89.f4 == (((safe_rshift_func_uint16_t_u_u((l_17 != g_89.f0), (!(((safe_sub_func_uint8_t_u_u(l_17, (safe_rshift_func_uint8_t_u_s(g_40.f3, 3)))) & g_97) >= l_17)))) != l_17) ^ g_97)) < 0xC08B) ^ l_17), g_89.f1))) < l_17)) >= 0x9720) && g_343);
    return l_17;
}


/* ------------------------------------------ */
/* 
 * reads : g_157 g_158 g_136 g_89.f4 g_299 g_125
 * writes: g_40.f5 g_89.f4 g_137
 */
static struct S0 * func_5(struct S0 * p_6, int32_t  p_7, struct S0 * p_8, int32_t  p_9, uint16_t  p_10)
{ /* block id: 143 */
    int32_t **l_324 = (void*)0;
    int32_t *l_329 = (void*)0;
lbl_328:
    for (p_10 = (-7); (p_10 == 54); ++p_10)
    { /* block id: 146 */
        uint8_t l_325 = 0x0D;
        int32_t *l_326 = (void*)0;
        int32_t *l_327 = &g_40.f5;
        (*l_327) = (safe_rshift_func_uint16_t_u_u(p_9, ((l_324 == (**g_157)) < l_325)));
        if (p_10)
            goto lbl_328;
    }
    g_40.f5 = 0xCC21393E;
    for (g_89.f4 = 0; (g_89.f4 >= 41); ++g_89.f4)
    { /* block id: 153 */
        int32_t *l_332 = (void*)0;
        struct S0 l_333 = {65534U,0x1C0DFE4C,4294967293U,0U,0xEA13,0x61F875AD,-2795};
        (***g_157) = l_332;
        if (g_89.f4)
            goto lbl_328;
        l_333 = l_333;
    }
    return (*g_299);
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f1 g_136 g_137 g_157 g_40.f5 g_40.f3 g_158 g_2 g_89.f1 g_40 g_89.f5 g_97 g_89.f4 g_89 g_125 g_245 g_298 g_299
 * writes: g_40.f5 g_40.f1 g_137 g_89.f5 g_89.f1 g_40 g_89 g_125 g_158 g_245
 */
static struct S0 * func_11(int32_t  p_12, int16_t  p_13, int32_t  p_14, uint32_t  p_15, struct S0 * p_16)
{ /* block id: 47 */
    struct S0 *l_135 = (void*)0;
    int32_t *l_142 = &g_89.f5;
    uint32_t l_178 = 3U;
    uint8_t l_244 = 0xC0;
    int32_t ***l_251 = &g_136;
    struct S0 **l_253 = &g_125;
    struct S0 ***l_252 = &l_253;
    struct S0 **l_257 = &g_125;
    uint32_t l_284 = 4294967288U;
    struct S0 l_288 = {0U,0x57A2E974,8U,0xB8,65530U,0x7C837AE3,1714};
    uint32_t l_305 = 4U;
    if ((safe_mul_func_int8_t_s_s(g_40.f1, (l_135 != &g_89))))
    { /* block id: 48 */
        int16_t l_138 = 0x6DEA;
        struct S0 *l_149 = &g_89;
        int32_t ****l_159 = &g_158;
        uint32_t l_160 = 1U;
        if (((void*)0 != g_136))
        { /* block id: 49 */
            struct S0 *l_143 = (void*)0;
            int32_t l_144 = 9;
            int32_t *l_171 = &g_40.f1;
            if (l_138)
            { /* block id: 50 */
                int32_t ****l_139 = (void*)0;
                int32_t ***l_141 = &g_136;
                int32_t ****l_140 = &l_141;
                (*l_140) = &g_136;
                l_142 = (*g_136);
                return l_143;
            }
            else
            { /* block id: 54 */
                struct S0 **l_170 = &l_143;
                struct S0 ***l_169 = &l_170;
                (*g_137) = (0x41E9 | l_144);
                for (g_40.f1 = (-24); (g_40.f1 > (-11)); g_40.f1 = safe_add_func_int32_t_s_s(g_40.f1, 1))
                { /* block id: 58 */
                    struct S0 l_147 = {0U,-10,4294967286U,7U,65535U,0x4370A8D4,-1087};
                    struct S0 *l_148 = &l_147;
                    l_147 = l_147;
                    (*l_148) = l_147;
                    if ((0 & l_147.f4))
                    { /* block id: 61 */
                        (****l_159) = (l_147.f5 == (((l_149 == p_16) ^ ((0x55696F08 < (safe_rshift_func_uint16_t_u_u(0x6E85, 12))) & (safe_sub_func_uint16_t_u_u((((safe_rshift_func_uint8_t_u_s((safe_unary_minus_func_uint8_t_u(0x5B)), 2)) || ((g_157 != l_159) >= (((p_14 & (**g_136)) | g_40.f3) >= l_160))) && (***g_158)), g_2)))) || 0));
                        return &g_89;
                    }
                    else
                    { /* block id: 64 */
                        (*g_136) = (*g_136);
                        (*l_142) = p_15;
                        return &g_89;
                    }
                }
                for (g_89.f1 = (-26); (g_89.f1 <= (-23)); g_89.f1 = safe_add_func_int16_t_s_s(g_89.f1, 7))
                { /* block id: 72 */
                    int16_t l_167 = 1;
                    int32_t *l_168 = &g_40.f1;
                    (*l_142) = (safe_lshift_func_int16_t_s_s((safe_sub_func_int8_t_s_s(0x22, l_167)), 10));
                    g_40 = g_40;
                    (**g_158) = l_168;
                    (**g_158) = l_168;
                }
                (*l_169) = &l_149;
            }
            l_171 = (*g_136);
            (**g_158) = &l_144;
            return l_135;
        }
        else
        { /* block id: 83 */
            (***l_159) = (***g_157);
            if ((safe_mul_func_uint16_t_u_u(((***g_157) == l_142), (safe_sub_func_int8_t_s_s((*l_142), (&p_16 == &p_16))))))
            { /* block id: 85 */
                (***g_158) = 6;
            }
            else
            { /* block id: 87 */
                struct S0 **l_179 = (void*)0;
                struct S0 **l_180 = &g_125;
                int32_t *l_181 = &g_89.f5;
                (*l_180) = func_36(func_36(func_36(l_149, (safe_rshift_func_uint8_t_u_s(l_178, 7))), g_40.f6), ((&g_158 == (void*)0) >= 0x6370));
                (*g_125) = (**l_180);
                (*g_136) = l_181;
            }
        }
        (*l_159) = (*g_157);
    }
    else
    { /* block id: 94 */
        int32_t *l_227 = &g_89.f1;
        int32_t l_228 = 0xC8820D8B;
        int32_t ****l_233 = (void*)0;
        uint16_t l_258 = 0x5702;
        if (p_14)
        { /* block id: 95 */
            uint8_t l_186 = 246U;
            int32_t l_215 = 0x19322E61;
            (***g_158) = (safe_mul_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u(0x6F35, l_186)), 0U));
            (*l_142) = (safe_lshift_func_int8_t_s_s((((safe_lshift_func_int16_t_s_u((((g_97 | (safe_lshift_func_int8_t_s_u((safe_mod_func_uint8_t_u_u(((safe_sub_func_int16_t_s_s(p_14, (safe_mul_func_int8_t_s_s(l_186, (safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_u((safe_mod_func_int8_t_s_s((p_15 == (p_12 & (safe_mod_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(((safe_add_func_uint16_t_u_u(p_12, g_89.f0)) > ((p_13 || (safe_add_func_int32_t_s_s(((safe_rshift_func_uint16_t_u_u(0x34E3, l_186)) | l_186), 1U))) >= (-1))), (*l_142))), g_89.f3)))), (*l_142))), l_186)), 4294967293U)))))) == l_186), l_215)), 7))) > (*l_142)) & p_12), g_40.f5)) != l_215) || 0x3A77), l_186));
        }
        else
        { /* block id: 98 */
            uint32_t l_236 = 4294967295U;
            uint32_t l_243 = 1U;
            int32_t *****l_246 = &g_157;
            (*l_142) = (safe_add_func_int16_t_s_s(((safe_mod_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((((safe_rshift_func_int16_t_s_s((+(safe_add_func_int32_t_s_s(((-1) && ((***g_157) == l_227)), (&g_89 != p_16)))), 8)) & 0xDB) >= (4294967295U < g_89.f1)), 6)), p_12)) == (*l_142)), l_228));
            (**g_158) = (*g_136);
            for (g_40.f3 = 0; (g_40.f3 == 11); ++g_40.f3)
            { /* block id: 103 */
                int32_t l_259 = 0xDA0F3384;
                if (((safe_sub_func_uint16_t_u_u(((void*)0 != l_233), ((*l_142) ^ (safe_sub_func_int16_t_s_s(0x05FB, (l_236 <= ((l_236 & p_14) >= (((safe_mod_func_int32_t_s_s((safe_sub_func_uint32_t_u_u(0x1D69C6CB, (safe_mul_func_int16_t_s_s(l_243, l_244)))), g_245)) & l_236) & (-1))))))))) || g_2))
                { /* block id: 104 */
                    l_246 = &l_233;
                    (*l_227) = ((safe_mul_func_int16_t_s_s(0x8C49, (g_40.f2 >= ((8U != (l_251 != (void*)0)) <= (l_252 != (void*)0))))) ^ ((p_13 || (((+(safe_add_func_int8_t_s_s((((*l_252) != l_257) || l_258), l_259))) || 0xDDAD4C54) && p_14)) >= g_245));
                }
                else
                { /* block id: 107 */
                    (***g_157) = &l_228;
                }
            }
            (***g_157) = (**l_251);
        }
        (*g_136) = (**l_251);
    }
    if ((safe_mul_func_uint8_t_u_u(0U, (safe_sub_func_uint16_t_u_u((*l_142), ((p_14 & (safe_sub_func_uint16_t_u_u((((safe_mul_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_u((safe_mod_func_int8_t_s_s((0xF1 < (((((safe_lshift_func_uint16_t_u_s(((safe_rshift_func_uint8_t_u_s(((safe_add_func_uint16_t_u_u((safe_add_func_uint32_t_u_u((safe_mod_func_uint8_t_u_u(0x39, (safe_sub_func_uint32_t_u_u(p_14, ((*l_142) >= ((void*)0 != l_251)))))), 4294967290U)), 0xD317)) && l_284), p_15)) && 0x9B), 12)) ^ p_13) > p_12) > (*l_142)) | p_15)), 0x83)), 1)) >= (*l_142)) < g_97), p_15)) >= 9) & (*l_142)), 65534U))) & g_40.f3))))))
    { /* block id: 115 */
        return p_16;
    }
    else
    { /* block id: 117 */
        struct S0 l_289 = {0xAFF7,0xD6A1B3C1,0xEC739D5C,0xE0,65535U,-1,-295};
        int32_t *****l_304 = &g_157;
        int32_t *l_319 = &g_2;
        for (g_245 = 0; (g_245 == 8); g_245++)
        { /* block id: 120 */
            int32_t *l_295 = &g_89.f1;
            if ((!1U))
            { /* block id: 121 */
                int32_t ****l_294 = &g_158;
                l_289 = l_288;
                (*l_257) = (**l_252);
                for (g_40.f2 = 0; (g_40.f2 > 10); g_40.f2++)
                { /* block id: 126 */
                    (*l_142) = ((-1) || p_14);
                    if ((safe_sub_func_int8_t_s_s(((void*)0 == l_294), 251U)))
                    { /* block id: 128 */
                        return p_16;
                    }
                    else
                    { /* block id: 130 */
                        return p_16;
                    }
                }
            }
            else
            { /* block id: 134 */
                l_289 = l_289;
            }
            (**g_158) = l_295;
        }
        (*l_142) = (safe_rshift_func_uint8_t_u_u(0xD3, ((0x97B8A6DA & l_289.f0) >= (((p_14 ^ (&l_253 == g_298)) | g_89.f0) && (safe_mod_func_int16_t_s_s((p_13 ^ ((safe_mod_func_uint8_t_u_u(((l_304 == &g_157) == l_305), p_15)) == g_97)), p_14))))));
        (*g_299) = (**g_298);
    }
    return (**g_298);
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f2 g_40.f5
 * writes: g_40.f2
 */
static int16_t  func_30(uint32_t  p_31, struct S0 * p_32, struct S0 * p_33, uint8_t  p_34, struct S0 * p_35)
{ /* block id: 39 */
    int32_t *l_126 = &g_40.f5;
    int32_t **l_127 = &l_126;
    int16_t l_130 = 0x1AB8;
    (*l_127) = l_126;
    for (g_40.f2 = 0; (g_40.f2 <= 34); ++g_40.f2)
    { /* block id: 43 */
        return (**l_127);
    }
    return l_130;
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f1 g_40.f4 g_40.f0 g_40.f5 g_40 g_97 g_89.f1 g_89.f4 g_89 g_2
 * writes: g_40.f1 g_40.f5 g_89 g_40
 */
static struct S0 * func_36(struct S0 * p_37, uint32_t  p_38)
{ /* block id: 4 */
    struct S0 *l_43 = &g_40;
    int32_t *l_105 = (void*)0;
    int32_t **l_106 = &l_105;
    int32_t *l_121 = &g_2;
    uint8_t l_122 = 255U;
    int32_t l_123 = 7;
    int32_t l_124 = 0xB33379BB;
    (*p_37) = func_41(l_43);
    (*l_106) = l_105;
    l_124 = (safe_mul_func_uint8_t_u_u(0x6A, (safe_rshift_func_uint8_t_u_u((((safe_mul_func_int16_t_s_s((safe_sub_func_int8_t_s_s(((safe_mod_func_int16_t_s_s(g_89.f2, ((safe_mod_func_int32_t_s_s((p_38 || (247U != g_89.f4)), (g_40.f6 | (4294967288U <= g_89.f0)))) ^ ((safe_mul_func_int16_t_s_s(((l_121 == (*l_106)) == 0xFACDC9FF), (*l_121))) == p_38)))) != g_97), l_122)), 65532U)) || l_123) > 250U), 7))));
    return &g_40;
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f1 g_40.f4 g_40.f0 g_40.f5 g_40 g_97 g_89.f1 g_89.f4 g_89
 * writes: g_40.f1 g_40.f5 g_89
 */
static struct S0  func_41(struct S0 * p_42)
{ /* block id: 5 */
    uint16_t l_65 = 0x05D0;
    uint8_t l_74 = 0U;
    struct S0 *l_79 = &g_40;
    uint32_t l_102 = 0U;
lbl_104:
    for (g_40.f1 = (-17); (g_40.f1 != 3); g_40.f1 = safe_add_func_uint32_t_u_u(g_40.f1, 4))
    { /* block id: 8 */
        int16_t l_46 = 0xC298;
        int32_t *l_87 = &g_40.f5;
        struct S0 *l_88 = &g_89;
        (*l_87) = (((l_46 == (safe_mul_func_uint8_t_u_u(func_49(func_52(func_55((safe_lshift_func_int8_t_s_u(func_62(p_42, l_65), (safe_mul_func_int16_t_s_s(l_46, (safe_mod_func_int16_t_s_s((0x04 && (safe_rshift_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u(l_46, ((0U || g_40.f1) | g_40.f4))), 1))), 0xA8B1)))))), l_74, l_46, l_46), l_79), g_40.f0), l_46))) >= 3U) != l_46);
        (*l_88) = (*l_79);
        if (((safe_add_func_uint16_t_u_u((((0x7E08A84A ^ (+(safe_mod_func_int16_t_s_s(0x6E27, ((safe_sub_func_int8_t_s_s(0, (0xD795 & g_97))) & l_74))))) & (((l_65 < (safe_lshift_func_int8_t_s_u(((safe_rshift_func_int8_t_s_s((0x28F8F04B && 0x66640DD1), 6)) ^ g_40.f6), l_74))) ^ (-8)) ^ l_102)) | g_89.f1), g_89.f4)) > 0U))
        { /* block id: 26 */
            uint32_t l_103 = 0x38BBD881;
            if (l_103)
                break;
            if (g_40.f3)
                goto lbl_104;
            return (*p_42);
        }
        else
        { /* block id: 29 */
            return (*l_88);
        }
    }
    return (*p_42);
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f5 g_40.f1
 * writes: g_40.f5
 */
static uint8_t  func_49(struct S0 * p_50, uint32_t  p_51)
{ /* block id: 21 */
    int32_t *l_84 = (void*)0;
    int32_t *l_85 = (void*)0;
    int32_t *l_86 = &g_40.f5;
    (*l_86) = (safe_add_func_int32_t_s_s(g_40.f5, p_51));
    return g_40.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_52(uint16_t  p_53, struct S0 * p_54)
{ /* block id: 18 */
    int32_t *l_81 = &g_2;
    int32_t **l_80 = &l_81;
    (*l_80) = (void*)0;
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_55(uint16_t  p_56, uint32_t  p_57, int16_t  p_58, uint32_t  p_59)
{ /* block id: 11 */
    int32_t *l_77 = (void*)0;
    for (p_56 = (-15); (p_56 > 19); p_56 = safe_add_func_uint16_t_u_u(p_56, 3))
    { /* block id: 14 */
        int32_t **l_78 = &l_77;
        (*l_78) = l_77;
    }
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_62(struct S0 * p_63, int32_t  p_64)
{ /* block id: 9 */
    return p_64;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_2;
    csmith_sink_ = g_40.f0;
    csmith_sink_ = g_40.f1;
    csmith_sink_ = g_40.f2;
    csmith_sink_ = g_40.f3;
    csmith_sink_ = g_40.f4;
    csmith_sink_ = g_40.f5;
    csmith_sink_ = g_40.f6;
    csmith_sink_ = g_89.f0;
    csmith_sink_ = g_89.f1;
    csmith_sink_ = g_89.f2;
    csmith_sink_ = g_89.f3;
    csmith_sink_ = g_89.f4;
    csmith_sink_ = g_89.f5;
    csmith_sink_ = g_89.f6;
    csmith_sink_ = g_97;
    csmith_sink_ = g_245;
    csmith_sink_ = g_343;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 62
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 15
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 1
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 12
XXX times a bitfields struct on LHS: 5
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 3

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 115
   depth: 2, occurrence: 17
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 10, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 27, occurrence: 2
   depth: 28, occurrence: 1

XXX total number of pointers: 71

XXX times a variable address is taken: 59
XXX times a pointer is dereferenced on RHS: 42
breakdown:
   depth: 1, occurrence: 28
   depth: 2, occurrence: 10
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 42
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 6
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 169

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 105
   level: 2, occurrence: 37
   level: 3, occurrence: 27
   level: 4, occurrence: 10
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 26
XXX number of pointers point to scalars: 21
XXX number of pointers point to structs: 24
XXX percent of pointers has null in alias set: 32.4
XXX average alias set size: 1.25

XXX times a non-volatile is read: 313
XXX times a non-volatile is write: 126
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 1

XXX stmts: 99
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 20
   depth: 2, occurrence: 18
   depth: 3, occurrence: 16
   depth: 4, occurrence: 12
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 20.6
XXX percentage an existing variable is used: 79.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

