/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --no-bitfields --no-checksum --no-comma-operators --no-compound-assignment --no-consts --no-divs --embedded-assigns --no-jumps --longlong --no-force-non-uniform-arrays --math64 --muls --packed-struct --paranoid --pointers --structs --inline-function --no-return-structs --arg-structs --dangling-global-pointers
 * Seed:      6055157603630660501
 */

#include "csmith.h"

volatile uint64_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
   int64_t  f1;
   uint8_t  f2;
   int64_t  f3;
   uint16_t  f4;
   uint16_t  f5;
   int16_t  f6;
   int8_t  f7;
   int32_t  f8;
   uint8_t  f9;
};

/* --- GLOBAL VARIABLES --- */
static struct S0 g_2 = {7UL,-6L,0xBAL,-4L,0x52D8L,0xB4C2L,0xAFC3L,0L,-1L,0x5AL};
static int32_t *g_42 = (void*)0;
static struct S0 g_43 = {0x65ADL,0xCAD8E65DD4D14B71LL,6UL,-6L,65527UL,1UL,0x4E2EL,-4L,0L,254UL};
static int32_t g_66 = 0xD3A1A91FL;
static int32_t *g_74 = (void*)0;
static struct S0 *g_93 = (void*)0;
static int64_t *g_95 = &g_2.f1;
static int32_t g_124 = (-1L);
static int32_t **g_128 = &g_42;
static int32_t ***g_127 = &g_128;
static uint8_t *g_143 = &g_43.f2;
static uint8_t *g_145 = &g_2.f2;
static int16_t g_169 = 0x2BDAL;


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
inline static int32_t * func_4(int32_t * p_5, uint32_t  p_6, struct S0 * p_7, int32_t  p_8);
inline static int32_t * func_9(uint32_t  p_10);
inline static uint16_t  func_13(struct S0 * p_14, uint8_t  p_15, int64_t * p_16);
static struct S0 * func_17(uint16_t  p_18, int64_t  p_19);
inline static int64_t * func_28(int64_t  p_29);
static uint8_t  func_36(int32_t * p_37, struct S0  p_38, uint16_t  p_39, int16_t  p_40, uint64_t  p_41);
static int32_t  func_44(struct S0 * p_45, struct S0  p_46);
static int32_t * func_50(int32_t  p_51, int64_t * p_52);
inline static int64_t * func_54(int64_t  p_55, uint32_t  p_56, int64_t ** p_57, int8_t  p_58, int64_t  p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_42 g_43 g_66 g_95 g_74 g_127 g_128 g_124 g_143 g_145 g_169
 * writes: g_2 g_43.f2 g_43.f7 g_66 g_42 g_74 g_93 g_43 g_124 g_143
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    struct S0 *l_3 = &g_2;
    int32_t l_11 = (-1L);
    int64_t *l_12 = &g_2.f1;
    uint8_t *l_25 = (void*)0;
    uint8_t *l_26 = (void*)0;
    uint8_t *l_27 = &g_2.f2;
    int8_t l_126 = 0x33L;
    int32_t *l_178 = &l_11;
    (*l_3) = g_2;
    l_178 = func_4(func_9((((*l_12) = l_11) || (((0x75D5L != func_13(func_17(g_2.f6, g_2.f4), ((*l_27) = g_2.f4), func_28((safe_mul_func_int8_t_s_s((safe_sub_func_uint8_t_u_u((safe_sub_func_uint8_t_u_u(func_36(g_42, g_43, g_2.f8, l_11, l_11), g_2.f3)), l_11)), l_126))))) ^ 18446744073709551614UL) > (*g_95)))), l_11, l_3, g_169);
    /* statement id: 89 */
    assert (g_42 == &g_66);
    assert (g_74 == 0 || g_74 == &g_66);
    assert (g_93 == 0 || g_93 == &g_2);
    assert (l_178 == &g_66);
    return g_43.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_128 g_2.f3 g_127 g_42 g_2.f0
 * writes: g_42 g_2.f3 g_66 g_2.f0
 */
inline static int32_t * func_4(int32_t * p_5, uint32_t  p_6, struct S0 * p_7, int32_t  p_8)
{ /* block id: 74 */
    int32_t *l_170 = &g_66;
    int32_t l_174 = 0xE08AAF6EL;
    int32_t *l_177 = &g_66;
    (*g_128) = l_170;
    /* statement id: 75 */
    assert (g_42 == &g_66);
    for (g_2.f3 = 18; (g_2.f3 >= (-7)); g_2.f3 = safe_sub_func_uint8_t_u_u(g_2.f3, 1))
    { /* block id: 78 */
        uint64_t l_173 = 1UL;
        if (p_6)
            break;
        l_174 = ((***g_127) = l_173);
        for (g_2.f0 = 0; (g_2.f0 <= 38); g_2.f0++)
        { /* block id: 84 */
            return (**g_127);
            /* statement id: 85 */
            //assert (func_4_rv == &g_66);
        }
    }
    return l_177;
    /* statement id: 88 */
    //assert (func_4_rv == &g_66);
}


/* ------------------------------------------ */
/* 
 * reads : g_124 g_2 g_127 g_128 g_42
 * writes: g_2 g_43
 */
inline static int32_t * func_9(uint32_t  p_10)
{ /* block id: 67 */
    int64_t **l_161 = &g_95;
    int32_t l_162 = 0x4F97B649L;
    struct S0 l_165 = {4UL,0L,0x83L,0xD7957E77FE76C900LL,0UL,1UL,0xD157L,5L,1L,0xE6L};
    struct S0 *l_166 = (void*)0;
    struct S0 *l_167 = &g_2;
    struct S0 *l_168 = &g_43;
    l_162 = ((void*)0 == l_161);
    l_162 = (safe_rshift_func_uint16_t_u_s((g_124 & 0L), 2));
    (*l_168) = ((*l_167) = (l_165 = g_2));
    return (**g_127);
    /* statement id: 73 */
    //assert (func_9_rv == 0 || func_9_rv == &g_66);
}


/* ------------------------------------------ */
/* 
 * reads : g_128 g_42 g_127 g_124 g_2.f3 g_143 g_145 g_2.f1 g_43.f4 g_66 g_74 g_2.f2 g_2.f8
 * writes: g_42 g_143 g_2.f2 g_66 g_43.f5 g_124
 */
inline static uint16_t  func_13(struct S0 * p_14, uint8_t  p_15, int64_t * p_16)
{ /* block id: 57 */
    int32_t l_137 = 0L;
    int32_t l_138 = 0x7D9AD9C2L;
    uint8_t **l_144 = &g_143;
    uint16_t *l_156 = &g_43.f5;
    int32_t *l_160 = &g_124;
    (**g_127) = (*g_128);
    (*g_74) = ((safe_rshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_u((safe_add_func_int16_t_s_s((l_138 = l_137), 0x0A7DL)), (safe_lshift_func_uint8_t_u_u((safe_mul_func_uint8_t_u_u(g_124, (g_2.f3 || ((((*l_144) = g_143) == g_145) || (0x07L ^ p_15))))), (((*g_145) = (!(safe_sub_func_int32_t_s_s(((g_2.f1 && 0xFF3DL) >= l_137), p_15)))) < l_137))))), g_43.f4)) <= (*g_42));
    (*l_160) = ((p_15 && ((*g_74) = (safe_mul_func_uint8_t_u_u(0x57L, (safe_lshift_func_int8_t_s_s(g_124, (((*g_145) & 255UL) != (+(safe_rshift_func_uint16_t_u_s((((*l_156) = l_137) != (safe_add_func_int8_t_s_s(g_2.f8, ((safe_unary_minus_func_uint8_t_u(p_15)) || l_138)))), 3)))))))))) ^ l_137);
    return (*l_160);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_17(uint16_t  p_18, int64_t  p_19)
{ /* block id: 3 */
    int64_t *l_21 = &g_2.f3;
    int64_t **l_20 = &l_21;
    int64_t ***l_22 = &l_20;
    int32_t *l_23 = (void*)0;
    int32_t **l_24 = &l_23;
    (*l_22) = l_20;
    (*l_24) = l_23;
    return &g_2;
    /* statement id: 6 */
    //assert (func_17_rv == &g_2);
}


/* ------------------------------------------ */
/* 
 * reads : g_127
 * writes:
 */
inline static int64_t * func_28(int64_t  p_29)
{ /* block id: 54 */
    int32_t ***l_129 = &g_128;
    int64_t *l_130 = &g_43.f1;
    l_129 = g_127;
    return l_130;
    /* statement id: 56 */
    //assert (func_28_rv == &g_43.f1);
}


/* ------------------------------------------ */
/* 
 * reads : g_43.f2 g_42 g_66 g_2.f9 g_2.f4 g_43.f6 g_43.f3 g_95 g_2.f3 g_43.f5 g_74 g_2.f8 g_43 g_2.f1 g_2.f6
 * writes: g_43.f2 g_43.f7 g_66 g_42 g_74 g_93 g_2.f8 g_43 g_124
 */
static uint8_t  func_36(int32_t * p_37, struct S0  p_38, uint16_t  p_39, int16_t  p_40, uint64_t  p_41)
{ /* block id: 8 */
    struct S0 l_47 = {0xAF0DL,1L,247UL,-7L,65535UL,6UL,1L,-6L,0x0B13309EL,254UL};
    int32_t *l_125 = &g_66;
    (*l_125) = func_44(&g_43, l_47);
    /* statement id: 52 */
    assert (g_42 == &g_66);
    assert (g_74 == &g_66);
    assert (g_93 == 0 || g_93 == &g_2);
    return (*l_125);
}


/* ------------------------------------------ */
/* 
 * reads : g_43.f2 g_42 g_66 g_2.f9 g_2.f4 g_43.f6 g_43.f3 g_95 g_2.f3 g_43.f5 g_74 g_2.f8 g_43 g_2.f1 g_2.f6
 * writes: g_43.f2 g_43.f7 g_66 g_42 g_74 g_93 g_2.f8 g_43 g_124
 */
static int32_t  func_44(struct S0 * p_45, struct S0  p_46)
{ /* block id: 9 */
    int64_t l_60 = 0x79405A9AD1DC2CBFLL;
    int32_t *l_65 = &g_66;
    int32_t **l_106 = &g_74;
    struct S0 l_109 = {7UL,0xA8D5DA263B4A8206LL,255UL,-9L,3UL,0xE97CL,1L,0xA5L,0x204FE417L,0xD4L};
    int32_t **l_120 = &g_42;
    uint16_t *l_123 = &l_109.f4;
    for (g_43.f2 = 11; (g_43.f2 < 12); g_43.f2 = safe_add_func_uint64_t_u_u(g_43.f2, 8))
    { /* block id: 12 */
        int32_t l_53 = 1L;
        int64_t *l_62 = &g_2.f1;
        int64_t **l_61 = &l_62;
        int8_t *l_64 = &g_43.f7;
        int32_t **l_73 = &g_42;
        uint8_t *l_100 = &g_43.f2;
        int64_t l_102 = 0L;
        g_74 = ((*l_73) = func_50(l_53, func_54(l_60, p_46.f8, l_61, ((*l_64) = (!0x207E8793EB104B5BLL)), (l_65 != (void*)0))));
        /* statement id: 21 */
        assert (g_42 == &g_66);
        assert (g_74 == &g_66);
        if ((((0xC1AABB77L >= (-1L)) <= (**l_73)) || g_2.f9))
        { /* block id: 22 */
            uint8_t *l_85 = (void*)0;
            uint8_t *l_86 = (void*)0;
            uint8_t *l_87 = (void*)0;
            struct S0 **l_90 = (void*)0;
            struct S0 *l_92 = &g_43;
            struct S0 **l_91 = &l_92;
            int32_t l_96 = (-1L);
            if ((((g_93 = ((*l_91) = func_17(g_2.f4, (safe_mul_func_uint8_t_u_u((**l_73), ((**l_73) ^ (safe_sub_func_uint64_t_u_u((safe_mul_func_int8_t_s_s(0xCAL, (((safe_sub_func_uint64_t_u_u((((safe_mul_func_int16_t_s_s(((p_46.f2 = 0xA4L) | p_46.f1), p_46.f5)) & 1L) <= (safe_lshift_func_uint8_t_u_s(((p_46.f9 != (**l_73)) | (*l_65)), g_43.f6))), p_46.f9)) & g_43.f3) < 0xEFL))), p_46.f0)))))))) != (void*)0) ^ 65535UL))
            { /* block id: 26 */
                int8_t l_94 = 9L;
                (*l_73) = func_50(l_94, g_95);
            }
            else
            { /* block id: 28 */
                struct S0 *l_97 = &g_43;
                int64_t **l_101 = &l_62;
                int32_t l_103 = 9L;
                int32_t *l_104 = &l_53;
                (*l_104) = (l_96 | ((((&p_46 != (p_45 = l_97)) ^ g_2.f3) && ((0x697EL >= ((safe_mod_func_uint64_t_u_u(((((((**l_73) = ((g_43.f5 && (l_100 == l_87)) >= ((void*)0 == l_101))) ^ g_43.f6) || 0x62BBL) != p_46.f2) > p_46.f5), 18446744073709551611UL)) == l_102)) || l_103)) < l_103));
            }
            /* facts after branching */
            assert (l_92 == &g_2);
            assert (g_93 == &g_2);
            (*l_65) = ((-1L) || (0x589394F4L & (*l_65)));
        }
        else
        { /* block id: 34 */
            (*g_74) = (!18446744073709551615UL);
            if ((**l_73))
                break;
        }
    }
    /* facts after for loop */
    assert (g_42 == &g_66 || g_42 == 0);
    assert (g_74 == &g_66 || g_74 == 0);
    assert (g_93 == 0 || g_93 == &g_2);
    (*l_106) = func_50((*l_65), g_95);
    /* statement id: 39 */
    assert (g_74 == &g_66);
    for (g_2.f8 = (-24); (g_2.f8 != 28); ++g_2.f8)
    { /* block id: 42 */
        (*p_45) = g_43;
        l_109 = l_109;
        (*l_106) = (*l_106);
    }
    g_124 = (safe_mul_func_int8_t_s_s(p_46.f1, ((safe_sub_func_int32_t_s_s(((*g_74) = (*g_74)), (((safe_mul_func_uint16_t_u_u(g_43.f4, (((g_43.f3 | ((((safe_lshift_func_uint16_t_u_u(((*l_123) = (safe_sub_func_int16_t_s_s(((*l_106) != ((*l_120) = func_50(p_46.f9, &l_60))), ((*g_95) | 0UL)))), 9)) & g_43.f0) | 1L) | g_43.f8)) || 7L) > g_43.f8))) <= p_46.f4) == 0x642F9FB1L))) >= g_2.f6)));
    /* statement id: 50 */
    assert (g_42 == &g_66);
    return (**l_106);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_50(int32_t  p_51, int64_t * p_52)
{ /* block id: 17 */
    struct S0 *l_71 = &g_43;
    struct S0 **l_70 = &l_71;
    int32_t *l_72 = &g_66;
    l_70 = l_70;
    return l_72;
    /* statement id: 19 */
    //assert (func_50_rv == &g_66);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_66
 */
inline static int64_t * func_54(int64_t  p_55, uint32_t  p_56, int64_t ** p_57, int8_t  p_58, int64_t  p_59)
{ /* block id: 14 */
    int32_t *l_68 = &g_66;
    int64_t *l_69 = &g_43.f3;
    (*l_68) = (~0x9C29L);
    return l_69;
    /* statement id: 16 */
    //assert (func_54_rv == &g_43.f3);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_2.f0;
    csmith_sink_ = g_2.f1;
    csmith_sink_ = g_2.f2;
    csmith_sink_ = g_2.f3;
    csmith_sink_ = g_2.f4;
    csmith_sink_ = g_2.f5;
    csmith_sink_ = g_2.f6;
    csmith_sink_ = g_2.f7;
    csmith_sink_ = g_2.f8;
    csmith_sink_ = g_2.f9;
    csmith_sink_ = g_43.f0;
    csmith_sink_ = g_43.f1;
    csmith_sink_ = g_43.f2;
    csmith_sink_ = g_43.f3;
    csmith_sink_ = g_43.f4;
    csmith_sink_ = g_43.f5;
    csmith_sink_ = g_43.f6;
    csmith_sink_ = g_43.f7;
    csmith_sink_ = g_43.f8;
    csmith_sink_ = g_43.f9;
    csmith_sink_ = g_66;
    csmith_sink_ = g_124;
    csmith_sink_ = g_169;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 38
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 6
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 2
   depth: 26, occurrence: 1

XXX total number of pointers: 68

XXX times a variable address is taken: 47
XXX times a pointer is dereferenced on RHS: 21
breakdown:
   depth: 1, occurrence: 13
   depth: 2, occurrence: 8
XXX times a pointer is dereferenced on LHS: 32
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 2
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 3
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 89

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 104
   level: 2, occurrence: 37
   level: 3, occurrence: 4
XXX number of pointers point to pointers: 17
XXX number of pointers point to scalars: 39
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 20.6
XXX average alias set size: 1.12

XXX times a non-volatile is read: 149
XXX times a non-volatile is write: 86
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 45
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 8
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2

XXX percentage a fresh-made variable is used: 29.1
XXX percentage an existing variable is used: 70.9
********************* end of statistics **********************/

