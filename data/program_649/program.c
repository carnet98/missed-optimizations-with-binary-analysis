/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --jumps --no-longlong --force-non-uniform-arrays --math64 --no-muls --no-packed-struct --no-paranoid --pointers --structs --inline-function --no-return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      3021882601537001952
 */


#define NO_LONGLONG

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t *g_7 = (void*)0;
static uint8_t g_8 = 3U;
static const int32_t g_61 = 1;
static const int32_t g_63 = (-9);
static const int32_t *g_62 = &g_63;
static uint16_t g_78 = 1U;
static uint32_t g_79 = 4294967295U;
static int32_t g_84 = (-1);
static uint8_t g_90 = 0x55;
static int32_t **g_92 = &g_7;
static int32_t ***g_91 = &g_92;
static int32_t *g_117 = &g_84;


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_1(void);
inline static int32_t * func_2(int32_t * p_3, int32_t  p_4, int32_t * p_5, int32_t  p_6);
static int32_t * func_9(int32_t * p_10, int32_t * p_11, int16_t  p_12, uint8_t  p_13, int32_t * p_14);
static int32_t * func_15(int32_t * p_16, int32_t  p_17);
static int8_t  func_19(const uint32_t  p_20, int8_t  p_21);
inline static int8_t  func_23(int32_t  p_24, int32_t * p_25);
inline static int32_t * func_26(int32_t * p_27, int32_t * p_28, int32_t * p_29, int8_t  p_30);
static int32_t * func_31(int32_t * p_32, int32_t  p_33, const int32_t * p_34, int32_t * p_35);
inline static int32_t * func_36(int32_t * p_37, int32_t * p_38, int16_t  p_39);
static uint16_t  func_42(uint32_t  p_43);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_7 g_8 g_63 g_78 g_84 g_90 g_91 g_62 g_92 g_61 g_79 g_117
 * writes: g_62 g_79 g_84 g_117 g_92 g_90 g_7
 */
inline static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_18 = (void*)0;
    int32_t l_22 = 0x90611BC3;
    int32_t **l_198 = &g_7;
    (*l_198) = func_2(g_7, g_8, func_9(func_15(l_18, ((func_19(g_8, ((l_22 & func_23(g_8, func_26(func_31(func_36(&l_22, &l_22, (safe_rshift_func_uint16_t_u_s(func_42(g_8), 4))), g_8, g_7, g_7), g_7, &l_22, g_63))) < 0xAE35)) > 5U) == g_78)), &l_22, g_8, g_90, (*g_92)), g_78);
    return (**l_198);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_2(int32_t * p_3, int32_t  p_4, int32_t * p_5, int32_t  p_6)
{ /* block id: 79 */
    int32_t *l_197 = &g_84;
    return l_197;
}


/* ------------------------------------------ */
/* 
 * reads : g_79 g_91 g_92 g_7 g_63 g_117 g_8 g_90 g_78 g_61 g_84 g_62
 * writes: g_117 g_84 g_92 g_90 g_62
 */
static int32_t * func_9(int32_t * p_10, int32_t * p_11, int16_t  p_12, uint8_t  p_13, int32_t * p_14)
{ /* block id: 34 */
    const int32_t **l_121 = (void*)0;
    int16_t l_122 = 1;
    int8_t l_148 = 0xCE;
    int32_t *l_190 = &g_84;
    int16_t l_193 = (-2);
    int32_t **l_195 = (void*)0;
    int32_t **l_196 = &l_190;
    if ((safe_add_func_uint16_t_u_u(g_79, (((p_11 == (**g_91)) > (0x4F69 ^ (g_63 <= ((void*)0 == (*g_92))))) == ((~((4 ^ ((l_121 != (void*)0) & l_122)) < 1)) >= 65527U)))))
    { /* block id: 35 */
        int32_t **l_123 = &g_117;
        uint8_t l_147 = 0U;
        (*l_123) = p_10;
        (*l_123) = p_11;
        (**l_123) = (safe_add_func_uint8_t_u_u((safe_sub_func_uint32_t_u_u((0xAC331A2D < ((safe_lshift_func_int16_t_s_u(((safe_add_func_uint8_t_u_u(((*g_117) != ((safe_add_func_int16_t_s_s((((safe_add_func_int16_t_s_s((!((safe_rshift_func_uint16_t_u_s(0U, 5)) ^ ((l_123 != (void*)0) && ((safe_add_func_int32_t_s_s(((((((safe_add_func_int8_t_s_s(((safe_lshift_func_int16_t_s_s(((safe_lshift_func_int16_t_s_u((((((&p_11 != l_123) != 0x23) > (**l_123)) > p_12) > (**l_123)), 7)) || l_147), 4)) | (**l_123)), g_8)) < p_12) | (*p_11)) == g_90) | g_79) == g_79), 0xBFB87D1E)) <= 0xD58A)))), p_13)) == (**l_123)) ^ (**l_123)), p_13)) < 6)), l_148)) || g_78), 10)) >= g_61)), g_84)), 0x53));
    }
    else
    { /* block id: 39 */
        int8_t l_162 = 0xA6;
        const int32_t * const *l_163 = (void*)0;
        (*g_117) = (0U != (&l_121 == &l_121));
        for (l_148 = 0; (l_148 == (-25)); --l_148)
        { /* block id: 43 */
            for (l_122 = 3; (l_122 > 27); l_122 = safe_add_func_uint8_t_u_u(l_122, 8))
            { /* block id: 46 */
                (*g_91) = &p_14;
                (**g_91) = (void*)0;
            }
            (*g_117) = (((safe_sub_func_uint8_t_u_u(((*g_62) <= ((safe_lshift_func_uint8_t_u_s((safe_unary_minus_func_int8_t_s(((safe_add_func_uint8_t_u_u(((safe_rshift_func_uint8_t_u_s((l_162 & (((l_163 != (void*)0) < 0x3421) && g_61)), ((*g_117) == ((((safe_lshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u((safe_sub_func_int16_t_s_s((-1), (safe_mod_func_int32_t_s_s((safe_sub_func_int32_t_s_s((*p_11), p_13)), p_12)))), p_12)), 11)) == 0xCA) <= 3) & (*g_62))))) <= (*p_10)), 0xDC)) || (-5)))), g_84)) & p_12)), p_13)) || g_63) & p_12);
        }
    }
    (*p_10) = (4U | ((safe_add_func_uint8_t_u_u(0xD6, (safe_lshift_func_int8_t_s_s((safe_mod_func_int8_t_s_s((0x01 > (p_13 & ((g_84 == (g_63 == ((void*)0 != (*g_91)))) <= ((&l_121 != &l_121) == p_13)))), g_63)), p_12)))) < p_12));
    for (g_90 = 18; (g_90 >= 47); ++g_90)
    { /* block id: 56 */
        int32_t *l_191 = &g_84;
        const int32_t *l_192 = (void*)0;
        int32_t **l_194 = &l_190;
        for (l_122 = 0; (l_122 >= 20); l_122 = safe_add_func_uint8_t_u_u(l_122, 8))
        { /* block id: 59 */
            int32_t **l_189 = &g_117;
        }
        l_192 = l_192;
        (*l_194) = func_31(l_190, g_78, p_14, p_10);
    }
    (*l_196) = (*g_92);
    return p_11;
}


/* ------------------------------------------ */
/* 
 * reads : g_117
 * writes:
 */
static int32_t * func_15(int32_t * p_16, int32_t  p_17)
{ /* block id: 31 */
    int32_t *l_116 = (void*)0;
    int32_t **l_115 = &l_116;
    (*l_115) = p_16;
    return g_117;
}


/* ------------------------------------------ */
/* 
 * reads : g_91 g_92 g_7 g_63
 * writes:
 */
static int8_t  func_19(const uint32_t  p_20, int8_t  p_21)
{ /* block id: 28 */
    int32_t *l_114 = (void*)0;
    int32_t **l_113 = &l_114;
    (*l_113) = (**g_91);
    return g_63;
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_84 g_90 g_91 g_8 g_78 g_62 g_92 g_63 g_61 g_79
 * writes: g_62 g_79 g_84
 */
inline static int8_t  func_23(int32_t  p_24, int32_t * p_25)
{ /* block id: 15 */
    int32_t *l_83 = &g_84;
    const int32_t *l_93 = (void*)0;
    int32_t **l_94 = &l_83;
    uint16_t l_101 = 0xD248;
    int32_t l_102 = 5;
    int32_t l_112 = 0x4D26467E;
    (*l_94) = func_26(g_7, func_31(l_83, (safe_sub_func_uint8_t_u_u((((((*l_83) | 8) != (+(safe_add_func_int8_t_s_s((g_90 || (*l_83)), ((void*)0 != g_91))))) <= p_24) > (*p_25)), 251U)), l_93, l_83), p_25, g_84);
    (*l_94) = func_31(p_25, p_24, p_25, p_25);
    p_25 = func_31(p_25, p_24, p_25, (*l_94));
    if ((((((void*)0 != &l_83) < g_78) != p_24) | l_101))
    { /* block id: 19 */
        int32_t *l_103 = &g_84;
        p_25 = p_25;
        p_25 = p_25;
        (*l_103) = (*g_62);
    }
    else
    { /* block id: 23 */
        int32_t l_108 = 0;
        int32_t *l_111 = &g_84;
        p_25 = (**g_91);
        (*l_111) = ((g_90 || p_24) != ((safe_sub_func_uint16_t_u_u(g_63, g_61)) <= (+(((((+((l_108 > ((g_63 == ((g_63 && (safe_add_func_uint8_t_u_u((0U ^ p_24), p_24))) == g_79)) > 8)) || 0xF9311F6B)) ^ g_90) >= g_78) == 0x2E2238E9) | (*g_62)))));
    }
    return l_112;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_78 l_22
 * writes: g_79
 */
inline static int32_t * func_26(int32_t * p_27, int32_t * p_28, int32_t * p_29, int8_t  p_30)
{ /* block id: 10 */
    uint16_t l_64 = 0x0EAA;
    const int32_t **l_69 = &g_62;
    int32_t l_81 = 0xF9D3F58F;
    g_79 = ((((l_64 >= ((safe_sub_func_uint32_t_u_u(1U, (safe_sub_func_int32_t_s_s(l_64, (&g_62 == l_69))))) >= (p_30 ^ (((*p_29) < (safe_sub_func_uint8_t_u_u(((safe_rshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_s(p_30, 15)), 11)) != (safe_sub_func_uint16_t_u_u(g_8, p_30))), g_78))) && l_64)))) & 0x94) <= l_64) < g_78);
    if (g_78)
        goto lbl_82;
lbl_82:
    l_81 = (+p_30);
    return p_29;
}


/* ------------------------------------------ */
/* 
 * reads : g_7
 * writes: g_62
 */
static int32_t * func_31(int32_t * p_32, int32_t  p_33, const int32_t * p_34, int32_t * p_35)
{ /* block id: 6 */
    const int32_t *l_60 = &g_61;
    const int32_t **l_59 = &l_60;
    const int32_t ***l_58 = &l_59;
    (*l_58) = &p_34;
    g_62 = (**l_58);
    return g_7;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_7
 * writes:
 */
inline static int32_t * func_36(int32_t * p_37, int32_t * p_38, int16_t  p_39)
{ /* block id: 3 */
    int32_t l_51 = 0;
    int32_t l_56 = 0xC84060A3;
    uint32_t l_57 = 0x88DD0BB2;
    l_57 = ((g_8 == ((4294967295U != ((((((safe_rshift_func_int16_t_s_s(((0 >= ((safe_add_func_uint8_t_u_u((safe_lshift_func_int16_t_s_u((l_51 ^ (l_51 | (safe_mod_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(((g_7 == p_37) || (((g_8 <= g_8) > g_8) == (*p_37))), (-8))), 0x5188)))), l_51)), g_8)) == l_51)) < g_8), 5)) > p_39) <= p_39) & 1U) < l_56) != g_8)) | p_39)) >= (*p_37));
    return g_7;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_42(uint32_t  p_43)
{ /* block id: 1 */
    int32_t l_44 = 0x706B3799;
    return l_44;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    g_62 = 0;
    g_92 = 0;
    g_117 = 0;
    csmith_sink_ = g_8;
    csmith_sink_ = g_61;
    csmith_sink_ = g_63;
    csmith_sink_ = g_78;
    csmith_sink_ = g_79;
    csmith_sink_ = g_84;
    csmith_sink_ = g_90;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 35
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
   depth: 5, occurrence: 4
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 3
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 33, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 49

XXX times a variable address is taken: 35
XXX times a pointer is dereferenced on RHS: 51
breakdown:
   depth: 1, occurrence: 36
   depth: 2, occurrence: 15
XXX times a pointer is dereferenced on LHS: 22
breakdown:
   depth: 1, occurrence: 20
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 179

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 78
   level: 2, occurrence: 53
   level: 3, occurrence: 3
XXX number of pointers point to pointers: 16
XXX number of pointers point to scalars: 33
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 46.9
XXX average alias set size: 1.35

XXX times a non-volatile is read: 291
XXX times a non-volatile is write: 62
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 44
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 13
   depth: 2, occurrence: 2
   depth: 3, occurrence: 2

XXX percentage a fresh-made variable is used: 11.6
XXX percentage an existing variable is used: 88.4
********************* end of statistics **********************/

