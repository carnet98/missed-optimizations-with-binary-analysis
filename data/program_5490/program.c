/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-jumps --no-longlong --force-non-uniform-arrays --no-math64 --no-muls --no-packed-struct --paranoid --pointers --structs --inline-function --return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      1500628264
 */


#define NO_LONGLONG

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 2;
   signed f1 : 15;
   unsigned f2 : 21;
};

struct S1 {
   unsigned f0 : 17;
   unsigned f1 : 15;
   const unsigned f2 : 24;
   signed f3 : 15;
   int16_t  f4;
   unsigned f5 : 23;
   unsigned f6 : 10;
   signed f7 : 31;
};

/* --- GLOBAL VARIABLES --- */
static uint8_t g_16 = 0x49;
static int32_t g_22 = 0x37FC0336;
static int32_t *g_34 = &g_22;
static int32_t **g_33 = &g_34;
static struct S1 *g_69 = (void*)0;
static struct S1 g_116 = {24,143,2696,-160,0xA862,2612,10,8271};
static int32_t *g_138 = &g_22;
static struct S0 g_145 = {0,-141,288};
static int32_t ***g_168 = &g_33;
static int32_t ****g_167 = &g_168;
static int32_t *****g_166 = &g_167;
static struct S1 g_333 = {226,119,2357,109,0x5B23,1259,5,-31543};
static const int32_t *g_421 = &g_22;
static const int32_t **g_420 = &g_421;
static struct S0 *g_472 = &g_145;
static struct S0 ** const g_471 = &g_472;


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
static uint8_t  func_10(int8_t  p_11, int16_t  p_12);
static const int32_t ** func_23(int32_t  p_24, int32_t * p_25, int8_t  p_26);
inline static int32_t * func_27(int32_t  p_28, uint16_t  p_29, uint32_t  p_30, int32_t * p_31, uint32_t  p_32);
inline static uint32_t  func_37(uint32_t  p_38, int32_t * p_39);
inline static int32_t *** func_43(int32_t *** p_44, int32_t  p_45);
inline static int32_t  func_47(uint16_t  p_48);
inline static int32_t * func_54(int32_t  p_55, int32_t ** p_56, int32_t * p_57);
static int32_t ** func_58(uint8_t  p_59, int32_t  p_60);
static int32_t * func_63(int32_t * p_64, uint32_t  p_65, int32_t  p_66);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_16 g_33 g_22 g_34 g_69 g_116.f1 g_116.f5 g_145 g_168 g_116.f3 g_116.f2 g_138 g_116.f0 g_116.f6 g_116.f7 g_167 g_116.f4 g_333.f6 g_333.f4 g_333.f2 g_333.f1 g_333.f7 g_420 g_333.f0 g_471
 * writes: g_22 g_69 g_116.f4 g_138 g_145 g_166 g_34 g_16 g_168 g_421 g_420
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_13 = 65535U;
    int16_t l_14 = 0xE763;
    int8_t l_20 = 0x39;
    int32_t *l_21 = &g_22;
    const int32_t ***l_475 = &g_420;
    struct S1 **l_476 = &g_69;
    (*l_21) = (safe_sub_func_uint16_t_u_u(((((0 && ((safe_add_func_int16_t_s_s((safe_mod_func_int8_t_s_s(0xF9, (safe_add_func_uint16_t_u_u((func_10(l_13, l_14) <= ((func_10((g_16 >= (safe_sub_func_uint32_t_u_u((safe_unary_minus_func_uint8_t_u((func_10(l_14, l_13) || 0x89))), l_14))), l_20) != g_16) || 0xE809)), (-1))))), g_16)) && 0x0737)) & (-8)) && l_14) <= 0), l_20));
    (*l_475) = func_23(g_16, func_27((g_33 == &l_21), (*l_21), (*l_21), (*g_33), g_22), (g_116.f1 & (-9)));
    /* statement id: 189 */
    assert (g_34 == &g_22 || g_34 == 0);
    assert (g_69 == &g_116 || g_69 == 0);
    //assert (g_166 == dangling || g_166 == &g_167);
    (*l_476) = &g_333;
    /* statement id: 190 */
    assert (g_69 == &g_333);
    return g_145.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_10(int8_t  p_11, int16_t  p_12)
{ /* block id: 1 */
    uint16_t l_15 = 65529U;
    return l_15;
}


/* ------------------------------------------ */
/* 
 * reads : g_145.f2 g_116.f2 g_116.f6 g_22 g_138 g_145.f1 g_116.f7 g_116.f3 g_116.f1 g_116.f0 g_168 g_33 g_34 g_167 g_145.f0 g_116.f5 g_116.f4 g_16 g_333.f6 g_333.f4 g_333.f2 g_333.f1 g_333.f7 g_69 g_420 g_333.f0 g_471
 * writes: g_22 g_145 g_34 g_69 g_16 g_168 g_421
 */
static const int32_t ** func_23(int32_t  p_24, int32_t * p_25, int8_t  p_26)
{ /* block id: 99 */
    int32_t l_223 = 0x592CA975;
    int32_t *****l_232 = &g_167;
    uint16_t l_267 = 0xFBE2;
    int32_t ****l_286 = &g_168;
    struct S1 *l_332 = &g_333;
    int32_t l_356 = 2;
    struct S0 l_413 = {1,-133,579};
    const int32_t *l_417 = &l_356;
    const int32_t **l_416 = &l_417;
    int8_t l_425 = 2;
    int32_t l_457 = (-1);
    struct S0 **l_474 = (void*)0;
    struct S0 ***l_473 = &l_474;
    if ((0xFD48 ^ (safe_rshift_func_uint16_t_u_s(((((((safe_rshift_func_uint16_t_u_s((l_223 < g_145.f2), 9)) || (safe_add_func_uint16_t_u_u(g_116.f2, l_223))) & (safe_add_func_int32_t_s_s((safe_mod_func_int16_t_s_s(l_223, l_223)), (safe_rshift_func_uint8_t_u_u((l_232 == l_232), p_24))))) ^ 0xB1) >= 0x939D) && p_24), 7))))
    { /* block id: 100 */
        struct S1 ** const l_236 = &g_69;
        int32_t l_237 = 0xF4D21E74;
        struct S1 **l_238 = (void*)0;
        struct S0 *l_243 = &g_145;
        (*g_138) = (((safe_sub_func_uint16_t_u_u(p_24, (((g_116.f6 & (+(((((l_236 == (void*)0) & (g_22 >= (0xFEA248F7 >= (l_237 >= (l_236 != l_238))))) != l_223) ^ g_116.f2) > (*g_138)))) && l_237) ^ (-3)))) < l_237) == 0xA5);
        l_237 = (*g_138);
        (*g_138) = (+(((((l_237 | g_145.f1) & g_116.f7) & (~g_116.f3)) || ((((safe_add_func_int16_t_s_s(g_145.f2, p_24)) <= 0x29863923) && g_145.f2) ^ (l_243 != &g_145))) >= g_116.f1));
    }
    else
    { /* block id: 104 */
        int32_t l_261 = 0xE5DCDF2A;
        struct S0 *l_263 = &g_145;
        struct S0 **l_262 = &l_263;
        int32_t *l_264 = &g_22;
        struct S1 **l_285 = &g_69;
        int8_t l_357 = 0x58;
        uint32_t l_358 = 0xBF9705C1;
        uint16_t l_377 = 0x55A2;
        int32_t ***l_414 = &g_33;
        const int32_t **l_419 = &l_417;
        int8_t l_447 = 1;
        if ((65535U && g_116.f0))
        { /* block id: 105 */
            const uint16_t l_244 = 1U;
            uint16_t l_247 = 0x77C6;
            int32_t l_289 = 0x2EB0A1AF;
            const struct S1 *l_308 = &g_116;
            const struct S1 **l_307 = &l_308;
            if (l_244)
            { /* block id: 106 */
                struct S0 *l_276 = &g_145;
                int32_t l_278 = 0xF25B8A72;
                int32_t ** const *l_282 = (void*)0;
                struct S1 *l_291 = &g_116;
                for (p_24 = (-5); (p_24 > 19); p_24 = safe_add_func_int32_t_s_s(p_24, 7))
                { /* block id: 109 */
                    const struct S0 l_250 = {0,179,20};
                    const struct S0 **l_252 = (void*)0;
                    const struct S0 *l_254 = &l_250;
                    const struct S0 **l_253 = &l_254;
                    (*g_138) = l_247;
                    for (l_223 = 0; (l_223 == (-27)); l_223 = safe_sub_func_uint8_t_u_u(l_223, 5))
                    { /* block id: 113 */
                        struct S0 *l_251 = &g_145;
                        (*l_251) = l_250;
                        (*g_138) = ((**g_168) == p_25);
                    }
                    (*l_253) = &l_250;
                    (****l_232) = l_264;
                    /* statement id: 118 */
                    assert (g_34 == &g_22);
                }
                if ((safe_mod_func_uint8_t_u_u(((((l_267 && (safe_rshift_func_uint16_t_u_u((0x79 >= (&g_116 == (void*)0)), 11))) & p_26) != ((safe_add_func_int8_t_s_s((safe_rshift_func_uint8_t_u_s((safe_add_func_int16_t_s_s((&g_145 != l_276), ((-1) | (~(-4))))), g_116.f6)), (*l_264))) > g_116.f3)) <= l_278), p_26)))
                { /* block id: 120 */
                    int32_t l_287 = 3;
                    int8_t l_288 = 0xD7;
                    const struct S0 l_290 = {0,87,1205};
                    l_289 = (((+0x78BE) <= 1U) != (safe_mod_func_uint16_t_u_u((((g_116.f2 > 1) ^ (((void*)0 != l_282) ^ (((((safe_sub_func_int32_t_s_s(((void*)0 != l_285), (((((*l_232) != l_286) <= g_116.f6) ^ g_145.f0) & 0x3B5F))) < p_26) & (*l_264)) ^ p_26) | l_287))) != g_116.f5), l_288)));
                    (*l_264) = (-1);
                    (*l_276) = l_290;
                    (*l_285) = l_291;
                    /* statement id: 124 */
                    assert (g_69 == &g_116);
                }
                else
                { /* block id: 125 */
                    uint8_t l_313 = 0x9F;
                    if ((p_24 <= ((l_276 == (void*)0) < (0xEB < g_116.f1))))
                    { /* block id: 126 */
                        (*l_264) = (safe_lshift_func_uint16_t_u_u(((((((safe_sub_func_int8_t_s_s(((0xA528 ^ ((-1) == ((safe_sub_func_int8_t_s_s(6, 0U)) > (~(safe_lshift_func_uint16_t_u_s((safe_mod_func_int32_t_s_s(((((safe_sub_func_int32_t_s_s(0, ((safe_lshift_func_int8_t_s_s(((void*)0 != l_307), (((safe_mod_func_int32_t_s_s((l_313 == 9), l_247)) < 0x56) > 0U))) || l_313))) >= 9) < g_145.f1) ^ g_116.f4), 0xA534EDE8)), g_16)))))) ^ 249U), 0x0C)) & l_244) <= 0x41F1) != l_247) | g_22) < 1U), p_24));
                    }
                    else
                    { /* block id: 128 */
                        int8_t l_328 = 0x5B;
                        uint32_t l_329 = 4294967291U;
                        uint32_t l_330 = 0x1CA42827;
                        int32_t l_331 = 3;
                        l_331 = (((p_24 | p_26) | ((safe_rshift_func_int8_t_s_u(((p_26 >= l_313) || ((((safe_rshift_func_uint16_t_u_s(((l_244 ^ ((((safe_sub_func_uint16_t_u_u((!(*l_264)), ((safe_lshift_func_int8_t_s_s((safe_add_func_int32_t_s_s(((safe_add_func_uint8_t_u_u(((***g_167) == (****l_232)), (+p_26))) & 0xFA103EE5), l_328)), 2)) | 0x955F64ED))) != p_26) ^ p_26) >= 0U)) || p_24), g_145.f1)) && g_116.f2) > p_26) < l_329)), l_247)) >= l_330)) ^ 0x6D);
                        (***l_286) = (void*)0;
                        /* statement id: 130 */
                        assert (g_34 == 0);
                    }
                    l_332 = (void*)0;
                    /* statement id: 132 */
                    assert (l_332 == 0);
                }
                /* facts after branching */
                assert (l_332 == 0 || l_332 == &g_333);
                l_358 = (((1U <= (0xA2 < (safe_mod_func_int8_t_s_s(((((((0xDF || (safe_rshift_func_uint8_t_u_u((safe_sub_func_int16_t_s_s(((safe_mod_func_int16_t_s_s(p_24, ((((safe_lshift_func_uint8_t_u_s(((safe_lshift_func_uint16_t_u_u((((safe_sub_func_uint16_t_u_u((((((*g_33) == &l_289) ^ ((((safe_add_func_uint32_t_u_u(p_26, ((((safe_sub_func_int16_t_s_s(((safe_add_func_uint8_t_u_u(4U, (safe_add_func_uint16_t_u_u(0U, 0U)))) & 7U), l_278)) | (*l_264)) > 1) & (*l_264)))) == l_356) >= 0x3A66112E) != 0xB5)) != p_26) == g_333.f6), g_145.f1)) & 1) != p_24), 6)) < 0x88), 6)) <= g_333.f4) || l_289) ^ 0x8C251C10))) & 0x45), l_357)), 0))) | 0x1904) || 0x08B0A408) >= 0) != g_333.f2) && 0xA47ABD0C), g_333.f1)))) < l_247) == 0xB5EF);
            }
            else
            { /* block id: 135 */
                struct S0 l_359 = {1,89,601};
                int32_t l_401 = 7;
                (**l_262) = l_359;
                for (g_16 = 0; (g_16 == 4); g_16 = safe_add_func_uint8_t_u_u(g_16, 1))
                { /* block id: 139 */
                    int32_t l_378 = 0xA8EAB974;
                    l_359.f1 = ((p_26 | (safe_sub_func_int32_t_s_s(l_359.f2, (((safe_rshift_func_int16_t_s_u((p_26 && ((((!65532U) >= p_26) < (((((((safe_add_func_int16_t_s_s(0xE311, ((safe_lshift_func_uint16_t_u_s((((safe_add_func_int32_t_s_s(0xFEA37F8D, 0xC6D1A99E)) | (((((safe_rshift_func_uint8_t_u_s((p_26 || 248U), l_377)) && l_289) & p_26) <= g_333.f7) & 0x24)) || p_26), 12)) != (-4)))) | 0xFBB2) > p_26) && g_22) & (*l_264)) <= 0x55DB8D7A) ^ 0x9F)) == l_378)), 1)) | 0x9FE1FDFE) < 0U)))) > 0xF2);
                }
                (***g_167) = func_63((*g_33), (*l_264), p_26);
                /* statement id: 142 */
                assert (g_34 == &g_22);
                (**g_33) = p_26;
            }
            /* facts after branching */
            assert (l_332 == 0 || l_332 == &g_333);
            (*l_264) = (safe_mod_func_uint8_t_u_u(0U, (safe_sub_func_int16_t_s_s((safe_unary_minus_func_uint16_t_u((&p_25 == &p_25))), (safe_sub_func_uint8_t_u_u(((safe_sub_func_int16_t_s_s(l_247, ((1U & ((safe_add_func_int16_t_s_s((&g_69 != l_285), (65535U == (-8)))) <= (*l_264))) != l_244))) && 0U), g_116.f2))))));
            (*l_263) = l_413;
            (**l_232) = l_414;
        }
        else
        { /* block id: 148 */
            struct S0 l_415 = {1,-26,875};
            const int32_t **l_418 = &l_417;
            (***l_286) = (**l_414);
            (*l_263) = l_415;
            return g_420;
            /* statement id: 151 */
            //assert (func_23_rv == &g_421);
        }
        /* facts after branching */
        assert (l_332 == 0 || l_332 == &g_333);
        if ((((**g_168) == (void*)0) > g_333.f4))
        { /* block id: 153 */
            int32_t *l_424 = &g_22;
            for (l_377 = 0; (l_377 > 9); l_377 = safe_add_func_int16_t_s_s(l_377, 4))
            { /* block id: 156 */
                (**g_168) = (void*)0;
                /* statement id: 157 */
                assert (g_34 == 0);
                (*g_420) = func_63(l_424, p_26, l_425);
            }
            (*l_419) = func_63((*g_33), p_26, (safe_lshift_func_int8_t_s_u((p_24 >= p_24), 7)));
            /* statement id: 160 */
            assert (l_417 == &g_22);
            if ((*g_138))
            { /* block id: 161 */
                (*g_138) = ((*g_167) == (void*)0);
                (*l_424) = 7;
            }
            else
            { /* block id: 164 */
                return &g_421;
                /* statement id: 165 */
                //assert (func_23_rv == &g_421);
            }
            (*g_33) = (**g_168);
        }
        else
        { /* block id: 168 */
            uint32_t l_446 = 1U;
            const int32_t **l_459 = &l_417;
            if ((((((safe_rshift_func_uint8_t_u_s((g_116.f0 == ((safe_lshift_func_uint16_t_u_s(g_145.f2, (((safe_rshift_func_uint16_t_u_s(g_333.f7, 15)) | (safe_lshift_func_uint16_t_u_s((0x56DA063D | (safe_lshift_func_int8_t_s_s((0x1C81 >= (((safe_rshift_func_uint8_t_u_u(((safe_sub_func_int32_t_s_s((safe_rshift_func_uint8_t_u_s(3U, 4)), (safe_mod_func_uint32_t_u_u((((((0x35 || (0x0555 <= (0xED ^ p_24))) & l_446) ^ g_145.f1) <= l_446) == 1), l_446)))) | l_447), p_24)) == (**l_416)) | p_26)), 2))), 1))) & l_446))) ^ p_24)), 1)) | p_24) == p_26) == 0x1F02) & g_333.f0))
            { /* block id: 169 */
                int8_t l_454 = 0xD0;
                (*l_264) = (p_24 & l_446);
                (*g_138) = (0x8646 & (safe_mod_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u((((0xB3921B82 != (safe_lshift_func_int8_t_s_s(0x43, 6))) < ((void*)0 != (*l_262))) > l_454), 3)), (-7))));
                for (g_22 = 4; (g_22 < (-29)); g_22 = safe_sub_func_uint32_t_u_u(g_22, 2))
                { /* block id: 174 */
                    uint32_t l_458 = 0xB0854F1E;
                    if (l_457)
                        break;
                    p_25 = func_63((**g_168), (&g_69 != (void*)0), (**l_419));
                    /* statement id: 176 */
                    assert (p_25 == &g_22);
                    (***l_286) = func_63(p_25, g_116.f0, l_458);
                    /* statement id: 177 */
                    assert (g_34 == &g_22);
                }
            }
            else
            { /* block id: 179 */
                return &g_421;
                /* statement id: 180 */
                //assert (func_23_rv == &g_421);
            }
            (*l_419) = func_63(p_25, (**l_416), (**l_416));
            /* statement id: 182 */
            assert (l_417 == &g_22);
            (*g_138) = (**l_459);
        }
        /* facts after branching */
        assert (l_417 == &g_22);
    }
    /* facts after branching */
    assert (l_332 == 0 || l_332 == &g_333);
    assert (l_417 == &g_22 || l_417 == &l_356);
    (*g_138) = ((safe_rshift_func_int8_t_s_u((safe_sub_func_uint16_t_u_u((((0xA322 < p_26) == 0x08) >= 0x62), (((p_24 < ((safe_add_func_int16_t_s_s((safe_add_func_int16_t_s_s((safe_sub_func_uint16_t_u_u((safe_unary_minus_func_int16_t_s(1)), p_24)), (&g_167 != &l_286))), g_116.f0)) == 0xA3AC)) == 0xA0) | 0x5171))), (**l_416))) >= 65535U);
    (*l_473) = g_471;
    /* statement id: 187 */
    assert (l_474 == &g_472);
    return &g_421;
    /* statement id: 188 */
    //assert (func_23_rv == &g_421);
}


/* ------------------------------------------ */
/* 
 * reads : g_34 g_22 g_33 g_69 g_16 g_116.f1 g_116.f5 g_145 g_168 g_116.f3 g_116.f2 g_138 g_116.f0
 * writes: g_22 g_69 g_116.f4 g_138 g_145 g_166 g_34
 */
inline static int32_t * func_27(int32_t  p_28, uint16_t  p_29, uint32_t  p_30, int32_t * p_31, uint32_t  p_32)
{ /* block id: 4 */
    int32_t l_151 = 0x1E780F4A;
    struct S0 l_216 = {1,-114,1256};
    if ((*g_34))
    { /* block id: 5 */
        int32_t l_148 = 0x39397282;
        int32_t ***l_165 = (void*)0;
        int32_t ****l_164 = &l_165;
        int32_t ***** const l_163 = &l_164;
        struct S1 **l_178 = &g_69;
        (*g_34) = (safe_sub_func_uint32_t_u_u(4294967293U, ((((void*)0 == (*g_33)) > func_37(p_30, (*g_33))) <= (safe_sub_func_uint32_t_u_u((1 != l_148), (safe_rshift_func_uint8_t_u_u(l_151, p_30)))))));
        /* statement id: 58 */
        assert (g_69 == &g_116 || g_69 == 0);
        for (p_32 = 0; (p_32 == 20); ++p_32)
        { /* block id: 61 */
            struct S0 *l_156 = &g_145;
            for (p_28 = 1; (p_28 < 11); p_28 = safe_add_func_int16_t_s_s(p_28, 8))
            { /* block id: 64 */
                if ((*p_31))
                    break;
            }
            (*l_156) = g_145;
        }
        if ((*p_31))
        { /* block id: 69 */
            struct S0 * const l_159 = &g_145;
            int32_t l_175 = 0x57FF4375;
            struct S1 ** const l_183 = &g_69;
            for (p_32 = (-11); (p_32 != 43); p_32 = safe_add_func_uint8_t_u_u(p_32, 9))
            { /* block id: 72 */
                struct S0 *l_161 = (void*)0;
                struct S0 **l_160 = &l_161;
                int32_t *l_162 = &g_22;
                (*l_160) = l_159;
                /* statement id: 73 */
                assert (l_161 == &g_145);
                p_31 = l_162;
                g_166 = l_163;
                /* statement id: 75 */
                assert (g_166 == &l_164);
            }
            /* facts after for loop */
            assert (g_166 == &l_164 || g_166 == &g_167);
            if ((safe_lshift_func_int16_t_s_u((0x468E <= (safe_rshift_func_int8_t_s_u((safe_rshift_func_int8_t_s_u(l_175, ((safe_lshift_func_uint8_t_u_s(p_32, 5)) <= ((void*)0 == l_178)))), ((((safe_lshift_func_int8_t_s_u((p_32 <= (safe_add_func_uint16_t_u_u((l_183 != l_178), ((safe_rshift_func_uint16_t_u_u(0x85A9, 9)) != 4U)))), 2)) < 0U) != 0xF119E397) ^ l_151)))), 7)))
            { /* block id: 77 */
                int32_t *l_186 = &g_22;
                return l_186;
                /* statement id: 78 */
                //assert (g_166 == dangling || g_166 == &g_167);
                //assert (func_27_rv == &g_22);
            }
            else
            { /* block id: 79 */
                int32_t *l_187 = &l_151;
                struct S0 **l_188 = (void*)0;
                struct S0 *l_190 = &g_145;
                struct S0 **l_189 = &l_190;
                p_31 = l_187;
                /* statement id: 80 */
                assert (p_31 == &l_151);
                (*l_189) = &g_145;
            }
            /* facts after branching */
            assert (p_31 == &l_151);
            for (p_30 = 0; (p_30 == 20); p_30++)
            { /* block id: 85 */
                return (**g_168);
                /* statement id: 86 */
                //assert (g_166 == dangling || g_166 == &g_167);
                //assert (func_27_rv == &g_22);
            }
            p_31 = (void*)0;
            /* statement id: 88 */
            assert (p_31 == 0);
        }
        else
        { /* block id: 89 */
            uint32_t l_215 = 0U;
            (**g_168) = func_63(&l_151, (safe_rshift_func_uint16_t_u_u((safe_sub_func_int8_t_s_s(g_16, g_145.f1)), (0x7804E31C != ((safe_add_func_uint32_t_u_u(((((((0x4A ^ (safe_mod_func_uint16_t_u_u(((((((safe_add_func_uint16_t_u_u(((+((safe_mod_func_uint16_t_u_u(l_151, ((((((((g_116.f3 & (safe_rshift_func_int8_t_s_s(((((safe_mod_func_uint16_t_u_u((((((((safe_rshift_func_uint8_t_u_u((4294967295U <= (((safe_unary_minus_func_int8_t_s((safe_rshift_func_uint8_t_u_s(p_30, 2)))) ^ p_30) & p_29)), 1)) >= 0xE4519CD9) < p_32) ^ (-6)) >= 0) >= g_116.f2) == g_116.f1), l_151)) | g_16) & p_32) || p_28), 1))) & l_215) && p_28) & 0xD062) > (*g_138)) != p_29) | g_116.f0) ^ p_30))) > 1)) == l_215), 0x58DA)) && g_145.f0) > (-9)) >= (-1)) | 0x03) & g_16), 5U))) | p_30) != 0x5250) != l_215) >= 0x81AE) & 0x00010583), l_151)) <= g_145.f2)))), (***g_168));
            g_145 = l_216;
        }
        /* facts after branching */
        assert (p_31 == &g_22 || p_31 == 0);
        assert (g_166 == &l_164 || g_166 == &g_167);
    }
    else
    { /* block id: 93 */
        int32_t *l_217 = (void*)0;
        return l_217;
        /* statement id: 94 */
        //assert (func_27_rv == 0);
    }
    /* facts after branching */
    assert (p_31 == &g_22 || p_31 == 0);
    assert (g_69 == &g_116 || g_69 == 0);
    //assert (g_166 == dangling || g_166 == &g_167);
    (**g_168) = (void*)0;
    /* statement id: 96 */
    assert (g_34 == 0);
    (*g_138) = (!0x20E445E5);
    return (**g_168);
    /* statement id: 98 */
    //assert (func_27_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_34 g_22 g_33 g_69 g_16 g_116.f1 g_116.f5
 * writes: g_22 g_69 g_116.f4 g_138 g_145
 */
inline static uint32_t  func_37(uint32_t  p_38, int32_t * p_39)
{ /* block id: 6 */
    uint32_t l_40 = 0U;
    const struct S0 l_143 = {1,90,1435};
    struct S0 *l_144 = &g_145;
    (*g_34) = (p_38 || l_40);
    for (l_40 = (-25); (l_40 != 29); l_40 = safe_add_func_uint8_t_u_u(l_40, 3))
    { /* block id: 10 */
        int32_t ***l_46 = &g_33;
        int32_t ****l_139 = &l_46;
        int32_t *l_142 = (void*)0;
        (*l_139) = func_43(l_46, func_47(((func_10((safe_mod_func_int16_t_s_s(l_40, 0x62B1)), func_10(p_38, g_22)) <= 4) == p_38)));
        if ((****l_139))
        { /* block id: 50 */
            (***l_46) = (~p_38);
        }
        else
        { /* block id: 52 */
            int32_t **l_141 = (void*)0;
            l_142 = func_54(l_40, &g_34, p_39);
            /* statement id: 53 */
            assert (l_142 == &g_22);
        }
        /* facts after branching */
        assert (l_142 == &g_22 || l_142 == 0);
    }
    /* facts after for loop */
    assert (g_69 == &g_116 || g_69 == 0);
    (*l_144) = l_143;
    return g_116.f5;
}


/* ------------------------------------------ */
/* 
 * reads : g_22 g_33 g_34 g_69 g_16 g_116.f1 g_116.f4
 * writes: g_69 g_22 g_116.f4 g_138
 */
inline static int32_t *** func_43(int32_t *** p_44, int32_t  p_45)
{ /* block id: 14 */
    int32_t l_61 = 0xACAEC2B2;
    int32_t *l_137 = &g_22;
    int32_t **l_136 = &l_137;
    (*l_136) = func_54(g_22, func_58(g_22, l_61), func_63((**p_44), (safe_rshift_func_int8_t_s_s(p_45, 3)), l_61));
    g_138 = (**p_44);
    return &g_33;
    /* statement id: 48 */
    //assert (func_43_rv == &g_33);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_47(uint16_t  p_48)
{ /* block id: 11 */
    int32_t *l_52 = &g_22;
    int32_t **l_51 = &l_52;
    int8_t l_53 = 9;
    (*l_51) = (void*)0;
    /* statement id: 12 */
    assert (l_52 == 0);
    return l_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_34 g_22 g_69 g_16 g_33 g_116.f1 g_116.f4
 * writes: g_22 g_116.f4 g_69
 */
inline static int32_t * func_54(int32_t  p_55, int32_t ** p_56, int32_t * p_57)
{ /* block id: 20 */
    int32_t l_75 = 5;
    const int16_t l_82 = 1;
    int32_t *l_110 = &g_22;
    const struct S1 **l_123 = (void*)0;
    if ((!((safe_rshift_func_int16_t_s_s((l_75 >= (safe_add_func_int32_t_s_s((*g_34), l_75))), 8)) <= 0x0E)))
    { /* block id: 21 */
        int8_t l_85 = 0;
        int32_t l_107 = 0xFE27FCE2;
        int32_t *l_109 = &l_107;
        int32_t **l_108 = &l_109;
        (*g_34) = ((safe_add_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u(l_82, (&g_34 != &g_34))), ((safe_sub_func_int16_t_s_s(l_85, (safe_add_func_int32_t_s_s((*p_57), ((safe_rshift_func_int8_t_s_s(0, (1 && ((safe_rshift_func_int8_t_s_u(((+(safe_add_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u(((((safe_rshift_func_uint16_t_u_u(((safe_mod_func_uint8_t_u_u((safe_add_func_uint8_t_u_u(((safe_lshift_func_int16_t_s_u((g_69 == g_69), g_16)) & g_16), 0U)), g_22)) ^ l_75), 15)) && p_55) == l_85) && g_16), l_82)), l_82)), l_85))) > g_16), l_85)) & l_107)))) >= l_82))))) & l_75))) || l_85);
        (*g_34) = (**p_56);
        (*l_108) = (*g_33);
        /* statement id: 24 */
        assert (l_109 == &g_22);
        return (*p_56);
        /* statement id: 25 */
        //assert (func_54_rv == &g_22);
    }
    else
    { /* block id: 26 */
        int32_t ***l_112 = (void*)0;
        int32_t ****l_111 = &l_112;
        struct S1 *l_115 = &g_116;
        l_110 = &l_75;
        /* statement id: 27 */
        assert (l_110 == &l_75);
        (*l_111) = &p_56;
        /* statement id: 28 */
        assert (l_112 == &p_56);
        (*g_34) = (p_55 >= (safe_sub_func_int8_t_s_s((l_115 == l_115), (safe_add_func_uint16_t_u_u(((p_55 != ((safe_add_func_int32_t_s_s((*g_34), ((((&g_69 != l_123) != 0x0A77) && (((safe_unary_minus_func_uint16_t_u((***l_112))) != g_116.f1) < p_55)) ^ (**p_56)))) >= (*l_110))) ^ 0xDBBD), p_55)))));
        (****l_111) = ((&p_57 == &p_57) >= (****l_111));
    }
    /* facts after branching */
    assert (l_110 == &l_75);
    for (g_116.f4 = 0; (g_116.f4 != 0); g_116.f4 = safe_add_func_uint32_t_u_u(g_116.f4, 9))
    { /* block id: 34 */
        int32_t l_133 = 0xE83BB0DE;
        if ((safe_rshift_func_int16_t_s_s(0x7DF6, 1)))
        { /* block id: 35 */
            for (p_55 = 0; (p_55 <= 26); p_55 = safe_add_func_int16_t_s_s(p_55, 9))
            { /* block id: 38 */
                struct S1 **l_131 = (void*)0;
                struct S1 **l_132 = &g_69;
                (*l_132) = &g_116;
                /* statement id: 39 */
                assert (g_69 == &g_116);
            }
        }
        else
        { /* block id: 41 */
            int32_t **l_134 = (void*)0;
            int32_t **l_135 = &l_110;
            (*l_135) = func_63((*g_33), l_133, (*p_57));
            /* statement id: 42 */
            assert (l_110 == &g_22);
        }
    }
    /* facts after for loop */
    assert (l_110 == &g_22 || l_110 == &l_75);
    return (*g_33);
    /* statement id: 45 */
    //assert (func_54_rv == &g_22);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_58(uint8_t  p_59, int32_t  p_60)
{ /* block id: 15 */
    int32_t **l_62 = &g_34;
    return l_62;
    /* statement id: 16 */
    //assert (func_58_rv == &g_34);
}


/* ------------------------------------------ */
/* 
 * reads : g_69
 * writes: g_69
 */
static int32_t * func_63(int32_t * p_64, uint32_t  p_65, int32_t  p_66)
{ /* block id: 17 */
    struct S1 **l_70 = &g_69;
    int32_t *l_71 = &g_22;
    (*l_70) = g_69;
    return l_71;
    /* statement id: 19 */
    //assert (func_63_rv == &g_22);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_16;
    csmith_sink_ = g_22;
    csmith_sink_ = g_116.f0;
    csmith_sink_ = g_116.f1;
    csmith_sink_ = g_116.f2;
    csmith_sink_ = g_116.f3;
    csmith_sink_ = g_116.f4;
    csmith_sink_ = g_116.f5;
    csmith_sink_ = g_116.f6;
    csmith_sink_ = g_116.f7;
    csmith_sink_ = g_145.f0;
    csmith_sink_ = g_145.f1;
    csmith_sink_ = g_145.f2;
    csmith_sink_ = g_333.f0;
    csmith_sink_ = g_333.f1;
    csmith_sink_ = g_333.f2;
    csmith_sink_ = g_333.f3;
    csmith_sink_ = g_333.f4;
    csmith_sink_ = g_333.f5;
    csmith_sink_ = g_333.f6;
    csmith_sink_ = g_333.f7;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 84
   depth: 1, occurrence: 7
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 10
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 23
breakdown:
   indirect level: 0, occurrence: 7
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 9
XXX full-bitfields structs in the program: 7
breakdown:
   indirect level: 0, occurrence: 7
XXX times a bitfields struct's address is taken: 21
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 15
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 52

XXX max expression depth: 49
breakdown:
   depth: 1, occurrence: 139
   depth: 2, occurrence: 18
   depth: 3, occurrence: 2
   depth: 4, occurrence: 6
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 3
   depth: 13, occurrence: 1
   depth: 15, occurrence: 4
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 40, occurrence: 1
   depth: 49, occurrence: 1

XXX total number of pointers: 91

XXX times a variable address is taken: 95
XXX times a pointer is dereferenced on RHS: 65
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 19
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 58
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 6
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 272

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 133
   level: 2, occurrence: 39
   level: 3, occurrence: 25
   level: 4, occurrence: 33
   level: 5, occurrence: 20
XXX number of pointers point to pointers: 52
XXX number of pointers point to scalars: 23
XXX number of pointers point to structs: 16
XXX percent of pointers has null in alias set: 22
XXX average alias set size: 1.2

XXX times a non-volatile is read: 493
XXX times a non-volatile is write: 165
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 118
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 20
   depth: 2, occurrence: 26
   depth: 3, occurrence: 25
   depth: 4, occurrence: 14
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 17.7
XXX percentage an existing variable is used: 82.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

