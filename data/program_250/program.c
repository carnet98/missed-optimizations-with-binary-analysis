/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-jumps --longlong --no-force-non-uniform-arrays --no-math64 --muls --no-packed-struct --no-paranoid --pointers --no-structs --inline-function --no-return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      2039151328
 */

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint32_t g_11 = 0xA8D3A18EL;
static int32_t g_53 = (-2L);
static int32_t * const g_58 = &g_53;
static int32_t * const *g_57 = &g_58;
static int32_t * const ** const g_56 = &g_57;
static int32_t *g_112 = &g_53;
static int32_t **g_111 = &g_112;
static uint32_t g_307 = 18446744073709551606UL;
static int32_t g_311 = 0x9A90DBD7L;


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_1(void);
inline static int16_t  func_2(int8_t  p_3, uint32_t  p_4, uint32_t  p_5, const int32_t  p_6, uint32_t  p_7);
inline static uint8_t  func_12(const int32_t  p_13, uint16_t  p_14, int16_t  p_15, uint16_t  p_16);
static uint8_t  func_21(uint32_t  p_22, int32_t  p_23);
inline static int32_t  func_30(int8_t  p_31, uint32_t  p_32, uint32_t  p_33, uint32_t  p_34, const uint32_t  p_35);
static uint16_t  func_42(uint16_t  p_43, int16_t  p_44, uint8_t  p_45, int8_t  p_46);
static uint8_t  func_61(uint16_t  p_62, int32_t *** const  p_63, int32_t * p_64, int8_t  p_65, int32_t ** p_66);
static int32_t *** func_67(int16_t  p_68, int8_t  p_69, uint16_t  p_70, int32_t * p_71, const uint32_t  p_72);
static int32_t * func_76(int32_t ** p_77, int32_t ** p_78, int32_t ** p_79);
inline static int32_t ** func_80(uint16_t  p_81, int32_t  p_82, uint32_t  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_11 g_53 g_56 g_57 g_58 g_111 g_112 g_307 g_311
 * writes: g_53 g_112 g_11 g_307
 */
inline static int32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_8 = 0UL;
    (*g_58) = ((func_2(l_8, (((((safe_lshift_func_int16_t_s_u(g_11, 1)) && (((((func_12(l_8, l_8, l_8, g_11) > g_311) ^ ((safe_mod_func_uint32_t_u_u(g_311, 0xEBA00EA8L)) >= 0L)) < l_8) || 0xBDL) | l_8)) != g_311) && 65533UL) & 0x28C111F8L), l_8, l_8, g_311) & g_311) == l_8);
    return g_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_56 g_57 g_58 g_112 g_53
 * writes: g_112
 */
inline static int16_t  func_2(int8_t  p_3, uint32_t  p_4, uint32_t  p_5, const int32_t  p_6, uint32_t  p_7)
{ /* block id: 187 */
    int32_t **l_450 = &g_112;
    (*l_450) = (**g_56);
    return (**l_450);
}


/* ------------------------------------------ */
/* 
 * reads : g_11 g_53 g_56 g_57 g_58 g_111 g_112 g_307 g_311
 * writes: g_53 g_112 g_11 g_307
 */
inline static uint8_t  func_12(const int32_t  p_13, uint16_t  p_14, int16_t  p_15, uint16_t  p_16)
{ /* block id: 1 */
    const int32_t l_26 = 0L;
    if ((safe_rshift_func_int16_t_s_u((safe_unary_minus_func_uint16_t_u((~func_21((1UL & (safe_lshift_func_int16_t_s_s(l_26, (safe_unary_minus_func_int16_t_s((safe_rshift_func_int8_t_s_u(l_26, 3))))))), func_30(p_16, (safe_lshift_func_uint8_t_u_s((safe_sub_func_int8_t_s_s(((safe_mod_func_uint16_t_u_u(p_15, func_42(g_11, g_11, g_11, (safe_mod_func_uint8_t_u_u(((0x3D37F4A1L <= l_26) ^ p_13), l_26))))) | l_26), l_26)), 4)), p_13, g_11, p_15))))), p_14)))
    { /* block id: 166 */
        int32_t l_422 = 0xBF441BDDL;
        (***g_56) = (((***g_56) <= ((p_15 >= (safe_mul_func_uint8_t_u_u(((safe_rshift_func_uint16_t_u_u(l_422, p_15)) == (safe_add_func_uint16_t_u_u((250UL || (((((safe_lshift_func_uint8_t_u_s(((safe_lshift_func_int8_t_s_s((safe_lshift_func_uint16_t_u_u(l_422, 15)), 1)) ^ (l_26 && (safe_lshift_func_int8_t_s_u(l_26, 5)))), 5)) && (safe_sub_func_int16_t_s_s(((+((((safe_sub_func_uint32_t_u_u(1UL, p_15)) == p_15) <= 0xFEE4L) != g_53)) <= l_422), 0x7D40L))) && p_16) && 0xCCL) & p_15)), p_15))), p_15))) < g_11)) ^ l_26);
    }
    else
    { /* block id: 168 */
        for (p_16 = 0; (p_16 == 39); p_16 = safe_add_func_uint32_t_u_u(p_16, 9))
        { /* block id: 171 */
            const int32_t *l_442 = &g_311;
            for (g_307 = 0; (g_307 == 49); g_307 = safe_add_func_int32_t_s_s(g_307, 4))
            { /* block id: 174 */
                int32_t ***l_446 = &g_111;
                int32_t ****l_445 = &l_446;
                l_442 = (void*)0;
                for (p_14 = 0; (p_14 >= 45); p_14++)
                { /* block id: 178 */
                    int32_t *****l_447 = &l_445;
                    (**g_57) = (***g_56);
                    (*l_447) = l_445;
                }
            }
        }
        return p_14;
    }
    return l_26;
}


/* ------------------------------------------ */
/* 
 * reads : g_56 g_57 g_58 g_53 g_11 g_111 g_112 g_307 g_311
 * writes: g_112 g_53 g_11
 */
static uint8_t  func_21(uint32_t  p_22, int32_t  p_23)
{ /* block id: 14 */
    int32_t * const **l_59 = &g_57;
    int32_t *l_410 = &g_311;
    l_59 = g_56;
    if ((func_42(((+((void*)0 == &g_57)) <= 4UL), p_22, func_61(p_22, func_67((***l_59), (((p_22 <= (safe_unary_minus_func_int8_t_s((l_59 != (void*)0)))) >= (-6L)) != 0xD98CL), p_23, &g_53, g_11), l_410, g_307, &l_410), (*l_410)) <= 0x04F5E980L))
    { /* block id: 159 */
        int32_t **l_415 = (void*)0;
        int32_t **l_416 = &l_410;
        (*l_416) = (**l_59);
        return g_307;
    }
    else
    { /* block id: 162 */
        int32_t *l_417 = (void*)0;
        (*g_111) = l_417;
    }
    return p_22;
}


/* ------------------------------------------ */
/* 
 * reads : g_53
 * writes: g_53
 */
inline static int32_t  func_30(int8_t  p_31, uint32_t  p_32, uint32_t  p_33, uint32_t  p_34, const uint32_t  p_35)
{ /* block id: 4 */
    int32_t l_51 = 0x92764969L;
    int32_t *l_52 = &g_53;
    int32_t **l_55 = &l_52;
    for (p_31 = 0; (p_31 > (-19)); p_31 = safe_sub_func_int32_t_s_s(p_31, 1))
    { /* block id: 7 */
        return l_51;
    }
    (*l_52) = (1UL && 0L);
    (*l_52) = (safe_unary_minus_func_int32_t_s((l_52 == l_52)));
    (*l_55) = &g_53;
    return (*l_52);
}


/* ------------------------------------------ */
/* 
 * reads : g_11
 * writes:
 */
static uint16_t  func_42(uint16_t  p_43, int16_t  p_44, uint8_t  p_45, int8_t  p_46)
{ /* block id: 2 */
    return g_11;
}


/* ------------------------------------------ */
/* 
 * reads : g_112 g_57 g_58 g_311
 * writes: g_53 g_112
 */
static uint8_t  func_61(uint16_t  p_62, int32_t *** const  p_63, int32_t * p_64, int8_t  p_65, int32_t ** p_66)
{ /* block id: 155 */
    int8_t l_413 = 0x05L;
    int32_t **l_414 = &g_112;
    (*g_112) = (0xD6L < (safe_sub_func_uint32_t_u_u(l_413, (p_62 == ((void*)0 == &g_57)))));
    (*l_414) = (*g_57);
    return g_311;
}


/* ------------------------------------------ */
/* 
 * reads : g_53 g_11 g_57 g_58 g_111 g_112
 * writes: g_112 g_53 g_11
 */
static int32_t *** func_67(int16_t  p_68, int8_t  p_69, uint16_t  p_70, int32_t * p_71, const uint32_t  p_72)
{ /* block id: 16 */
    int32_t l_90 = 0x46CA37EAL;
    for (p_69 = 0; (p_69 <= (-4)); --p_69)
    { /* block id: 19 */
        int32_t l_89 = 0x0ED6CA13L;
        int32_t **l_113 = &g_112;
        (*l_113) = func_76(func_80((safe_lshift_func_uint8_t_u_u((safe_mul_func_int16_t_s_s(((!l_89) >= (l_90 || (safe_rshift_func_uint16_t_u_u((p_72 || (safe_add_func_uint32_t_u_u(4294967290UL, ((safe_sub_func_int16_t_s_s((safe_mul_func_int16_t_s_s(0x035DL, 0UL)), g_53)) && ((-8L) & (safe_mod_func_uint8_t_u_u((safe_mod_func_uint16_t_u_u(g_11, g_11)), g_11))))))), 10)))), l_89)), 6)), (**g_57), l_90), l_113, l_113);
    }
    return &g_111;
}


/* ------------------------------------------ */
/* 
 * reads : g_53 g_57 g_58 g_112 g_11 g_111
 * writes: g_112 g_53 g_11
 */
static int32_t * func_76(int32_t ** p_77, int32_t ** p_78, int32_t ** p_79)
{ /* block id: 24 */
    uint32_t l_116 = 0x65C99C23L;
    int8_t l_117 = 5L;
    const int32_t **l_119 = (void*)0;
    int32_t *l_141 = &g_53;
    int32_t **l_175 = &g_112;
    int8_t l_191 = 0xAFL;
    int8_t l_211 = 0x89L;
    const uint16_t l_217 = 65535UL;
    uint32_t l_230 = 18446744073709551606UL;
    int16_t l_327 = 0x457AL;
    int32_t l_346 = 0xA8841FF7L;
    uint16_t l_393 = 0UL;
    uint16_t l_403 = 0xE100L;
    if (((safe_lshift_func_uint8_t_u_u(l_116, (l_117 != l_116))) || ((!(l_117 || (l_119 != (void*)0))) > (g_53 ^ ((safe_mul_func_uint16_t_u_u(65532UL, ((safe_lshift_func_uint8_t_u_u(l_116, 7)) & 0xC5L))) != g_53)))))
    { /* block id: 25 */
        int32_t **l_124 = &g_112;
        (*l_124) = (*g_57);
        (**p_77) = ((safe_sub_func_uint16_t_u_u((**l_124), (**l_124))) >= ((safe_add_func_int8_t_s_s(0x2DL, (safe_sub_func_uint32_t_u_u(((**l_124) >= ((safe_lshift_func_uint16_t_u_u(((((safe_add_func_uint8_t_u_u((safe_mod_func_uint8_t_u_u((safe_lshift_func_int16_t_s_s((safe_sub_func_uint16_t_u_u(0UL, ((((void*)0 != l_141) != (**l_124)) | ((safe_sub_func_uint8_t_u_u((**l_124), (-1L))) < (**p_79))))), 8)), g_11)), (*l_141))) > (**l_124)) != (-10L)) | g_11), 11)) & g_11)), (-1L))))) && (**l_124)));
    }
    else
    { /* block id: 28 */
        int8_t l_158 = 0xDEL;
        uint32_t l_173 = 0x311A8DCBL;
        int32_t l_174 = 9L;
        for (l_116 = (-16); (l_116 > 32); l_116 = safe_add_func_int32_t_s_s(l_116, 3))
        { /* block id: 31 */
            uint8_t l_146 = 252UL;
        }
    }
    (*l_175) = (*g_57);
    if ((((*l_175) != (void*)0) > (safe_add_func_int32_t_s_s(((void*)0 == &l_175), 0x9DCED91EL))))
    { /* block id: 42 */
        return (*p_78);
    }
    else
    { /* block id: 44 */
        uint16_t l_188 = 8UL;
        int32_t *l_200 = &g_53;
        for (l_116 = 0; (l_116 != 0); l_116 = safe_add_func_int32_t_s_s(l_116, 8))
        { /* block id: 47 */
            int8_t l_190 = 0x5BL;
            for (g_11 = 3; (g_11 != 55); g_11++)
            { /* block id: 50 */
                uint32_t l_192 = 0UL;
                int32_t *l_193 = &g_53;
                (**p_77) = ((((safe_lshift_func_int16_t_s_u((g_11 == g_53), ((*g_58) != 0L))) == (safe_sub_func_int8_t_s_s((((((g_11 || (safe_mul_func_int8_t_s_s((l_188 <= (((+l_190) >= l_191) && (0xFFDAL >= l_192))), 0L))) != (-10L)) < g_53) ^ g_53) != l_190), g_53))) | l_192) & 0x80C9L);
                (*p_79) = l_193;
                (*p_78) = (*p_79);
                if ((**g_111))
                    break;
            }
            if ((**p_79))
                continue;
        }
        for (l_116 = (-6); (l_116 >= 9); ++l_116)
        { /* block id: 60 */
            int16_t l_207 = 0L;
            (*g_112) = (safe_mod_func_uint32_t_u_u((safe_mul_func_uint16_t_u_u((((l_200 != (*p_78)) < ((safe_mul_func_int8_t_s_s((0x310A9C07L || 0xD9A5CC0BL), (safe_unary_minus_func_int16_t_s((g_11 != g_53))))) > ((((safe_rshift_func_uint8_t_u_s(((+0x827581F2L) != (((((**l_175) | (g_53 <= 0x6A01D589L)) < 0x67735A7CL) || l_207) > (*l_200))), 3)) == l_207) ^ (*g_58)) >= 0x21460D04L))) || 1UL), l_207)), l_207));
        }
    }
    for (l_191 = 0; (l_191 >= 27); ++l_191)
    { /* block id: 66 */
        int32_t l_210 = 0xD0454759L;
        int32_t **l_220 = &l_141;
        uint32_t l_229 = 1UL;
        uint32_t l_328 = 0x60BBCD69L;
        (*g_58) = (**g_57);
    }
    return (*l_175);
}


/* ------------------------------------------ */
/* 
 * reads : g_111
 * writes:
 */
inline static int32_t ** func_80(uint16_t  p_81, int32_t  p_82, uint32_t  p_83)
{ /* block id: 20 */
    int32_t *l_104 = (void*)0;
    int32_t **l_103 = &l_104;
    (*l_103) = &p_82;
    (**l_103) = (safe_lshift_func_uint8_t_u_s((((p_81 == 0xEF155D26L) != (safe_rshift_func_uint8_t_u_u((((**l_103) != (p_81 | (1UL >= p_81))) == (((((safe_mod_func_uint32_t_u_u((p_83 < (**l_103)), 6L)) <= p_83) < p_82) > 0xE3L) > (**l_103))), 0))) == (-2L)), 1));
    return g_111;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_11;
    csmith_sink_ = g_53;
    csmith_sink_ = g_307;
    csmith_sink_ = g_311;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 67
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 12
   depth: 5, occurrence: 2
   depth: 12, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 49

XXX times a variable address is taken: 53
XXX times a pointer is dereferenced on RHS: 119
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 61
   depth: 3, occurrence: 9
XXX times a pointer is dereferenced on LHS: 53
breakdown:
   depth: 1, occurrence: 35
   depth: 2, occurrence: 17
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 273

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 102
   level: 2, occurrence: 116
   level: 3, occurrence: 13
XXX number of pointers point to pointers: 30
XXX number of pointers point to scalars: 19
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 12.2
XXX average alias set size: 1.12

XXX times a non-volatile is read: 587
XXX times a non-volatile is write: 148
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 55
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 15
   depth: 2, occurrence: 4
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2

XXX percentage a fresh-made variable is used: 15.2
XXX percentage an existing variable is used: 84.8
********************* end of statistics **********************/

