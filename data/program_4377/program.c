/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-jumps --no-longlong --force-non-uniform-arrays --math64 --no-muls --packed-struct --no-paranoid --pointers --structs --inline-function --return-structs --arg-structs --dangling-global-pointers
 * Seed:      2476451563891347262
 */


#define NO_LONGLONG

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
   signed f2 : 22;
   uint8_t  f3;
   int32_t  f4;
   int32_t  f5;
   uint32_t  f6;
   int32_t  f7;
   int32_t  f8;
   uint32_t  f9;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   const uint16_t  f0;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_2 = 0U;
static int32_t g_6 = 0x45625132;
static int32_t *g_5 = &g_6;
static struct S1 g_19 = {0xC28C};
static struct S0 g_39 = {0x1425452E,4294967294U,823,0U,0x33ECB407,0xB0BE945D,0U,-3,0xD5680A25,1U};
static struct S0 g_121 = {0xAF4752A8,0x6A380BAD,-467,0x15,0x3DCCCE59,0xC1C7BDE7,0xC92A3EDA,0x1CD825BC,0x0674D57D,4294967295U};
static int16_t g_146 = 8;
static int16_t g_197 = 0x0853;
static struct S1 g_254 = {0xF192};
static struct S1 *g_253 = &g_254;
static struct S0 *g_258 = &g_39;
static struct S0 **g_257 = &g_258;
static int32_t **g_311 = &g_5;
static int32_t ***g_310 = &g_311;
static int32_t *g_313 = &g_39.f8;
static int32_t g_390 = (-5);
static struct S1 ***g_391 = (void*)0;
static struct S0 g_406 = {0xB81689C6,4294967292U,-468,0x54,0,0x941AB923,0x029D7451,0xDCF0F107,0x7FDD7758,7U};


/* --- FORWARD DECLARATIONS --- */
inline static uint8_t  func_1(void);
inline static struct S1 * func_7(int32_t  p_8, uint16_t  p_9, int32_t * p_10);
static int16_t  func_11(uint8_t  p_12, uint32_t  p_13, int16_t  p_14);
inline static uint16_t  func_15(struct S1 * const  p_16, int32_t * p_17);
static int32_t ** func_20(int32_t  p_21, struct S1 * p_22);
inline static struct S1 * func_23(struct S1 * p_24, uint8_t  p_25, int32_t * p_26, uint8_t  p_27, struct S1 * p_28);
static int16_t  func_34(struct S0  p_35, uint32_t  p_36);
static struct S0 ** func_40(uint32_t  p_41, int16_t  p_42, int32_t ** p_43, uint32_t  p_44);
inline static uint8_t  func_45(struct S1  p_46, struct S0  p_47, struct S0  p_48);
inline static struct S1  func_49(int32_t * p_50);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_6 g_19.f0 g_39.f4 g_39.f7 g_39.f3 g_39.f9 g_257 g_258 g_39 g_5 g_121.f4 g_310 g_313 g_121.f2 g_254.f0 g_121.f5 g_311 g_121.f0 g_121.f9 g_146 g_121.f6 g_121.f1 g_121.f8 g_121.f3 g_390 g_391 g_121.f7 g_406.f6
 * writes: g_2 g_5 g_39 g_121 g_257 g_253 g_313 g_311 g_406 g_258 g_6
 */
inline static uint8_t  func_1(void)
{ /* block id: 0 */
    struct S1 * const l_18 = &g_19;
    int32_t l_358 = 0xFE36CB6C;
    int32_t **l_455 = &g_313;
    if (g_2)
    { /* block id: 1 */
        int8_t l_356 = (-1);
        uint32_t l_357 = 4294967294U;
        struct S1 **l_445 = &g_253;
        for (g_2 = 14; (g_2 > 10); g_2--)
        { /* block id: 4 */
            g_5 = (void*)0;
        }
        (*l_445) = func_7((func_11(g_6, ((((func_15(l_18, &g_6) < (((((((g_258 != g_258) & g_2) != (safe_sub_func_uint8_t_u_u(((void*)0 == g_258), l_356))) | l_356) | g_2) == l_356) > 0x9D)) & l_357) >= l_356) || l_358), l_358) ^ 0xC031), l_358, &l_358);
    }
    else
    { /* block id: 271 */
        int32_t **l_454 = &g_5;
        (*g_310) = (void*)0;
        (*g_5) = (*g_5);
        for (l_358 = 0; (l_358 <= (-24)); l_358 = safe_sub_func_uint8_t_u_u(l_358, 6))
        { /* block id: 276 */
            uint16_t l_450 = 0U;
            int32_t l_451 = (-3);
            int32_t **l_452 = (void*)0;
            int32_t **l_453 = &g_313;
        }
        (*l_454) = &l_358;
    }
    (*l_455) = &l_358;
    return g_121.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1 * func_7(int32_t  p_8, uint16_t  p_9, int32_t * p_10)
{ /* block id: 267 */
    struct S0 l_444 = {0U,0x50531CE2,105,1U,0xD4654BA4,-1,0x7CA8B9AF,0,0x06EE5CF3,0U};
    l_444 = l_444;
    return &g_19;
}


/* ------------------------------------------ */
/* 
 * reads : g_257 g_258 g_39 g_310 g_311 g_313 g_121.f1 g_121.f9 g_121.f5 g_254.f0 g_121.f8 g_121.f3 g_121.f4 g_2 g_121.f2 g_390 g_391 g_121.f7 g_406.f6
 * writes: g_39 g_313 g_121.f4 g_2 g_5 g_406 g_121.f5 g_121.f8 g_258
 */
static int16_t  func_11(uint8_t  p_12, uint32_t  p_13, int16_t  p_14)
{ /* block id: 207 */
    int32_t *l_359 = &g_39.f7;
    struct S1 *l_360 = &g_19;
    uint32_t l_363 = 4294967295U;
    struct S0 *l_377 = &g_39;
    int32_t l_378 = 0xB9B5C6D6;
    int32_t l_379 = 0x6AAA291E;
    struct S1 **l_393 = &l_360;
    struct S1 ***l_392 = &l_393;
    int32_t ***l_407 = &g_311;
    (**g_257) = (**g_257);
    l_359 = (**g_310);
    (*g_258) = (**g_257);
    if (((((((void*)0 == l_360) > 4294967295U) == 0x8394) < (p_14 < (((((safe_lshift_func_uint16_t_u_s(((g_121.f1 || l_363) | (safe_rshift_func_int16_t_s_s(((((g_121.f9 > ((((-10) ^ 0x1478E56B) || g_121.f5) >= g_39.f3)) != 0) | p_13) & g_39.f9), p_13))), l_363)) & p_14) > g_121.f1) <= 0x3A3C200E) != l_363))) > g_39.f9))
    { /* block id: 211 */
        (*g_258) = (**g_257);
        (*g_311) = l_359;
        return g_39.f1;
    }
    else
    { /* block id: 215 */
        int8_t l_376 = (-8);
        int32_t * const l_385 = (void*)0;
        struct S0 l_405 = {1U,4294967295U,-320,5U,1,0x9D41F788,0xA617C6CC,1,5,0x640594B7};
        int32_t ***l_408 = &g_311;
        int16_t l_419 = (-8);
        struct S1 *l_438 = &g_254;
        struct S0 ***l_439 = &g_257;
        int32_t *l_442 = (void*)0;
        int32_t *l_443 = &g_39.f8;
        l_378 = (safe_lshift_func_uint8_t_u_u((((-9) > g_254.f0) && ((0U ^ (safe_lshift_func_int8_t_s_u((((safe_add_func_int32_t_s_s((safe_rshift_func_int8_t_s_u((safe_rshift_func_int16_t_s_u(p_12, 10)), 0)), (0x3F > ((((l_376 == (0xA4 <= ((l_377 == (void*)0) || 7))) && 1) | g_39.f6) != 0x27)))) >= p_13) & g_121.f8), 4))) > g_121.f3)), 4));
        if ((0 < (g_254.f0 <= (g_254.f0 ^ l_379))))
        { /* block id: 217 */
            struct S0 l_382 = {5U,1U,-1558,0xCB,0x1CA60A50,-9,4294967295U,0x3D67D674,0x4AEB1D1E,0x2F020D75};
            for (g_121.f4 = (-24); (g_121.f4 >= (-26)); --g_121.f4)
            { /* block id: 220 */
                return p_13;
            }
            (*l_377) = l_382;
            for (g_2 = 0; (g_2 == 45); ++g_2)
            { /* block id: 226 */
                int32_t **l_386 = (void*)0;
                int32_t **l_387 = &g_5;
                int32_t l_401 = 0xD1D7D04A;
                (*l_387) = l_385;
                l_401 = ((g_121.f2 == g_390) > ((g_391 == l_392) > ((safe_lshift_func_int16_t_s_s(((safe_mod_func_int16_t_s_s((safe_unary_minus_func_int32_t_s(1)), p_14)) != p_13), 12)) != (safe_mod_func_uint16_t_u_u((((g_121.f5 | ((l_382.f1 | p_14) <= p_12)) > l_376) && p_13), l_363)))));
                if (p_13)
                    continue;
            }
            for (g_39.f8 = (-8); (g_39.f8 < 6); g_39.f8 = safe_add_func_int32_t_s_s(g_39.f8, 4))
            { /* block id: 233 */
                int32_t *l_404 = &g_39.f7;
                (**g_310) = (*g_311);
                (*g_311) = (**g_310);
                (*g_311) = l_404;
                g_406 = l_405;
            }
        }
        else
        { /* block id: 239 */
            struct S1 *l_409 = (void*)0;
            int32_t ****l_410 = &g_310;
            int16_t l_420 = 0;
            if ((p_12 < (g_121.f7 != (l_407 == l_408))))
            { /* block id: 240 */
                uint32_t l_418 = 9U;
                (**l_392) = l_409;
                l_420 = (((((l_410 == &l_407) <= (safe_add_func_int16_t_s_s(0x5FE5, (((safe_sub_func_uint8_t_u_u(4U, (~5))) ^ (safe_add_func_int16_t_s_s((((0xDA5BF75F && l_418) >= (((p_14 < p_12) || 253U) | g_39.f5)) && g_406.f6), g_39.f7))) != 0xC5)))) > p_14) < 0) ^ l_419);
                (**l_408) = (*g_311);
                (**l_407) = (**l_407);
            }
            else
            { /* block id: 245 */
                int32_t l_433 = 0;
                int32_t *l_437 = &g_406.f5;
                for (l_405.f4 = (-16); (l_405.f4 > (-27)); l_405.f4 = safe_sub_func_uint16_t_u_u(l_405.f4, 6))
                { /* block id: 248 */
                    uint32_t l_434 = 5U;
                    (**g_257) = (**g_257);
                    g_121.f5 = ((safe_mod_func_int32_t_s_s(0, (-1))) > ((p_12 & (g_121.f5 || ((safe_lshift_func_uint16_t_u_s((((void*)0 != (**g_310)) >= (safe_lshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u(((0xC16E <= l_433) && (-8)), 4)), g_121.f1))), 3)) | 1U))) > l_434));
                }
                for (g_121.f8 = 0; (g_121.f8 >= (-20)); --g_121.f8)
                { /* block id: 254 */
                    (**l_408) = l_437;
                    (*g_257) = l_377;
                }
                (**l_392) = l_438;
            }
            l_405.f2 = p_13;
            (**l_407) = (**l_408);
        }
        l_439 = (void*)0;
        (*l_443) = (0 > (safe_add_func_int8_t_s_s(p_12, ((((void*)0 == &l_408) ^ g_121.f2) != 255U))));
    }
    return p_12;
}


/* ------------------------------------------ */
/* 
 * reads : g_19.f0 g_2 g_39.f4 g_39.f7 g_39.f3 g_39.f9 g_257 g_6 g_258 g_39 g_5 g_121.f4 g_310 g_313 g_121.f2 g_254.f0 g_121.f5 g_311 g_121.f0 g_121.f9 g_146 g_121.f6
 * writes: g_39 g_5 g_121 g_257 g_253 g_313 g_311
 */
inline static uint16_t  func_15(struct S1 * const  p_16, int32_t * p_17)
{ /* block id: 7 */
    struct S1 *l_29 = &g_19;
    struct S0 l_37 = {4294967293U,8U,-2041,254U,0x2EFE8E60,-1,0U,-7,-1,0x5E13CD4F};
    struct S1 ***l_340 = (void*)0;
    int32_t *l_341 = &l_37.f7;
    (*g_310) = func_20(g_19.f0, func_23(l_29, (((7U < (0 <= ((safe_sub_func_int32_t_s_s((safe_sub_func_uint16_t_u_u((func_34(l_37, g_2) | (safe_mod_func_int8_t_s_s((((void*)0 != l_340) ^ 255U), g_19.f0))), g_146)), 1)) || l_37.f0))) < 1U) | 0xC2), l_341, (*l_341), l_29));
    return g_39.f6;
}


/* ------------------------------------------ */
/* 
 * reads : g_39.f7 g_313 g_311 g_257 g_258 g_121.f6
 * writes: g_39.f8 g_5 g_39 g_121.f6 g_313
 */
static int32_t ** func_20(int32_t  p_21, struct S1 * p_22)
{ /* block id: 186 */
    struct S1 *l_344 = &g_254;
    int32_t l_345 = 0xCDC3E104;
    uint16_t l_347 = 0U;
    int32_t **l_350 = &g_313;
    if (((p_22 != l_344) > (((-1) == 0xB3B32C04) <= l_345)))
    { /* block id: 187 */
        struct S1 *l_346 = &g_254;
        (*g_313) = (((l_346 != (void*)0) < g_39.f7) && (p_21 ^ l_345));
    }
    else
    { /* block id: 189 */
        int32_t *l_348 = &g_39.f8;
        struct S0 l_351 = {4294967290U,0xD04DAC93,-122,249U,0xB61EE534,0x33099370,0x3A9BFCDB,0xEE339FBE,-9,0xFABAB807};
        (*g_313) = l_347;
        if (p_21)
        { /* block id: 191 */
            int32_t *l_349 = &g_121.f7;
            l_349 = l_348;
        }
        else
        { /* block id: 193 */
            (*g_311) = &p_21;
            return l_350;
        }
        (**g_257) = l_351;
    }
    for (g_121.f6 = 12; (g_121.f6 >= 43); g_121.f6 = safe_add_func_int8_t_s_s(g_121.f6, 1))
    { /* block id: 201 */
        (*l_350) = (void*)0;
    }
    return l_350;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1 * func_23(struct S1 * p_24, uint8_t  p_25, int32_t * p_26, uint8_t  p_27, struct S1 * p_28)
{ /* block id: 183 */
    const int32_t *l_342 = (void*)0;
    struct S1 *l_343 = &g_19;
    l_342 = l_342;
    return l_343;
}


/* ------------------------------------------ */
/* 
 * reads : g_39.f4 g_39.f7 g_39.f3 g_39.f9 g_257 g_6 g_258 g_39 g_5 g_121.f4 g_310 g_313 g_121.f2 g_254.f0 g_121.f5 g_311 g_121.f0 g_121.f9 g_2
 * writes: g_39 g_5 g_121 g_257 g_253
 */
static int16_t  func_34(struct S0  p_35, uint32_t  p_36)
{ /* block id: 8 */
    struct S0 *l_38 = &g_39;
    int32_t *l_51 = &g_39.f7;
    struct S0 ***l_259 = &g_257;
    int32_t **l_274 = (void*)0;
    int32_t ***l_273 = &l_274;
    int32_t ****l_272 = &l_273;
    int16_t l_337 = 0xA8C5;
    (*l_38) = p_35;
    (*l_259) = func_40(((&g_39 != (void*)0) < (func_45(func_49(l_51), p_35, p_35) | g_39.f3)), g_39.f9, &l_51, g_39.f3);
    if ((safe_sub_func_int8_t_s_s((safe_mod_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u((safe_add_func_uint8_t_u_u(((((safe_lshift_func_uint16_t_u_u((!((-1) | ((~65527U) == (((((p_35.f6 != (*l_51)) || g_6) < ((*l_51) & (*l_51))) ^ (((void*)0 != l_272) >= p_35.f9)) > p_36)))), g_39.f3)) != 1) != p_35.f9) < p_35.f5), g_39.f7)), g_6)), (*l_51))), p_35.f2)))
    { /* block id: 133 */
        const int32_t *l_275 = &g_39.f7;
        const int32_t **l_276 = &l_275;
        g_5 = &g_6;
        (*l_276) = l_275;
        g_5 = &g_6;
    }
    else
    { /* block id: 137 */
        struct S1 **l_277 = &g_253;
        int32_t **l_278 = &g_5;
        struct S0 l_281 = {6U,0x424F5989,595,0xFC,0x0C9890C0,0x86A296AE,0xCEF9BB32,0x21BFEE4D,-4,0x8D8505F0};
        int16_t l_318 = 0xEA00;
        (*l_277) = &g_19;
        (*l_278) = &g_6;
        (*l_38) = (*g_258);
        if ((safe_add_func_int32_t_s_s(p_35.f7, g_39.f1)))
        { /* block id: 141 */
            (*g_258) = l_281;
        }
        else
        { /* block id: 143 */
            uint32_t l_299 = 2U;
            int32_t *l_304 = &l_281.f8;
            struct S0 l_320 = {0x070C9ECB,1U,-1744,0x2C,1,0xE6F80BEC,4294967290U,0x9975634F,0x43A5CBA9,5U};
            for (l_281.f7 = 11; (l_281.f7 <= 20); l_281.f7 = safe_add_func_uint8_t_u_u(l_281.f7, 5))
            { /* block id: 146 */
                int32_t ****l_288 = &l_273;
                struct S1 *l_302 = &g_254;
                struct S0 ***l_331 = &g_257;
                const int32_t * const l_334 = &l_281.f8;
                const int32_t *l_336 = &g_39.f5;
                const int32_t **l_335 = &l_336;
                for (g_121.f9 = 22; (g_121.f9 > 11); g_121.f9 = safe_sub_func_int32_t_s_s(g_121.f9, 4))
                { /* block id: 149 */
                    struct S1 ***l_286 = (void*)0;
                    struct S1 ***l_287 = &l_277;
                    (*l_278) = &g_6;
                    (*l_287) = (void*)0;
                    (*l_51) = ((void*)0 == l_288);
                    for (l_281.f0 = 0; (l_281.f0 < 13); l_281.f0 = safe_add_func_int8_t_s_s(l_281.f0, 3))
                    { /* block id: 155 */
                        int32_t *l_291 = &g_121.f8;
                        l_291 = &g_6;
                        (*l_51) = p_35.f2;
                        if ((*g_5))
                            break;
                        (*l_278) = l_291;
                    }
                }
                if ((*g_5))
                { /* block id: 162 */
                    struct S1 *l_303 = &g_19;
                    int32_t ***l_309 = &l_274;
                    if ((((!((((&g_258 != &g_258) <= (safe_sub_func_int32_t_s_s(0x3C6D8B24, (safe_lshift_func_uint8_t_u_s((l_299 < ((safe_lshift_func_uint16_t_u_u((l_302 == l_303), 8)) > g_39.f0)), 6))))) < 7) && g_121.f4)) ^ p_35.f3) <= g_39.f9))
                    { /* block id: 163 */
                        g_5 = l_304;
                        (*l_38) = (*g_258);
                    }
                    else
                    { /* block id: 166 */
                        int32_t *l_312 = &l_281.f7;
                        (*g_313) = (safe_mod_func_uint16_t_u_u((((0xEADC || (safe_sub_func_int32_t_s_s((**l_278), 4294967288U))) <= ((l_309 != g_310) | (l_312 != g_313))) == (safe_rshift_func_int16_t_s_u((((safe_add_func_int8_t_s_s(p_35.f8, l_318)) != g_121.f2) <= g_254.f0), 2))), g_121.f5));
                        (*l_51) = (-1);
                        (*l_278) = l_304;
                        l_312 = (**g_310);
                    }
                }
                else
                { /* block id: 172 */
                    struct S0 l_319 = {0x790BFC1F,0x5C9EA918,-1279,255U,1,0x6EB9C293,1U,1,0xC2E01EB9,0xBCF94D50};
                    int32_t **l_328 = &l_304;
                    l_320 = l_319;
                    (*g_313) = (safe_rshift_func_int16_t_s_u((!(safe_lshift_func_uint8_t_u_s(0x10, (safe_sub_func_uint8_t_u_u((l_328 == (*g_310)), (((**l_278) && ((void*)0 == l_331)) <= ((-1) < ((safe_add_func_uint32_t_u_u(g_6, (((((g_39.f7 && (**l_278)) | g_121.f0) != g_121.f9) >= 0x4EACAEC4) ^ g_2))) < p_35.f2)))))))), g_6));
                }
                (*l_335) = l_334;
            }
            (*g_311) = (**g_310);
            (*g_311) = (*l_278);
        }
    }
    return l_337;
}


/* ------------------------------------------ */
/* 
 * reads : g_257
 * writes: g_121
 */
static struct S0 ** func_40(uint32_t  p_41, int16_t  p_42, int32_t ** p_43, uint32_t  p_44)
{ /* block id: 129 */
    struct S0 l_255 = {1U,4294967295U,-115,0xC6,0xDED8AAA0,0x3F47E55B,4294967288U,0x7DD89BB4,1,0xE3A16E78};
    struct S0 *l_256 = &g_121;
    (*l_256) = l_255;
    return g_257;
}


/* ------------------------------------------ */
/* 
 * reads : g_39.f7 g_39.f4
 * writes: g_39.f7 g_39.f4 g_39.f8 g_5
 */
inline static uint8_t  func_45(struct S1  p_46, struct S0  p_47, struct S0  p_48)
{ /* block id: 17 */
    uint32_t l_77 = 0x6A339976;
    int8_t l_83 = 0x4F;
    struct S0 *l_102 = &g_39;
    struct S0 **l_101 = &l_102;
    int32_t *l_142 = &g_121.f5;
    int16_t l_209 = 9;
    int32_t l_228 = 0;
    int32_t l_244 = (-2);
    for (p_48.f1 = (-6); (p_48.f1 <= 58); p_48.f1 = safe_add_func_uint32_t_u_u(p_48.f1, 1))
    { /* block id: 20 */
        int32_t *l_60 = &g_6;
        for (g_39.f7 = 0; (g_39.f7 >= 8); ++g_39.f7)
        { /* block id: 23 */
            l_60 = l_60;
        }
    }
    for (g_39.f4 = 0; (g_39.f4 > 3); g_39.f4 = safe_add_func_int8_t_s_s(g_39.f4, 7))
    { /* block id: 29 */
        int32_t l_68 = (-5);
        uint32_t l_82 = 0x2C75BC62;
        struct S0 **l_151 = &l_102;
        int32_t l_185 = 0x16DF6E39;
        int32_t * const *l_222 = &l_142;
        for (p_47.f4 = (-21); (p_47.f4 == (-30)); p_47.f4 = safe_sub_func_uint32_t_u_u(p_47.f4, 1))
        { /* block id: 32 */
            int32_t *l_66 = &g_39.f8;
            int32_t **l_67 = &g_5;
            (*l_66) = (!p_48.f5);
            (*l_66) = ((void*)0 != &g_5);
            (*l_67) = &g_6;
        }
        if (l_68)
            continue;
    }
    return p_48.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_39.f4
 * writes: g_39.f4 g_5
 */
inline static struct S1  func_49(int32_t * p_50)
{ /* block id: 10 */
    struct S1 l_55 = {1U};
    for (g_39.f4 = (-12); (g_39.f4 < (-16)); g_39.f4--)
    { /* block id: 13 */
        int32_t **l_54 = &g_5;
        (*l_54) = &g_6;
    }
    return l_55;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_2;
    csmith_sink_ = g_6;
    csmith_sink_ = g_19.f0;
    csmith_sink_ = g_39.f0;
    csmith_sink_ = g_39.f1;
    csmith_sink_ = g_39.f2;
    csmith_sink_ = g_39.f3;
    csmith_sink_ = g_39.f4;
    csmith_sink_ = g_39.f5;
    csmith_sink_ = g_39.f6;
    csmith_sink_ = g_39.f7;
    csmith_sink_ = g_39.f8;
    csmith_sink_ = g_39.f9;
    csmith_sink_ = g_121.f0;
    csmith_sink_ = g_121.f1;
    csmith_sink_ = g_121.f2;
    csmith_sink_ = g_121.f3;
    csmith_sink_ = g_121.f4;
    csmith_sink_ = g_121.f5;
    csmith_sink_ = g_121.f6;
    csmith_sink_ = g_121.f7;
    csmith_sink_ = g_121.f8;
    csmith_sink_ = g_121.f9;
    csmith_sink_ = g_146;
    csmith_sink_ = g_197;
    csmith_sink_ = g_254.f0;
    csmith_sink_ = g_390;
    csmith_sink_ = g_406.f0;
    csmith_sink_ = g_406.f1;
    csmith_sink_ = g_406.f2;
    csmith_sink_ = g_406.f3;
    csmith_sink_ = g_406.f4;
    csmith_sink_ = g_406.f5;
    csmith_sink_ = g_406.f6;
    csmith_sink_ = g_406.f7;
    csmith_sink_ = g_406.f8;
    csmith_sink_ = g_406.f9;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 97
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 21
breakdown:
   indirect level: 0, occurrence: 12
   indirect level: 1, occurrence: 2
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 10
XXX times a bitfields struct on LHS: 8
XXX times a bitfields struct on RHS: 18
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 16

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 152
   depth: 2, occurrence: 19
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1

XXX total number of pointers: 110

XXX times a variable address is taken: 119
XXX times a pointer is dereferenced on RHS: 45
breakdown:
   depth: 1, occurrence: 26
   depth: 2, occurrence: 18
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 74
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 12
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 270

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 121
   level: 2, occurrence: 59
   level: 3, occurrence: 39
   level: 4, occurrence: 8
XXX number of pointers point to pointers: 56
XXX number of pointers point to scalars: 28
XXX number of pointers point to structs: 26
XXX percent of pointers has null in alias set: 20
XXX average alias set size: 1.25

XXX times a non-volatile is read: 451
XXX times a non-volatile is write: 214
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 115
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 29
   depth: 2, occurrence: 19
   depth: 3, occurrence: 18
   depth: 4, occurrence: 11
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 22.7
XXX percentage an existing variable is used: 77.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

