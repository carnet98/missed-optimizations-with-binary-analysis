/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --no-bitfields --checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --jumps --longlong --force-non-uniform-arrays --no-math64 --no-muls --no-packed-struct --paranoid --pointers --structs --inline-function --no-return-structs --no-arg-structs --no-dangling-global-pointers
 * Seed:      809537560
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_15 = 0xA97963BAL;
static int32_t *g_14 = &g_15;
static uint32_t g_97 = 0x8F7D061DL;
static struct S0 g_107 = {0x198F9F05L};
static int32_t *** const g_110 = (void*)0;
static struct S0 *g_115 = (void*)0;
static struct S0 **g_114 = &g_115;
static int16_t g_179 = 0x7AFDL;
static int32_t g_200 = 1L;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
inline static int32_t * func_3(uint8_t  p_4, int32_t * p_5, uint16_t  p_6);
inline static int32_t * func_7(int8_t  p_8, int32_t * p_9, int32_t * p_10, const int32_t * p_11, int32_t * p_12);
inline static int32_t * func_16(int16_t  p_17, int32_t  p_18, int8_t  p_19, uint8_t  p_20, uint8_t  p_21);
inline static int16_t  func_22(int32_t  p_23, int32_t  p_24, const int32_t * p_25, uint32_t  p_26);
static uint32_t  func_29(int32_t  p_30, int32_t * p_31, uint32_t  p_32, const int32_t * p_33, int32_t  p_34);
inline static int8_t  func_42(int32_t * p_43, int32_t * p_44, int16_t  p_45);
static int8_t  func_46(int8_t  p_47, uint16_t  p_48, int16_t  p_49, uint8_t  p_50, int32_t * p_51);
static int32_t * func_56(int32_t  p_57, int16_t  p_58, uint32_t  p_59);
inline static int32_t * const  func_62(int32_t * const  p_63, uint32_t  p_64);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_14 g_15 g_97 g_107 g_110 g_179 g_200
 * writes: g_15 g_97 g_107 g_114 g_14 g_200
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int16_t l_2 = 0L;
    int32_t *l_35 = &g_15;
    uint32_t l_181 = 0UL;
    int32_t *l_199 = &g_200;
    const int32_t **l_222 = (void*)0;
    const int32_t ***l_221 = &l_222;
    const int32_t ****l_220 = &l_221;
    const struct S0 *l_287 = &g_107;
    const struct S0 **l_286 = &l_287;
    int16_t l_325 = 1L;
    uint16_t l_327 = 0x0EC0L;
    uint32_t l_385 = 2UL;
    int32_t **l_419 = &l_199;
    int8_t l_426 = 0x09L;
    int8_t l_431 = 0L;
    if (l_2)
    { /* block id: 1 */
        int8_t l_13 = 0xC3L;
        int8_t l_184 = 0xC1L;
        int32_t *l_219 = &g_15;
        struct S0 l_223 = {0xFC68CCC0L};
        int16_t l_248 = (-10L);
        uint16_t l_281 = 0UL;
        struct S0 *l_364 = &l_223;
        int32_t **l_370 = (void*)0;
        int32_t ***l_369 = &l_370;
        int32_t ****l_368 = &l_369;
        int32_t *****l_367 = &l_368;
        l_219 = func_3(l_2, func_7(l_13, g_14, func_16(func_22(l_2, (safe_rshift_func_int16_t_s_s((func_29(g_15, l_35, (*l_35), &g_15, (l_13 == g_15)) <= l_13), l_13)), g_14, l_181), l_184, g_179, g_179, g_179), g_14, l_199), g_179);
        /* statement id: 123 */
        assert (g_14 == &g_200);
        //assert (g_114 == &g_115 || g_114 == dangling);
        if ((l_220 != (void*)0))
        { /* block id: 124 */
            struct S0 *l_224 = &g_107;
            int32_t l_233 = (-1L);
            (*l_221) = (*l_221);
            (*l_224) = l_223;
            (*l_224) = l_223;
            (*l_35) = ((((safe_sub_func_int8_t_s_s((((((((safe_rshift_func_uint8_t_u_s((safe_add_func_uint32_t_u_u(((*l_199) & (((((safe_sub_func_uint32_t_u_u(l_233, (((&g_200 != (void*)0) && (((0x95CBA6E2L == ((((safe_add_func_uint8_t_u_u(0x24L, (safe_lshift_func_int8_t_s_s((safe_mod_func_int16_t_s_s((safe_rshift_func_int8_t_s_s((((((~(0x66L & (safe_add_func_uint16_t_u_u((safe_add_func_int16_t_s_s(((g_200 < (safe_unary_minus_func_uint32_t_u((((((g_107.f0 <= g_200) && l_233) <= g_200) | (*l_35)) >= (*l_35))))) == g_107.f0), 0x994EL)), (*l_35))))) >= 0x0F1CL) && g_179) == 0xB8L) >= 0x7AL), (*l_199))), g_179)), 4)))) ^ g_107.f0) || 2UL) == 0x1DA6L)) == 0L) > (*l_219))) <= g_200))) == (*l_219)) <= 0x3C1EEC73L) & l_233) | g_15)), l_233)), 7)) <= (*l_199)) || (-5L)) != 0UL) & (*l_219)) || g_200) & (*l_219)), g_15)) && (-2L)) | g_107.f0) != l_248);
        }
        else
        { /* block id: 129 */
            int32_t l_264 = 0L;
            int32_t *l_266 = (void*)0;
            uint32_t l_306 = 0x37CD8EF8L;
            int32_t l_326 = 0xB96F827CL;
            int32_t *****l_371 = &l_368;
            for (l_223.f0 = 0; (l_223.f0 != 7); ++l_223.f0)
            { /* block id: 132 */
                uint16_t l_259 = 65528UL;
                int32_t **l_268 = &l_199;
                int32_t ***l_267 = &l_268;
                struct S0 l_283 = {0L};
                uint32_t l_344 = 0UL;
                struct S0 *** const l_348 = &g_114;
                uint16_t l_357 = 0xA03AL;
                if (((safe_sub_func_uint16_t_u_u((safe_sub_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s(((((65527UL < (((g_15 && (safe_add_func_int16_t_s_s(l_259, ((safe_add_func_uint16_t_u_u(((safe_sub_func_uint8_t_u_u((g_110 == (void*)0), g_179)) != l_264), (~0x99L))) == 0L)))) && 0x4B4AL) <= l_259)) == g_200) <= 0xE2L) & (*g_14)), g_179)), g_200)), l_264)) > l_259))
                { /* block id: 133 */
                    int16_t l_280 = 0xC39BL;
                    struct S0 l_282 = {0x9CE5FD47L};
                    int32_t *l_289 = &g_15;
                    l_219 = l_266;
                    /* statement id: 134 */
                    assert (l_219 == 0);
                    if ((l_267 == &l_268))
                    { /* block id: 135 */
                        return g_15;
                    }
                    else
                    { /* block id: 137 */
                        int32_t **l_269 = &l_266;
                        (*l_269) = func_62(l_35, ((l_248 <= 0L) == (-6L)));
                        /* statement id: 138 */
                        assert (l_266 == &g_15);
                        (**l_269) = ((((((safe_rshift_func_uint8_t_u_s(g_179, ((*l_35) ^ (safe_mod_func_uint8_t_u_u(g_179, (((safe_mod_func_int16_t_s_s((-8L), (***l_267))) < (safe_sub_func_int16_t_s_s(((((void*)0 != g_110) ^ (0x844AFDE6L >= (safe_mod_func_int16_t_s_s((***l_267), 0x093AL)))) & (*l_266)), l_280))) & g_15)))))) <= l_281) | (***l_267)) != (**l_269)) <= 0x3399L) < g_179);
                        l_283 = l_282;
                    }
                    /* facts after branching */
                    assert (l_266 == &g_15);
                    for (l_181 = 0; (l_181 != 50); l_181++)
                    { /* block id: 144 */
                        (***l_267) = (0x5C18L >= g_200);
                    }
                    if ((*l_266))
                    { /* block id: 147 */
                        if ((*g_14))
                            break;
                        (**l_267) = (**l_267);
                        return (*l_35);
                    }
                    else
                    { /* block id: 151 */
                        const struct S0 ***l_288 = &l_286;
                        int32_t l_290 = 1L;
                        (*l_288) = l_286;
                        (**l_267) = func_3((*l_266), l_289, (*l_266));
                        /* statement id: 153 */
                        assert (l_199 == &g_15);
                        (*l_289) = l_290;
                    }
                    /* facts after branching */
                    assert (l_199 == &g_15);
                }
                else
                { /* block id: 156 */
                    uint32_t l_291 = 18446744073709551610UL;
                    struct S0 l_345 = {0x5CEA9568L};
                    int32_t l_356 = 0x5C657153L;
                    if (l_291)
                        break;
                    for (l_181 = (-26); (l_181 >= 11); l_181 = safe_add_func_uint8_t_u_u(l_181, 7))
                    { /* block id: 160 */
                        (*l_219) = (g_179 == (safe_add_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((safe_mod_func_int8_t_s_s((***l_267), ((*l_219) | (safe_add_func_uint32_t_u_u(1UL, (*g_14)))))), (safe_rshift_func_int16_t_s_s(((l_219 == l_219) == (g_15 ^ (safe_mod_func_int16_t_s_s(g_179, g_179)))), l_306)))), (*l_35))));
                    }
                    if (((safe_rshift_func_int8_t_s_u((0x3A13L <= ((safe_add_func_uint8_t_u_u((~((safe_mod_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((g_97 == 1L), (safe_unary_minus_func_int32_t_s((safe_sub_func_int8_t_s_s((safe_unary_minus_func_int32_t_s((0L || (((((safe_rshift_func_int8_t_s_s((l_291 < ((g_179 < (((((safe_mod_func_int32_t_s_s((((((g_200 > g_97) | (safe_unary_minus_func_int16_t_s(0xCA0AL))) || 0UL) && g_179) && g_200), g_107.f0)) < 0xF59B29B8L) == g_200) <= g_200) <= (***l_267))) | l_291)), 1)) != l_325) == (***l_267)) == l_326) >= l_327)))), (-1L))))))), g_200)) < 0x11L)), g_107.f0)) & 0xA78CL)), l_291)) > 255UL))
                    { /* block id: 163 */
                        (***l_267) = (((safe_lshift_func_uint16_t_u_u((safe_rshift_func_int8_t_s_s(((((safe_rshift_func_int8_t_s_s((&g_114 == &g_114), 7)) & ((g_200 | 0L) & ((0x469CL > g_200) == (safe_add_func_int16_t_s_s(0xE9D3L, (safe_sub_func_int32_t_s_s((safe_rshift_func_uint8_t_u_u((*l_35), 6)), (safe_mod_func_uint32_t_u_u((safe_rshift_func_int16_t_s_u(l_344, (*l_219))), (-2L)))))))))) <= (*l_219)) == (*l_199)), 4)), (*l_199))) ^ g_179) == 0x092FL);
                        if ((*l_219))
                            continue;
                    }
                    else
                    { /* block id: 166 */
                        uint16_t l_353 = 0x3CD4L;
                        g_107 = l_345;
                        (*g_14) = (safe_add_func_int8_t_s_s((l_348 != (void*)0), (((0x2600L && (safe_lshift_func_uint8_t_u_s(l_291, (l_353 < g_200)))) | ((0x8C5570C8L & l_345.f0) == (safe_rshift_func_uint16_t_u_s((((l_353 > 0x7143L) > g_200) | l_356), g_107.f0)))) <= g_97)));
                    }
                }
                /* facts after branching */
                assert (l_199 == &g_200 || l_199 == &g_15);
                assert (l_219 == &g_15 || l_219 == 0);
                assert (l_266 == 0 || l_266 == &g_15);
                (*g_14) = ((l_357 & (safe_mod_func_int16_t_s_s(1L, (((safe_lshift_func_int16_t_s_s(((**l_268) & 0xD0E0L), 8)) < 0xDDD2L) & ((0x3FE6L == ((void*)0 == l_364)) != (&g_110 != &g_110)))))) > g_200);
                (*l_35) = (safe_sub_func_uint8_t_u_u(((((void*)0 == &g_114) && ((*l_221) == (void*)0)) > (0x57L != g_97)), (g_97 || g_179)));
                return (**l_268);
            }
            /* facts after for loop */
            assert (l_219 == 0 || l_219 == &g_15);
            assert (l_266 == &g_15 || l_266 == 0);
            l_371 = l_367;
        }
        /* facts after branching */
        assert (l_219 == 0 || l_219 == &g_15);
    }
    else
    { /* block id: 177 */
        const int32_t *l_372 = &g_200;
        int32_t *l_373 = &g_200;
        l_373 = func_7(g_200, l_199, &g_15, l_372, l_373);
        /* statement id: 178 */
        assert (g_14 == &g_200);
    }
    /* facts after branching */
    assert (g_14 == &g_200);
    //assert (g_114 == &g_115 || g_114 == dangling);
    if (((g_110 != g_110) || (safe_lshift_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u(g_107.f0, (((safe_sub_func_uint16_t_u_u(((g_179 >= ((safe_rshift_func_int16_t_s_s(((((safe_add_func_int16_t_s_s(((*l_35) ^ (+(((*g_14) == ((*l_35) <= (g_97 ^ (g_200 <= g_200)))) == g_179))), g_15)) ^ g_97) & (-5L)) > (*g_14)), g_200)) == l_385)) && g_97), (*l_199))) && 0xE1AD3946L) > g_97))), 14))))
    { /* block id: 180 */
        struct S0 l_386 = {0x62D46D31L};
        struct S0 *l_387 = &g_107;
        int32_t **l_397 = (void*)0;
        uint8_t l_402 = 253UL;
        const int32_t *l_403 = (void*)0;
        int32_t **l_404 = &l_199;
        uint16_t l_411 = 0UL;
        (*l_387) = l_386;
        (*l_404) = func_7((safe_rshift_func_uint8_t_u_s(255UL, 5)), &g_15, func_56(g_15, ((safe_rshift_func_int8_t_s_s((-1L), 2)) >= (((+(((&g_110 == (void*)0) > (safe_sub_func_int16_t_s_s(((&g_14 != l_397) > (((safe_add_func_int8_t_s_s((safe_rshift_func_int16_t_s_u(0L, 3)), g_97)) && l_402) == g_15)), g_200))) & (-1L))) & g_97) > l_402)), g_97), l_403, l_35);
        /* statement id: 182 */
        assert (g_14 == &g_15);
        assert (l_199 == &g_15);
        (*l_35) = ((**l_404) & ((safe_lshift_func_uint8_t_u_s((safe_rshift_func_int8_t_s_u((-1L), (safe_mod_func_int16_t_s_s(((**l_404) >= (l_411 && ((safe_add_func_uint8_t_u_u((&g_107 == (void*)0), ((!g_15) && g_107.f0))) && (((safe_add_func_int32_t_s_s(((g_107.f0 || 0UL) | g_15), (*l_35))) >= g_179) == g_107.f0)))), g_15)))), 0)) >= g_200));
        (*l_404) = (*l_404);
    }
    else
    { /* block id: 185 */
        int16_t l_417 = 1L;
        int32_t **l_418 = &g_14;
        (*l_418) = func_3(l_417, func_3((l_417 || l_417), &g_200, g_107.f0), g_97);
        return (**l_418);
    }
    /* facts after branching */
    assert (g_14 == &g_15);
    assert (l_199 == &g_15);
    (*l_419) = l_199;
    (*l_419) = func_56(g_15, g_200, (safe_add_func_uint16_t_u_u((g_200 && g_15), (safe_rshift_func_uint8_t_u_s(((((4L != (safe_rshift_func_uint8_t_u_u(l_426, 5))) | (*g_14)) | (((safe_sub_func_uint16_t_u_u(((*l_35) <= (&g_200 != (void*)0)), l_431)) >= (*l_199)) < (*l_199))) != (*l_199)), g_200)))));
    return g_97;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_3(uint8_t  p_4, int32_t * p_5, uint16_t  p_6)
{ /* block id: 120 */
    struct S0 l_217 = {-2L};
    int32_t *l_218 = &l_217.f0;
    l_217 = l_217;
    return p_5;
    /* statement id: 122 */
    //assert (func_3_rv == &g_15 || func_3_rv == &g_200);
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_200 g_179 g_14
 * writes: g_15 g_14
 */
inline static int32_t * func_7(int8_t  p_8, int32_t * p_9, int32_t * p_10, const int32_t * p_11, int32_t * p_12)
{ /* block id: 114 */
    uint32_t l_209 = 0x72FA3325L;
    uint8_t l_212 = 0x1BL;
    int32_t **l_213 = &g_14;
    struct S0 l_214 = {-5L};
    struct S0 *l_215 = &l_214;
    (*l_213) = func_56(((-1L) >= (safe_mod_func_int8_t_s_s((((safe_sub_func_int32_t_s_s((safe_sub_func_uint8_t_u_u(((p_8 && ((safe_mod_func_int16_t_s_s(p_8, g_15)) == (l_209 == ((((void*)0 == &g_110) >= g_200) & ((safe_sub_func_int8_t_s_s(((((0xA6F5L <= g_200) & 0xDC2514DCL) <= g_15) <= l_209), p_8)) || g_179))))) >= p_8), 1UL)), (-4L))) & l_212) & l_212), l_212))), g_179, p_8);
    /* statement id: 115 */
    assert (g_14 == &g_15);
    if (l_212)
        goto lbl_216;
lbl_216:
    (*l_215) = l_214;
    (*l_213) = p_12;
    /* statement id: 118 */
    assert (g_14 == &g_200 || g_14 == &g_15);
    return p_9;
    /* statement id: 119 */
    //assert (func_7_rv == &g_15 || func_7_rv == &g_200);
}


/* ------------------------------------------ */
/* 
 * reads : g_179 g_97 g_14 g_107.f0 g_15
 * writes: g_15 g_97
 */
inline static int32_t * func_16(int16_t  p_17, int32_t  p_18, int8_t  p_19, uint8_t  p_20, uint8_t  p_21)
{ /* block id: 95 */
    uint8_t l_187 = 255UL;
    int32_t ***l_191 = (void*)0;
    int32_t *l_198 = &g_15;
    for (p_21 = 0; (p_21 >= 31); p_21++)
    { /* block id: 98 */
        const int32_t * const *l_189 = (void*)0;
        const int32_t * const **l_188 = &l_189;
        int32_t *l_193 = &g_15;
        int32_t **l_192 = &l_193;
        (*g_14) = (((g_179 >= 1L) >= ((l_187 & p_21) != (p_17 <= ((void*)0 != l_188)))) & ((!((l_191 == (void*)0) && g_97)) && g_97));
        (*l_192) = func_56(p_21, g_107.f0, p_20);
        for (p_19 = 0; (p_19 > 13); p_19 = safe_add_func_uint16_t_u_u(p_19, 8))
        { /* block id: 103 */
            (*l_192) = (void*)0;
            /* statement id: 104 */
            assert (l_193 == 0);
            for (g_97 = 1; (g_97 >= 18); g_97 = safe_add_func_uint8_t_u_u(g_97, 1))
            { /* block id: 107 */
                (*l_192) = &g_15;
                /* statement id: 108 */
                assert (l_193 == &g_15);
            }
            /* facts after for loop */
            assert (l_193 == &g_15 || l_193 == 0);
        }
        /* facts after for loop */
        assert (l_193 == &g_15 || l_193 == 0);
        p_18 = (*g_14);
    }
    return l_198;
    /* statement id: 113 */
    //assert (func_16_rv == &g_15);
}


/* ------------------------------------------ */
/* 
 * reads : g_179
 * writes:
 */
inline static int16_t  func_22(int32_t  p_23, int32_t  p_24, const int32_t * p_25, uint32_t  p_26)
{ /* block id: 88 */
    for (p_26 = 0; (p_26 <= 1); p_26 = safe_add_func_uint32_t_u_u(p_26, 3))
    { /* block id: 91 */
        return g_179;
    }
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_14 g_97 g_107 g_110 g_179
 * writes: g_15 g_97 g_107 g_114
 */
static uint32_t  func_29(int32_t  p_30, int32_t * p_31, uint32_t  p_32, const int32_t * p_33, int32_t  p_34)
{ /* block id: 2 */
    int32_t *l_40 = &g_15;
    int32_t **l_180 = &l_40;
    (*p_31) = ((safe_add_func_int16_t_s_s((safe_add_func_uint8_t_u_u((0x6AC3L > (l_40 == &g_15)), ((~(func_42(&g_15, l_40, ((((-3L) && ((0x9EL ^ func_46(p_30, (safe_rshift_func_uint16_t_u_u(((void*)0 == &g_15), p_34)), g_15, g_15, l_40)) == p_32)) > g_97) | 0xB7L)) & g_179)) < p_32))), p_34)) <= 7UL);
    /* statement id: 85 */
    //assert (g_114 == &g_115 || g_114 == dangling);
    (*l_180) = l_40;
    return (**l_180);
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_97 g_107 g_110 g_14
 * writes: g_97 g_107 g_114 g_15
 */
inline static int8_t  func_42(int32_t * p_43, int32_t * p_44, int16_t  p_45)
{ /* block id: 20 */
    int32_t *l_100 = (void*)0;
    struct S0 *l_113 = (void*)0;
    struct S0 **l_112 = &l_113;
    const int32_t l_160 = (-1L);
    int32_t **l_167 = &l_100;
    int32_t ***l_166 = &l_167;
    int32_t ****l_165 = &l_166;
    struct S0 l_177 = {1L};
    struct S0 *l_178 = &g_107;
    if ((safe_mod_func_int32_t_s_s(((void*)0 == l_100), (*p_43))))
    { /* block id: 21 */
        int32_t **l_101 = &l_100;
        (*l_101) = p_44;
        /* statement id: 22 */
        assert (l_100 == &g_15);
    }
    else
    { /* block id: 23 */
        struct S0 l_116 = {3L};
        int32_t l_131 = 0x7C3E796DL;
        int32_t **l_154 = (void*)0;
        int32_t **l_155 = &l_100;
        for (g_97 = 0; (g_97 < 52); g_97 = safe_add_func_uint8_t_u_u(g_97, 7))
        { /* block id: 26 */
            int32_t **l_106 = (void*)0;
            int32_t ***l_105 = &l_106;
            int32_t ****l_104 = &l_105;
            struct S0 *l_108 = &g_107;
            int32_t **l_117 = &l_100;
            (*l_104) = (void*)0;
            /* statement id: 27 */
            assert (l_105 == 0);
            (*l_108) = g_107;
            if (((!(((g_110 == g_110) < ((!(&g_14 != &l_100)) >= ((void*)0 != l_108))) == 0L)) < 0x7357609EL))
            { /* block id: 29 */
                g_114 = l_112;
                /* statement id: 30 */
                assert (g_114 == &l_113);
                (*g_14) = (*p_44);
            }
            else
            { /* block id: 32 */
                l_116 = l_116;
            }
            (*l_117) = &g_15;
            /* statement id: 35 */
            assert (l_100 == &g_15);
        }
        /* facts after for loop */
        assert (l_100 == &g_15 || l_100 == 0);
        assert (g_114 == &g_115 || g_114 == &l_113);
        for (l_116.f0 = (-3); (l_116.f0 > (-23)); --l_116.f0)
        { /* block id: 39 */
            struct S0 l_139 = {1L};
            l_112 = &g_115;
            /* statement id: 40 */
            assert (l_112 == &g_115);
            for (g_15 = 6; (g_15 == 23); g_15 = safe_add_func_uint32_t_u_u(g_15, 1))
            { /* block id: 43 */
                uint16_t l_130 = 65535UL;
                l_131 = (0xE6DEL & (((p_45 ^ (safe_sub_func_uint8_t_u_u((((safe_add_func_uint16_t_u_u(l_116.f0, (safe_rshift_func_int16_t_s_u((0x2B86L >= 0xEF14L), (safe_sub_func_int32_t_s_s(((((void*)0 != &l_113) || (253UL ^ ((0x70L < 1L) && (-7L)))) ^ l_130), (*p_44))))))) != (*p_43)) | 0xEEL), 247UL))) >= g_15) == p_45));
                return l_130;
                /* statement id: 45 */
                //assert (g_114 == &g_115 || g_114 == dangling);
            }
            if ((*p_43))
            { /* block id: 47 */
                int32_t **l_132 = &l_100;
                (*l_132) = p_43;
                /* statement id: 48 */
                assert (l_100 == &g_15);
                return p_45;
                /* statement id: 49 */
                //assert (g_114 == &g_115 || g_114 == dangling);
            }
            else
            { /* block id: 50 */
                uint8_t l_148 = 0xCEL;
                struct S0 l_149 = {0x6E8D0335L};
                const struct S0 **l_152 = (void*)0;
                int32_t **l_153 = &l_100;
                for (l_131 = 0; (l_131 != (-5)); l_131 = safe_sub_func_int8_t_s_s(l_131, 5))
                { /* block id: 53 */
                    (*p_44) = (&g_115 == (void*)0);
                }
                for (l_131 = 0; (l_131 <= 27); l_131 = safe_add_func_uint16_t_u_u(l_131, 5))
                { /* block id: 58 */
                    int32_t **l_150 = &l_100;
                    for (g_107.f0 = (-28); (g_107.f0 >= 27); g_107.f0++)
                    { /* block id: 61 */
                        struct S0 *l_140 = &l_139;
                        (*l_140) = l_139;
                        (*g_14) = (safe_add_func_int16_t_s_s(((void*)0 != &l_139), ((!g_97) <= ((safe_rshift_func_int16_t_s_u((l_116.f0 && (((safe_sub_func_uint8_t_u_u(p_45, (l_148 | (l_139.f0 || g_97)))) && g_97) >= 0L)), 15)) > 65535UL))));
                        l_139 = l_149;
                        return p_45;
                        /* statement id: 65 */
                        //assert (g_114 == &g_115 || g_114 == dangling);
                    }
                    (*p_44) = (*p_44);
                    (*l_150) = p_44;
                    /* statement id: 68 */
                    assert (l_100 == &g_15);
                    return p_45;
                    /* statement id: 69 */
                    //assert (g_114 == &g_115 || g_114 == dangling);
                }
                (*l_153) = func_56((!(l_152 != &g_115)), p_45, g_15);
                /* statement id: 71 */
                assert (l_100 == &g_15);
                if ((*p_43))
                    continue;
            }
            /* facts after branching */
            assert (l_100 == &g_15);
        }
        /* facts after for loop */
        assert (l_112 == &g_115 || l_112 == &l_113);
        (*l_155) = l_100;
    }
    /* facts after branching */
    assert (l_100 == &g_15 || l_100 == 0);
    assert (l_112 == &g_115 || l_112 == &l_113);
    assert (g_114 == &g_115 || g_114 == &l_113);
    if (((safe_sub_func_int16_t_s_s(0L, (safe_add_func_int32_t_s_s(l_160, l_160)))) & g_97))
    { /* block id: 77 */
        return g_107.f0;
        /* statement id: 78 */
        //assert (g_114 == &g_115 || g_114 == dangling);
    }
    else
    { /* block id: 79 */
        int32_t ***l_176 = &l_167;
        (*g_14) = ((safe_lshift_func_int16_t_s_u((safe_mod_func_int16_t_s_s(((((((void*)0 != l_165) >= (safe_add_func_uint16_t_u_u(((p_45 == ((*p_43) >= (&p_43 == (**l_165)))) ^ ((safe_rshift_func_uint8_t_u_u(g_97, 1)) || (safe_rshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_u((l_176 != l_176), g_107.f0)), p_45)))), 0UL))) <= g_107.f0) | g_97) <= g_15), 2L)), g_97)) && p_45);
        (***l_165) = p_43;
        /* statement id: 81 */
        assert (l_100 == &g_15);
    }
    /* facts after branching */
    assert (l_100 == &g_15);
    (*l_178) = l_177;
    return p_45;
    /* statement id: 84 */
    //assert (g_114 == &g_115 || g_114 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_14
 * writes: g_15
 */
static int8_t  func_46(int8_t  p_47, uint16_t  p_48, int16_t  p_49, uint8_t  p_50, int32_t * p_51)
{ /* block id: 3 */
    uint16_t l_95 = 2UL;
    int32_t l_96 = 0x5FFFC42EL;
    for (p_50 = (-7); (p_50 == 28); p_50 = safe_add_func_int8_t_s_s(p_50, 8))
    { /* block id: 6 */
        int8_t l_60 = (-8L);
        uint32_t l_61 = 18446744073709551615UL;
        int32_t *l_79 = &g_15;
        int32_t **l_78 = &l_79;
        (*l_78) = func_56(l_60, l_61, ((2UL <= l_60) ^ l_60));
        (*p_51) = (safe_sub_func_int32_t_s_s((((*l_79) <= ((void*)0 != &g_15)) != (safe_lshift_func_uint16_t_u_s(((~(((((**l_78) <= (safe_sub_func_int16_t_s_s((safe_sub_func_int32_t_s_s((p_47 < (~(p_49 != ((((safe_mod_func_uint32_t_u_u((((!0xB9L) != (safe_lshift_func_uint8_t_u_u((g_15 != ((0xD26DL < 0x125FL) & (**l_78))), 3))) == 0x186F270AL), l_95)) & l_96) | 0xD24A1705L) <= g_15)))), (*l_79))), p_48))) || 2UL) > g_15) && p_49)) == p_49), p_47))), (-2L)));
    }
    return g_15;
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_14
 * writes: g_15
 */
static int32_t * func_56(int32_t  p_57, int16_t  p_58, uint32_t  p_59)
{ /* block id: 7 */
    int32_t * const l_65 = &g_15;
    int32_t *l_76 = &g_15;
    int32_t **l_75 = &l_76;
    int32_t **l_77 = &l_76;
    (*l_75) = func_62(l_65, ((*l_65) > 0x7067L));
    (*l_75) = (void*)0;
    /* statement id: 13 */
    assert (l_76 == 0);
    (*l_77) = func_62(func_62(&g_15, p_58), (g_14 == g_14));
    /* statement id: 14 */
    assert (l_76 == &g_15);
    return &g_15;
    /* statement id: 15 */
    //assert (func_56_rv == &g_15);
}


/* ------------------------------------------ */
/* 
 * reads : g_15
 * writes: g_15
 */
inline static int32_t * const  func_62(int32_t * const  p_63, uint32_t  p_64)
{ /* block id: 8 */
    int32_t *l_69 = &g_15;
    int32_t **l_74 = &l_69;
    (*l_69) = (!(safe_rshift_func_uint16_t_u_s((((((((void*)0 != l_69) >= ((void*)0 == &g_15)) && (safe_add_func_int8_t_s_s((l_69 == l_69), (p_63 != p_63)))) || (safe_rshift_func_uint8_t_u_s((0UL == p_64), g_15))) ^ g_15) == (*l_69)), (*l_69))));
    (*l_74) = p_63;
    return p_63;
    /* statement id: 11 */
    //assert (func_62_rv == &g_15);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    g_114 = 0;
    transparent_crc(g_15, "g_15", print_hash_value);
    transparent_crc(g_97, "g_97", print_hash_value);
    transparent_crc(g_107.f0, "g_107.f0", print_hash_value);
    transparent_crc(g_179, "g_179", print_hash_value);
    transparent_crc(g_200, "g_200", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 70
   depth: 1, occurrence: 12
XXX total union variables: 0

XXX max expression depth: 46
breakdown:
   depth: 1, occurrence: 134
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 8, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 14, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 30, occurrence: 1
   depth: 46, occurrence: 1

XXX total number of pointers: 91

XXX times a variable address is taken: 93
XXX times a pointer is dereferenced on RHS: 73
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 11
   depth: 3, occurrence: 6
XXX times a pointer is dereferenced on LHS: 55
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 3
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 245

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 169
   level: 2, occurrence: 30
   level: 3, occurrence: 24
   level: 4, occurrence: 8
XXX number of pointers point to pointers: 46
XXX number of pointers point to scalars: 35
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 20.9
XXX average alias set size: 1.19

XXX times a non-volatile is read: 497
XXX times a non-volatile is write: 146
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 118
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 23
   depth: 2, occurrence: 15
   depth: 3, occurrence: 16
   depth: 4, occurrence: 12
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 15.7
XXX percentage an existing variable is used: 84.3
********************* end of statistics **********************/

