/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --jumps --longlong --no-force-non-uniform-arrays --math64 --no-muls --no-packed-struct --paranoid --pointers --structs --inline-function --return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      398466504
 */

#include "csmith.h"

volatile uint64_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint32_t g_6 = 0xF8256A9EL;
static int32_t g_8 = (-3L);
static int32_t g_48 = 1L;
static int32_t ***g_52 = (void*)0;
static int32_t ****g_51 = &g_52;
static uint64_t g_64 = 0x12D4938140A9711FLL;
static int32_t *g_225 = &g_8;
static int32_t **g_224 = &g_225;
static int32_t *g_242 = (void*)0;
static uint8_t g_273 = 0x47L;
static int32_t *****g_345 = &g_51;


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
inline static int32_t * func_2(int64_t  p_3, uint32_t  p_4);
static int32_t  func_10(int16_t  p_11);
static int32_t * func_12(int32_t  p_13, int32_t  p_14, uint64_t  p_15, int32_t  p_16, int64_t  p_17);
inline static int32_t  func_20(uint32_t  p_21);
inline static int32_t  func_24(int32_t * const * p_25);
inline static int32_t ** func_26(uint8_t  p_27, int32_t ** p_28);
static int32_t *** const  func_33(uint32_t  p_34, int32_t *** p_35, const int16_t  p_36);
static int64_t  func_39(uint32_t  p_40, int64_t  p_41, int32_t ** p_42, int32_t *** p_43, int32_t *** p_44);
static int32_t ** func_46(int32_t ** p_47);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_8 g_64 g_273 g_51 g_52 g_224 g_225 g_48
 * writes: g_48 g_8 g_225 g_345
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    int64_t l_5 = (-2L);
    (*g_224) = func_2(l_5, g_6);
    /* statement id: 197 */
    assert (g_225 == &g_48);
    return l_5;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_64 g_273 g_51 g_52 g_224 g_225 g_48 g_6
 * writes: g_48 g_8 g_225 g_345
 */
inline static int32_t * func_2(int64_t  p_3, uint32_t  p_4)
{ /* block id: 1 */
    const int32_t *l_7 = &g_8;
    const int32_t **l_9 = &l_7;
    int8_t l_348 = 0x25L;
    int32_t *l_380 = &g_48;
    (*l_9) = l_7;
    l_348 = func_10(g_8);
    /* statement id: 193 */
    assert (g_225 == &g_48 || g_225 == &g_8);
    (*g_225) = (safe_div_func_int64_t_s_s((safe_rshift_func_int8_t_s_s(((((safe_add_func_uint32_t_u_u(((((((**l_9) != ((*l_7) && ((p_4 || (((safe_mod_func_uint8_t_u_u((((safe_sub_func_int8_t_s_s((+(safe_sub_func_int8_t_s_s(((4294967293UL && p_3) | ((g_6 < (safe_sub_func_uint8_t_u_u(0xD8L, 1L))) < (**l_9))), 0UL))), g_64)) & 9L) > (**l_9)), 0xE1L)) > p_4) > p_3)) < p_4))) >= 0x5BL) & p_4) && g_273) == (*l_7)), (*l_7))) && g_273) <= 0x4FA59629L) != (*g_225)), (*l_7))), 1L));
    (*g_225) = ((((p_3 == ((**l_9) >= (((safe_unary_minus_func_int32_t_s(((safe_mod_func_uint32_t_u_u(g_64, (~((safe_sub_func_int64_t_s_s(g_273, (safe_div_func_uint32_t_u_u(((safe_rshift_func_int16_t_s_u((*l_7), p_4)) && (safe_add_func_int32_t_s_s((p_4 & (safe_lshift_func_uint8_t_u_s((((g_273 == (&l_9 == (*g_51))) & (**l_9)) && (*l_7)), p_3))), (**g_224)))), (-3L))))) < p_4)))) & g_48))) == (**l_9)) >= g_8))) <= p_4) > 1L) == g_273);
    return l_380;
    /* statement id: 196 */
    //assert (func_2_rv == &g_48);
}


/* ------------------------------------------ */
/* 
 * reads : g_64 g_8 g_273 g_51 g_52 g_224 g_225 g_48
 * writes: g_48 g_8 g_225 g_345
 */
static int32_t  func_10(int16_t  p_11)
{ /* block id: 3 */
    uint8_t l_304 = 0x1FL;
    int32_t *****l_309 = &g_51;
    int32_t l_310 = 0L;
    (*g_224) = func_12((safe_rshift_func_uint16_t_u_u(1UL, 0)), func_20(p_11), ((((safe_div_func_uint32_t_u_u(((safe_rshift_func_uint8_t_u_u((safe_div_func_uint16_t_u_u((l_304 > g_64), (safe_sub_func_uint8_t_u_u(l_304, (((safe_add_func_uint16_t_u_u((l_309 != &g_51), ((-8L) | g_8))) && p_11) ^ (-1L)))))), l_304)) == g_8), l_304)) > 0L) != g_8) == g_273), p_11, l_310);
    if (p_11)
    { /* block id: 184 */
        uint16_t l_344 = 1UL;
        int32_t *l_346 = &g_48;
        l_344 = (-2L);
        g_345 = &g_51;
        l_346 = l_346;
        (*g_225) = p_11;
    }
    else
    { /* block id: 189 */
        int32_t *l_347 = &g_48;
        (*g_224) = l_347;
        /* statement id: 190 */
        assert (g_225 == &g_48);
    }
    /* facts after branching */
    assert (g_225 == &g_48 || g_225 == &g_8);
    return p_11;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_51 g_52 g_224 g_225 g_48 g_64 g_273
 * writes: g_48 g_8 g_225
 */
static int32_t * func_12(int32_t  p_13, int32_t  p_14, uint64_t  p_15, int32_t  p_16, int64_t  p_17)
{ /* block id: 163 */
    int16_t l_315 = 0x9B9EL;
    int32_t *l_316 = &g_8;
    int32_t ***** const l_317 = &g_51;
    p_13 = ((safe_div_func_int16_t_s_s((safe_sub_func_uint8_t_u_u(l_315, ((&p_13 == l_316) > (*l_316)))), ((l_317 == (void*)0) & ((*g_51) == (*g_51))))) != (safe_rshift_func_uint16_t_u_s((safe_lshift_func_int8_t_s_u((safe_sub_func_int64_t_s_s((safe_add_func_uint32_t_u_u((safe_unary_minus_func_int64_t_s((*l_316))), (**g_224))), g_8)), 6)), (*l_316))));
    for (l_315 = (-15); (l_315 >= (-25)); l_315 = safe_sub_func_uint16_t_u_u(l_315, 1))
    { /* block id: 167 */
        int8_t l_340 = 0xFFL;
        int32_t *l_341 = &g_8;
        for (g_48 = 0; (g_48 >= 12); g_48 = safe_add_func_int32_t_s_s(g_48, 2))
        { /* block id: 170 */
            uint8_t l_331 = 1UL;
            int32_t ***l_333 = &g_224;
            if (l_331)
                break;
            (**g_224) = (safe_unary_minus_func_uint64_t_u(((*l_316) <= (((l_333 == (void*)0) && ((0x030061F076C89BE4LL <= (safe_sub_func_uint16_t_u_u((safe_sub_func_uint64_t_u_u((&g_52 == (void*)0), (***l_333))), (safe_sub_func_int32_t_s_s((((-1L) || g_64) == g_273), l_340))))) & (*l_316))) & (-1L)))));
            (*g_224) = l_341;
            if ((*g_225))
                break;
        }
    }
    for (p_15 = (-24); (p_15 < 9); p_15 = safe_add_func_uint16_t_u_u(p_15, 7))
    { /* block id: 179 */
        if ((*g_225))
            break;
    }
    return l_316;
    /* statement id: 182 */
    //assert (func_12_rv == &g_8);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_20(uint32_t  p_21)
{ /* block id: 4 */
    int8_t l_297 = 1L;
    for (p_21 = (-7); (p_21 >= 35); p_21++)
    { /* block id: 7 */
        int32_t *l_30 = &g_8;
        int32_t **l_29 = &l_30;
        int32_t *l_296 = &g_48;
    }
    l_297 = 3L;
    return l_297;
}


/* ------------------------------------------ */
/* 
 * reads : g_8
 * writes: g_225
 */
inline static int32_t  func_24(int32_t * const * p_25)
{ /* block id: 156 */
    int32_t **l_295 = &g_225;
    (*l_295) = (*p_25);
    return (**p_25);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_8 g_51 g_52 g_64 g_48 g_224 g_225
 * writes: g_6 g_48 g_51 g_64 g_52 g_8
 */
inline static int32_t ** func_26(uint8_t  p_27, int32_t ** p_28)
{ /* block id: 8 */
    int32_t **l_38 = (void*)0;
    int32_t ***l_37 = &l_38;
    for (g_6 = 5; (g_6 <= 56); ++g_6)
    { /* block id: 11 */
        int32_t l_45 = 0L;
        int32_t ****l_147 = (void*)0;
        int32_t ****l_148 = &g_52;
        (*l_148) = func_33(g_8, l_37, (0x963EC58F5537C57FLL > func_39(g_6, l_45, func_46(p_28), g_52, &l_38)));
        /* statement id: 92 */
        assert (g_52 == &l_38);
        for (g_48 = (-6); (g_48 < (-12)); g_48--)
        { /* block id: 95 */
            const int32_t *l_151 = &g_8;
            const int32_t **l_152 = &l_151;
            int32_t **** const *l_163 = (void*)0;
            const uint8_t l_187 = 0xE5L;
            int32_t *l_223 = (void*)0;
            int8_t l_237 = 0x81L;
            int64_t l_278 = 6L;
        }
    }
    /* facts after for loop */
    assert (g_52 == &l_38 || g_52 == 0);
    for (g_64 = 0; (g_64 <= 58); g_64++)
    { /* block id: 151 */
        const uint64_t l_288 = 8UL;
        int32_t **l_289 = &g_225;
        int64_t l_294 = 0xF372E633990AE0B8LL;
        (**g_224) = (p_27 ^ 0xDA22L);
        (**p_28) = (safe_mod_func_int32_t_s_s((0xEE2EL ^ ((safe_sub_func_int16_t_s_s(0L, (safe_add_func_int32_t_s_s(l_288, (((l_289 != (*l_37)) < p_27) || (((-3L) <= g_64) || (safe_add_func_int16_t_s_s((safe_rshift_func_int16_t_s_s(g_8, g_6)), 0xACA5L)))))))) <= 0UL)), l_294));
    }
    return p_28;
    /* statement id: 155 */
    //assert (g_52 == dangling || g_52 == 0);
    //assert (func_26_rv == &l_30);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_48
 */
static int32_t *** const  func_33(uint32_t  p_34, int32_t *** p_35, const int16_t  p_36)
{ /* block id: 87 */
    int32_t *l_146 = &g_48;
    int32_t **l_145 = &l_146;
    (*l_145) = &g_48;
    (*l_145) = (*l_145);
    (*l_146) = 0L;
    return p_35;
    /* statement id: 91 */
    //assert (func_33_rv == &l_38);
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_64 g_48 g_6 l_30
 * writes: g_64 g_48
 */
static int64_t  func_39(uint32_t  p_40, int64_t  p_41, int32_t ** p_42, int32_t *** p_43, int32_t *** p_44)
{ /* block id: 21 */
    uint32_t l_72 = 1UL;
    const int32_t *l_88 = &g_48;
    const int32_t **l_87 = &l_88;
    const int32_t ***l_86 = &l_87;
    const int32_t ****l_85 = &l_86;
    const int32_t *****l_84 = &l_85;
    int32_t l_92 = (-7L);
    uint32_t l_94 = 0x0E7AF825L;
    uint16_t l_108 = 0x54CFL;
    uint32_t l_139 = 1UL;
    int32_t *l_144 = &g_48;
    if ((**p_42))
    { /* block id: 22 */
        int8_t l_67 = 1L;
        int32_t l_80 = 0xF8C0E5C5L;
        int32_t *l_102 = &l_92;
        int32_t **l_101 = &l_102;
        int32_t ***l_100 = &l_101;
        uint32_t l_106 = 18446744073709551615UL;
        l_80 = (safe_rshift_func_int16_t_s_s(((safe_sub_func_uint32_t_u_u((safe_rshift_func_uint8_t_u_u((((safe_mod_func_uint32_t_u_u(g_64, (safe_lshift_func_int16_t_s_s(0x0451L, l_67)))) < ((safe_sub_func_int16_t_s_s(((0x45CBL >= (safe_add_func_int8_t_s_s(l_72, (((!(safe_rshift_func_int8_t_s_u((g_8 <= (safe_lshift_func_uint16_t_u_u((((-1L) == (p_41 != ((safe_mod_func_int64_t_s_s(g_48, 0x559CDE89C674F989LL)) == p_41))) != 0x0AL), 8))), p_41))) != g_8) == 4L)))) && l_67), 1L)) && 0xAEC2B2A8F302D78BLL)) & l_67), p_41)), l_67)) <= g_6), 7));
        if ((((p_41 ^ 0x07L) | (((g_48 != ((!((safe_mod_func_int32_t_s_s(8L, ((l_84 != (void*)0) || ((p_41 == (*****l_84)) & (g_48 | (*l_88)))))) != 0xC4L)) != g_64)) | (-7L)) != p_41)) && 0x4BD9F5B60AA07078LL))
        { /* block id: 24 */
            for (l_80 = 28; (l_80 < 8); l_80 = safe_sub_func_uint16_t_u_u(l_80, 4))
            { /* block id: 27 */
                if ((*****l_84))
                    break;
            }
        }
        else
        { /* block id: 30 */
            uint16_t l_91 = 0x32C3L;
            int32_t *l_129 = &l_80;
            l_92 = (l_91 != g_6);
            l_80 = (!(l_94 == (-1L)));
            for (g_64 = (-9); (g_64 != 7); g_64 = safe_add_func_int64_t_s_s(g_64, 2))
            { /* block id: 35 */
                int32_t *l_109 = &g_8;
                if ((safe_add_func_uint32_t_u_u((0xCD2AL >= g_6), 0x73B00C6BL)))
                { /* block id: 36 */
                    int32_t *l_103 = &g_48;
                    if ((**p_42))
                        break;
                    l_92 = ((0x27L >= p_40) | (+(l_100 != (void*)0)));
                    (*l_87) = l_103;
                    /* statement id: 39 */
                    assert (l_88 == &g_48);
                }
                else
                { /* block id: 40 */
                    for (g_48 = 24; (g_48 <= (-28)); g_48 = safe_sub_func_int64_t_s_s(g_48, 3))
                    { /* block id: 43 */
                        (*l_102) = ((void*)0 == &p_42);
                    }
                }
                if (l_106)
                { /* block id: 47 */
                    int32_t *****l_107 = &g_51;
                    l_107 = (void*)0;
                    /* statement id: 48 */
                    assert (l_107 == 0);
                    if (((&l_85 == &g_51) > ((void*)0 == &g_51)))
                    { /* block id: 49 */
                        (****l_84) = (*p_42);
                        /* statement id: 50 */
                        assert (l_88 == &g_8);
                        (*l_102) = l_108;
                    }
                    else
                    { /* block id: 52 */
                        (***l_85) = l_109;
                        /* statement id: 53 */
                        assert (l_88 == &g_8);
                    }
                    /* facts after branching */
                    assert (l_88 == &g_8);
                }
                else
                { /* block id: 55 */
                    int32_t *l_114 = &g_8;
                    uint64_t l_126 = 0x5AC0CBF8205C77F5LL;
                    (***l_100) = (safe_div_func_uint32_t_u_u(g_8, (safe_rshift_func_uint16_t_u_u(65531UL, p_41))));
                    (****l_84) = l_114;
                    /* statement id: 57 */
                    assert (l_88 == &g_8);
                    (***l_100) = (l_91 | (g_64 < ((safe_rshift_func_int16_t_s_u(((**p_42) >= ((~(1L || ((safe_lshift_func_int16_t_s_s((+(((safe_rshift_func_uint8_t_u_u(((safe_mod_func_int16_t_s_s(0L, 0x18FFL)) > (p_41 | (((((safe_unary_minus_func_int16_t_s(((*l_109) | ((((-2L) ^ 8UL) & l_126) <= g_64)))) & 65535UL) <= (**l_87)) >= (*****l_84)) && 0x7EL))), (*l_114))) | (*l_109)) && p_41)), 7)) | l_91))) < p_40)), 1)) ^ 0x00EBL)));
                    (**l_101) = ((*l_102) | (safe_lshift_func_uint16_t_u_s((g_64 <= 0xAE2794C0L), g_8)));
                }
                /* facts after branching */
                assert (l_88 == &g_8);
                (****l_84) = l_129;
                /* statement id: 61 */
                assert (l_88 == &l_80);
                (*l_87) = (*p_42);
                /* statement id: 62 */
                assert (l_88 == &g_8);
            }
            /* facts after for loop */
            assert (l_88 == &g_8 || l_88 == &g_48);
            for (g_64 = 17; (g_64 <= 40); g_64 = safe_add_func_uint64_t_u_u(g_64, 2))
            { /* block id: 66 */
                return p_41;
            }
        }
        /* facts after branching */
        assert (l_88 == &g_8 || l_88 == &g_48);
    }
    else
    { /* block id: 70 */
        int32_t *l_132 = &l_92;
lbl_137:
        (*l_132) = (-4L);
        for (g_64 = 0; (g_64 <= 48); g_64 = safe_add_func_uint64_t_u_u(g_64, 3))
        { /* block id: 74 */
            int64_t l_138 = 0x487E53E2A5121EC5LL;
            for (p_40 = 21; (p_40 >= 8); p_40--)
            { /* block id: 77 */
                if (g_48)
                    goto lbl_137;
            }
            (***l_85) = (*p_42);
            /* statement id: 80 */
            assert (l_88 == &g_8);
            l_138 = ((**p_42) & 1UL);
            if ((**p_42))
                break;
        }
    }
    /* facts after branching */
    assert (l_88 == &g_8 || l_88 == &g_48);
    (*l_144) = (((void*)0 != (**l_85)) <= (((l_139 | (0x3DB6BE6058BBDFDCLL == (****l_85))) >= (&p_42 == (**l_84))) ^ (safe_sub_func_int64_t_s_s((safe_add_func_uint16_t_u_u(p_41, ((&p_43 == (void*)0) | g_64))), p_41))));
    return (*****l_84);
}


/* ------------------------------------------ */
/* 
 * reads : g_48 g_51 g_8 l_30
 * writes: g_48 g_51 l_30
 */
static int32_t ** func_46(int32_t ** p_47)
{ /* block id: 12 */
    int32_t *l_55 = &g_8;
    for (g_48 = (-30); (g_48 != (-3)); g_48++)
    { /* block id: 15 */
        int32_t *****l_53 = (void*)0;
        int32_t *****l_54 = &g_51;
        (*l_54) = g_51;
        if ((**p_47))
            break;
        (*p_47) = l_55;
    }
    return p_47;
    /* statement id: 20 */
    //assert (func_46_rv == &l_30);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_6;
    csmith_sink_ = g_8;
    csmith_sink_ = g_48;
    csmith_sink_ = g_64;
    csmith_sink_ = g_273;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 66
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 20
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 15, occurrence: 1
   depth: 22, occurrence: 2
   depth: 24, occurrence: 2
   depth: 27, occurrence: 1

XXX total number of pointers: 68

XXX times a variable address is taken: 67
XXX times a pointer is dereferenced on RHS: 64
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 25
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 4
XXX times a pointer is dereferenced on LHS: 45
breakdown:
   depth: 1, occurrence: 27
   depth: 2, occurrence: 11
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 336

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 94
   level: 2, occurrence: 68
   level: 3, occurrence: 49
   level: 4, occurrence: 51
   level: 5, occurrence: 14
XXX number of pointers point to pointers: 41
XXX number of pointers point to scalars: 27
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22.1
XXX average alias set size: 1.18

XXX times a non-volatile is read: 401
XXX times a non-volatile is write: 156
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 83
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 18
   depth: 2, occurrence: 13
   depth: 3, occurrence: 7
   depth: 4, occurrence: 10
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
********************* end of statistics **********************/

