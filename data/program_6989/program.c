/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --checksum --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --jumps --longlong --no-force-non-uniform-arrays --math64 --no-muls --no-packed-struct --paranoid --pointers --structs --inline-function --no-return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      301539550356654414
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 21;
   signed f1 : 22;
   unsigned : 0;
   signed f2 : 12;
   unsigned f3 : 11;
   unsigned f4 : 22;
   signed f5 : 28;
   signed f6 : 1;
   signed f7 : 1;
   unsigned f8 : 11;
};

struct S1 {
   unsigned f0 : 3;
   signed f1 : 13;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0x0585B7F3L;
static struct S1 g_91 = {1,-64};
static struct S0 g_108 = {594,-156,-39,23,1464,-12434,-0,0,39};
static struct S0 *g_107 = &g_108;
static int32_t g_110 = 0xDB2349D5L;
static int32_t *g_113 = &g_110;
static int32_t *g_131 = &g_110;
static struct S0 **g_195 = (void*)0;
static struct S0 ***g_194 = &g_195;
static struct S0 ****g_193 = &g_194;
static struct S0 *****g_282 = &g_193;
static int32_t **g_299 = &g_131;
static int32_t ***g_298 = &g_299;
static uint8_t g_301 = 255UL;
static struct S1 *g_341 = &g_91;
static struct S1 **g_340 = &g_341;
static struct S1 ***g_339 = &g_340;
static int32_t ****g_601 = &g_298;
static int32_t *****g_600 = &g_601;
static int16_t g_730 = (-1L);
static int64_t g_812 = 0xD94A2F449240F579LL;


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_1(void);
inline static int8_t  func_11(int8_t  p_12, int32_t  p_13, int32_t  p_14, uint64_t  p_15, uint32_t  p_16);
static int64_t  func_23(uint16_t  p_24, uint64_t  p_25, uint64_t  p_26, uint8_t  p_27, int8_t  p_28);
static uint32_t  func_37(uint32_t  p_38, uint16_t  p_39, int32_t  p_40, int64_t  p_41);
static int64_t  func_46(int32_t  p_47, uint16_t  p_48, uint64_t  p_49, int8_t  p_50);
inline static int8_t  func_57(uint8_t  p_58, uint32_t  p_59, uint32_t  p_60);
static int32_t * func_61(uint8_t  p_62, int64_t  p_63);
inline static int16_t  func_66(int32_t  p_67, int32_t * p_68);
static int32_t * func_75(int32_t  p_76, int32_t * p_77, uint32_t  p_78);
inline static int32_t * func_80(uint32_t  p_81, int32_t * p_82, int32_t  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_600 g_601 g_298 g_299 g_131
 * writes: g_2 g_131
 */
inline static uint32_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_19 = 255UL;
    int32_t l_668 = 0x2AC8987EL;
    int32_t l_682 = 0x794B96A3L;
    struct S1 *l_702 = &g_91;
    int32_t l_736 = 0x9016E25CL;
    for (g_2 = 0; (g_2 < 26); g_2++)
    { /* block id: 3 */
        uint64_t l_5 = 0xD9B4E94F934F545ELL;
        uint8_t l_20 = 0UL;
        struct S0 **l_614 = &g_107;
        uint32_t l_651 = 6UL;
        int32_t l_661 = 1L;
        int32_t *l_662 = (void*)0;
        struct S1 ***l_671 = &g_340;
        int8_t l_714 = (-7L);
        int8_t l_796 = 1L;
    }
    (****g_600) = (****g_600);
    (*g_299) = &l_668;
    /* statement id: 389 */
    assert (g_131 == &l_668);
    return l_682;
    /* statement id: 390 */
    //assert (g_131 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_298 g_299 g_108.f4 g_108.f5 g_108.f6 g_131 g_2 g_301 g_91.f1 g_108.f3 g_110 g_282 g_193 g_194 g_91.f0 g_108.f8
 * writes: g_131 g_194 g_110 g_108.f2
 */
inline static int8_t  func_11(int8_t  p_12, int32_t  p_13, int32_t  p_14, uint64_t  p_15, uint32_t  p_16)
{ /* block id: 283 */
    uint8_t l_525 = 0x15L;
    int8_t l_547 = 0xA6L;
    struct S0 **l_568 = (void*)0;
    uint64_t l_587 = 0xF500C49C08F4559BLL;
    int8_t l_588 = 0xA2L;
    (**g_298) = &g_2;
    /* statement id: 284 */
    assert (g_131 == &g_2);
    if (((safe_sub_func_int16_t_s_s((+((l_525 != (0xA9L < ((safe_rshift_func_int8_t_s_s(((safe_sub_func_int64_t_s_s((safe_sub_func_int16_t_s_s((safe_mod_func_uint64_t_u_u(g_108.f4, (safe_sub_func_int32_t_s_s(((((0xAEL >= ((safe_sub_func_uint32_t_u_u((((+(safe_div_func_uint8_t_u_u(l_525, g_108.f5))) != (safe_add_func_int16_t_s_s(g_108.f6, (l_525 == ((0x123CL <= 0x16E9L) < 4L))))) == 0xA5L), (**g_299))) >= p_16)) || g_301) & 0UL) & g_108.f4), l_547)))), l_547)), l_547)) == 5L), p_15)) <= l_525))) || 1L)), g_108.f5)) != 0x3DE3613CL))
    { /* block id: 285 */
        uint32_t l_556 = 0x1E547E43L;
        int64_t l_565 = (-1L);
        if ((((safe_div_func_int16_t_s_s((l_547 ^ (((0x55503377L != ((((safe_rshift_func_uint16_t_u_u(g_91.f1, 6)) != ((((safe_lshift_func_int16_t_s_u(((safe_div_func_uint16_t_u_u((l_556 & (safe_add_func_int32_t_s_s((safe_mod_func_uint64_t_u_u((((65535UL ^ 1UL) | (safe_add_func_int16_t_s_s((safe_rshift_func_int8_t_s_u(8L, (((l_565 > g_108.f3) | l_556) || 0x1574A506L))), g_301))) || (-1L)), p_13)), 1L))), 65530UL)) < 0x5DL), 1)) < p_14) != p_13) ^ g_110)) || l_565) < l_547)) ^ l_547) | l_556)), l_556)) & 0xB1D7L) & p_13))
        { /* block id: 286 */
            for (p_15 = 0; (p_15 == 3); ++p_15)
            { /* block id: 289 */
                (*g_193) = (**g_282);
                return l_556;
            }
        }
        else
        { /* block id: 293 */
            struct S0 **l_569 = &g_107;
            int32_t *l_570 = (void*)0;
            int32_t *l_571 = (void*)0;
            int32_t *l_572 = &g_110;
            (*l_572) = (l_568 == l_569);
        }
    }
    else
    { /* block id: 296 */
        return g_108.f5;
    }
    g_108.f2 = (safe_sub_func_int16_t_s_s(((safe_lshift_func_uint16_t_u_u((248UL <= (((safe_add_func_int8_t_s_s(0x2BL, ((safe_lshift_func_uint16_t_u_u((((safe_sub_func_int8_t_s_s((safe_div_func_uint8_t_u_u(((l_547 >= l_587) & (0xC8A975C77EC0581CLL > ((l_588 >= (safe_lshift_func_uint8_t_u_s((safe_add_func_int16_t_s_s((safe_sub_func_int16_t_s_s((safe_mod_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((((((void*)0 == (**g_282)) <= ((g_110 && 0UL) <= 0x32EF3211L)) & 0UL) | g_91.f0), (-4L))), 0x2B9EL)), p_15)), g_108.f8)), l_525))) || g_108.f4))), 0xD2L)), 0xE9L)) <= l_588) > p_12), g_108.f6)) > 0x2BL))) > g_91.f0) < p_15)), p_15)) & g_108.f5), 0xA81AL));
    return p_13;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_91 g_107 g_108.f7 g_108.f0 g_108.f2 g_113 g_110 g_131 g_108.f4 g_108.f8 g_108.f1 g_108.f3 g_108.f5 g_108.f6 g_193 g_298 g_301 g_108 g_299 g_339 g_340
 * writes: g_110 g_113 g_91 g_131 g_282 g_301 g_108.f5 g_108.f6
 */
static int64_t  func_23(uint16_t  p_24, uint64_t  p_25, uint64_t  p_26, uint8_t  p_27, int8_t  p_28)
{ /* block id: 4 */
    int8_t l_31 = 0x56L;
    int32_t l_521 = (-7L);
    l_521 = (safe_div_func_int16_t_s_s(l_31, (safe_mod_func_int16_t_s_s((safe_unary_minus_func_int64_t_s((g_2 > (safe_div_func_uint32_t_u_u(func_37(((safe_lshift_func_uint16_t_u_s((safe_mod_func_int64_t_s_s(((0x69B45C761B8CE229LL ^ func_46(l_31, l_31, p_27, (safe_add_func_uint64_t_u_u((safe_rshift_func_int8_t_s_s(((safe_rshift_func_uint8_t_u_u(249UL, 6)) && l_31), func_57(l_31, p_24, g_2))), (-4L))))) < 3UL), 0xB0AB872545833043LL)), l_31)) <= l_31), p_27, p_26, g_301), 1UL))))), 0xA56FL))));
    /* statement id: 281 */
    assert (g_113 == &g_2 || g_113 == &g_110);
    //assert (g_131 == 0 || g_131 == dangling || g_131 == &g_2);
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_108.f2 g_107 g_108 g_113 g_110 g_91.f0 g_91.f1 g_301 g_299 g_298 g_339 g_340
 * writes: g_282 g_301 g_131 g_108.f5 g_108.f6
 */
static uint32_t  func_37(uint32_t  p_38, uint16_t  p_39, int32_t  p_40, int64_t  p_41)
{ /* block id: 136 */
    uint32_t l_318 = 0xD747A76EL;
    int8_t l_336 = 1L;
    int64_t l_344 = 0x09282D32F513778ALL;
    struct S0 ***l_345 = &g_195;
    uint32_t l_385 = 18446744073709551609UL;
    int32_t *l_390 = &g_2;
    struct S1 *l_405 = &g_91;
    int32_t l_421 = 0L;
    int32_t l_457 = 0xCF3309E0L;
    struct S1 ***l_461 = &g_340;
    struct S0 l_462 = {822,-946,8,22,78,11055,-0,0,18};
    struct S0 *****l_491 = &g_193;
    for (p_38 = 0; (p_38 >= 21); p_38 = safe_add_func_int32_t_s_s(p_38, 1))
    { /* block id: 139 */
        struct S0 l_323 = {947,1357,-26,18,345,-864,-0,0,0};
        int32_t ****l_420 = &g_298;
        struct S0 *****l_430 = &g_193;
        struct S1 l_432 = {0,-49};
    }
    if (((*l_390) ^ ((-2L) >= l_457)))
    { /* block id: 245 */
        struct S0 ***l_460 = &g_195;
        int32_t l_479 = (-6L);
        if (p_40)
        { /* block id: 246 */
            p_40 = ((0x5FL || (safe_lshift_func_int8_t_s_s((g_108.f2 == ((void*)0 == l_460)), 7))) < (l_461 == (void*)0));
        }
        else
        { /* block id: 248 */
            uint32_t l_463 = 7UL;
            int32_t l_481 = (-1L);
            struct S0 l_484 = {1128,398,-60,44,1572,9325,-0,-0,39};
            if (p_38)
            { /* block id: 249 */
                struct S0 *****l_464 = &g_193;
                uint32_t l_480 = 0x1DF06D25L;
                l_462 = (*g_107);
                l_463 = (*g_113);
                g_282 = l_464;
                l_481 = ((*l_390) >= (safe_add_func_uint16_t_u_u((0xC3L != (safe_rshift_func_int8_t_s_u(((safe_mod_func_uint32_t_u_u(((!(g_108.f6 == (l_463 > (((((((safe_mod_func_uint64_t_u_u(((g_108.f6 & (safe_add_func_int16_t_s_s(((safe_div_func_uint64_t_u_u(((*l_390) | ((~p_41) && (((void*)0 != &g_298) <= g_91.f0))), l_479)) || l_480), p_40))) | (*l_390)), l_479)) > 0x21AACA16AE204A08LL) & 0x4DL) || 0xE77EDE55L) != g_108.f0) == 0x53E0E9FCC4D1D9BDLL) != 0x7DB3D328635BDAD2LL)))) > g_91.f1), (*g_113))) & 0UL), 4))), g_91.f1)));
            }
            else
            { /* block id: 254 */
                for (g_301 = 0; (g_301 <= 50); ++g_301)
                { /* block id: 257 */
                    return p_38;
                }
            }
            l_484 = (*g_107);
            l_484 = l_462;
        }
        (*g_299) = &l_479;
        /* statement id: 264 */
        assert (g_131 == &l_479);
    }
    else
    { /* block id: 265 */
        int32_t *l_485 = &g_2;
        struct S0 *****l_509 = &g_193;
        uint16_t l_510 = 65535UL;
        (**g_298) = l_485;
        /* statement id: 266 */
        assert (g_131 == &g_2);
        g_108.f5 = ((safe_add_func_int8_t_s_s(((0x429DL & (safe_sub_func_int8_t_s_s(((safe_unary_minus_func_int32_t_s(((*g_113) & (l_491 != l_491)))) != ((((void*)0 == (*g_339)) >= (safe_mod_func_int16_t_s_s((safe_rshift_func_int8_t_s_u((safe_sub_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_s(p_40, 6)), (~((safe_lshift_func_int16_t_s_u(((safe_div_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u(((l_509 != &g_193) ^ 0x0FD327BDL), (*l_485))), l_510)), (*l_485))) ^ g_2), p_41)) >= g_108.f6)))), 5)), g_108.f0))) >= (*l_485))), (*l_390)))) | p_38), 0xF4L)) <= 0x973CAE93L);
    }
    /* facts after branching */
    //assert (g_131 == &g_2 || g_131 == dangling);
    for (l_344 = (-18); (l_344 < 18); ++l_344)
    { /* block id: 271 */
        int32_t *l_515 = &l_457;
        (*l_515) = (safe_lshift_func_int8_t_s_s(0xBBL, 7));
    }
    for (l_318 = 0; (l_318 < 53); ++l_318)
    { /* block id: 276 */
        l_462.f1 = (~(*l_390));
        g_108.f6 = ((((*g_339) == (*l_461)) >= (((&g_193 != &g_193) > 4UL) <= ((*l_390) <= (0xF1L >= ((*g_298) == (void*)0))))) >= 0xDA5FL);
    }
    return (*l_390);
}


/* ------------------------------------------ */
/* 
 * reads : g_91.f0 g_108.f6 g_108.f5 g_108.f4 g_113 g_110 g_108.f2 g_108.f8 g_108.f0 g_91 g_298
 * writes: g_113 g_110 g_282 g_131 g_91
 */
static int64_t  func_46(int32_t  p_47, uint16_t  p_48, uint64_t  p_49, int8_t  p_50)
{ /* block id: 112 */
    uint16_t l_249 = 0xCE65L;
    int32_t l_250 = 0x5FDFF747L;
    int32_t l_255 = 7L;
    int8_t l_258 = 0xDCL;
    struct S1 *l_264 = &g_91;
    struct S1 **l_263 = &l_264;
    int32_t l_274 = 0x610735DBL;
    struct S0 *l_293 = (void*)0;
    int32_t *l_300 = &g_110;
    l_255 = ((0x34340374B80A7309LL != (((p_49 < 0x00CCDFA7L) && (~(safe_lshift_func_int8_t_s_s((l_249 >= (1UL == ((((l_249 < l_250) != ((((safe_mod_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u(l_249, (p_50 <= 18446744073709551611UL))), 0x84D3L)) || p_47) < p_47) >= g_91.f0)) > 0x3FC3L) <= 0xEF47AD6AL))), 5)))) ^ p_49)) ^ 0xBAA4C83CD3FB4F5BLL);
    if (((safe_add_func_int32_t_s_s((((p_49 && l_258) ^ g_108.f6) >= (safe_sub_func_int16_t_s_s(((g_108.f5 && (safe_add_func_uint32_t_u_u(g_108.f4, (l_255 != ((l_263 != (void*)0) && (l_258 != g_91.f0)))))) != l_250), 0xE175L))), l_249)) <= l_255))
    { /* block id: 114 */
        int32_t **l_265 = &g_113;
        struct S1 *l_279 = &g_91;
        (*l_265) = &g_110;
        /* statement id: 115 */
        assert (g_113 == &g_110);
        (*g_113) = (((**l_265) <= g_108.f4) ^ ((safe_lshift_func_uint8_t_u_u(p_47, 1)) > (((safe_lshift_func_int8_t_s_u(((safe_sub_func_int8_t_s_s((safe_lshift_func_int8_t_s_u((p_48 >= l_274), 5)), (&g_2 == &l_255))) != ((255UL & (safe_lshift_func_uint16_t_u_s((safe_lshift_func_uint16_t_u_s(((l_279 != l_279) != p_50), (**l_265))), p_47))) | g_91.f0)), g_108.f2)) | l_255) > 0x19L)));
        for (l_255 = 0; (l_255 == 14); l_255 = safe_add_func_uint64_t_u_u(l_255, 9))
        { /* block id: 119 */
            g_282 = &g_193;
        }
        (*g_113) = (*g_113);
    }
    else
    { /* block id: 123 */
        for (g_110 = (-18); (g_110 >= (-25)); g_110--)
        { /* block id: 126 */
            int32_t **l_285 = &g_131;
            int32_t l_292 = (-1L);
            int32_t *l_294 = &l_255;
            struct S1 l_295 = {0,-22};
            (*l_285) = (void*)0;
            /* statement id: 127 */
            assert (g_131 == 0);
            (*l_294) = ((3L >= (safe_rshift_func_uint16_t_u_u(((safe_add_func_int8_t_s_s(g_108.f4, g_108.f8)) > p_50), (((safe_mod_func_uint16_t_u_u(g_108.f0, g_108.f5)) ^ l_292) ^ ((l_293 == (void*)0) ^ p_49))))) < 0xD8B0L);
            (*l_264) = l_295;
            (*l_264) = g_91;
        }
        /* facts after for loop */
        //assert (g_131 == 0 || g_131 == dangling);
    }
    /* facts after branching */
    assert (g_113 == &g_2 || g_113 == &g_110);
    //assert (g_131 == 0 || g_131 == dangling);
    (*l_300) = (p_49 != ((safe_rshift_func_int8_t_s_u(0x04L, 5)) || (g_298 != &g_299)));
    (*l_300) = (((void*)0 == &l_263) ^ 1UL);
    return (*l_300);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_91 g_107 g_108.f7 g_108.f0 g_108.f2 g_113 g_110 g_131 g_108.f4 g_108.f8 g_108.f1 g_108.f3 g_108.f5 g_108.f6 g_193
 * writes: g_110 g_113 g_91 g_131
 */
inline static int8_t  func_57(uint8_t  p_58, uint32_t  p_59, uint32_t  p_60)
{ /* block id: 5 */
    int32_t *l_64 = &g_2;
    int32_t **l_239 = &g_113;
    int32_t ***l_240 = &l_239;
    int32_t *l_241 = (void*)0;
    int32_t *l_242 = &g_110;
    struct S1 *l_244 = &g_91;
    struct S1 **l_243 = &l_244;
    struct S1 ***l_245 = &l_243;
    (*l_239) = func_61(((void*)0 != l_64), g_2);
    /* statement id: 107 */
    assert (g_113 == &g_2);
    //assert (g_131 == dangling);
    (*l_242) = (l_240 != &l_239);
    (**l_240) = (*l_239);
    (*l_245) = l_243;
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_91 g_107 g_108.f7 g_108.f0 g_108.f2 g_113 g_110 g_131 g_108.f4 g_108.f8 g_108.f1 g_108.f3 g_108.f5 g_108.f6 g_193
 * writes: g_110 g_113 g_91 g_131
 */
static int32_t * func_61(uint8_t  p_62, int64_t  p_63)
{ /* block id: 6 */
    uint64_t l_65 = 18446744073709551615UL;
    int32_t l_235 = 0L;
    int32_t **l_236 = &g_131;
    uint64_t l_238 = 18446744073709551609UL;
    l_235 = (l_65 != func_66(l_65, &g_2));
    /* statement id: 103 */
    //assert (g_113 == dangling || g_113 == &g_110);
    (*l_236) = &l_235;
    /* statement id: 104 */
    assert (g_131 == &l_235);
    (*g_131) = (!l_238);
    return &g_2;
    /* statement id: 106 */
    //assert (g_131 == dangling);
    //assert (func_61_rv == &g_2);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_91 g_107 g_108.f7 g_108.f0 g_108.f2 g_113 g_110 g_131 g_108.f4 g_108.f8 g_108.f1 g_108.f3 g_108.f5 g_108.f6 g_193
 * writes: g_110 g_113 g_91
 */
inline static int16_t  func_66(int32_t  p_67, int32_t * p_68)
{ /* block id: 7 */
    uint16_t l_69 = 0x1676L;
    int32_t *l_74 = (void*)0;
    struct S0 *l_168 = (void*)0;
    uint32_t l_234 = 0x1ED602CCL;
    if (l_69)
    { /* block id: 8 */
        int32_t *l_84 = &g_2;
        int32_t **l_156 = &l_74;
        int32_t ***l_155 = &l_156;
        struct S0 *l_232 = &g_108;
        if ((*p_68))
        { /* block id: 9 */
            uint16_t l_142 = 65535UL;
            for (p_67 = (-2); (p_67 == 19); ++p_67)
            { /* block id: 12 */
                uint32_t l_79 = 6UL;
                int32_t *l_104 = &g_2;
                struct S1 *l_137 = &g_91;
                int32_t **l_150 = &g_113;
                int8_t l_160 = 3L;
                for (l_69 = 0; (l_69 <= 14); l_69 = safe_add_func_int32_t_s_s(l_69, 8))
                { /* block id: 15 */
                    uint8_t l_99 = 0x6BL;
                    if ((&g_2 != l_74))
                    { /* block id: 16 */
                        int32_t **l_132 = &g_113;
                        (*l_132) = func_75(l_79, func_80(p_67, l_84, g_2), ((safe_div_func_int8_t_s_s((((safe_lshift_func_uint16_t_u_s(l_99, (safe_lshift_func_int16_t_s_s(p_67, 7)))) != p_67) || (safe_mod_func_uint8_t_u_u(((l_84 != l_104) < g_91.f0), (-2L)))), (*l_84))) | p_67));
                        /* statement id: 48 */
                        assert (g_113 == &g_2 || g_113 == &g_110);
                        (*l_132) = &p_67;
                        /* statement id: 49 */
                        assert (g_113 == &p_67);
                        return p_67;
                        /* statement id: 50 */
                        //assert (g_113 == dangling);
                    }
                    else
                    { /* block id: 51 */
                        struct S0 **l_134 = &g_107;
                        struct S0 ***l_133 = &l_134;
                        int32_t **l_136 = &l_74;
                        int32_t ***l_135 = &l_136;
                        (*l_133) = (void*)0;
                        /* statement id: 52 */
                        assert (l_134 == 0);
                        (*l_133) = &g_107;
                        /* statement id: 53 */
                        assert (l_134 == &g_107);
                        (*l_135) = &g_113;
                        /* statement id: 54 */
                        assert (l_136 == &g_113);
                        return p_67;
                    }
                }
                (*l_137) = g_91;
                if ((((g_108.f2 != 0x2B54L) <= (g_108.f4 ^ 0x6FL)) < ((g_108.f8 > l_69) != 0xF5A5DA86L)))
                { /* block id: 59 */
                    int32_t **l_143 = &l_84;
                    p_68 = &g_110;
                    /* statement id: 60 */
                    assert (p_68 == &g_110);
                    (*l_143) = func_80((*l_84), func_80(g_108.f4, func_80(g_108.f4, &g_2, (((g_2 >= (safe_add_func_uint8_t_u_u((safe_add_func_uint32_t_u_u((&p_68 == &p_68), (((((((g_108.f1 >= p_67) ^ p_67) & g_108.f3) | (*g_113)) <= g_108.f3) > p_67) == (*g_113)))), g_108.f1))) != p_67) <= 1UL)), (*g_113)), l_142);
                    if ((((0L <= ((4294967295UL <= p_67) != (safe_lshift_func_int8_t_s_u(0x21L, ((safe_lshift_func_uint16_t_u_u(((l_150 == &g_113) ^ (p_67 > (p_67 != p_67))), g_2)) || 0L))))) | (*g_131)) >= (*l_104)))
                    { /* block id: 62 */
                        int32_t ***l_157 = &l_143;
                        (*g_131) = ((safe_sub_func_int32_t_s_s(0xD196261EL, ((safe_lshift_func_int16_t_s_s((((l_155 != l_157) == ((((-4L) == (g_108.f5 != g_108.f5)) | (p_67 | (((safe_lshift_func_uint8_t_u_u(0x6EL, ((&g_110 == &g_2) & p_67))) | 0xB4L) != (***l_157)))) == l_160)) < (**l_143)), g_108.f7)) != (***l_157)))) && p_67);
                    }
                    else
                    { /* block id: 64 */
                        struct S0 *l_167 = &g_108;
                        struct S0 **l_182 = &l_168;
                        struct S0 ***l_181 = &l_182;
                        struct S0 ****l_180 = &l_181;
                        struct S0 *****l_179 = &l_180;
                        (**l_150) = (safe_add_func_int8_t_s_s(((250UL <= (safe_rshift_func_uint16_t_u_s((safe_mod_func_uint64_t_u_u((((l_167 != l_168) > ((g_91.f1 || p_67) || ((safe_add_func_int32_t_s_s((safe_lshift_func_uint16_t_u_s((0x84L >= (safe_div_func_int32_t_s_s((-1L), (~(safe_mod_func_uint32_t_u_u(((~(**l_143)) == ((((g_108.f6 & g_91.f1) && (**l_143)) >= 0x740F3B8AL) > (*g_113))), (*p_68))))))), 8)), (*g_131))) <= 0xF882L))) <= 0xDE1D7CC4F2F6EF93LL), g_2)), (**l_150)))) > (**l_143)), (*l_104)));
                        (*l_179) = (void*)0;
                        /* statement id: 66 */
                        assert (l_180 == 0);
                        p_68 = func_80(p_67, &g_110, (*g_131));
                        /* statement id: 67 */
                        assert (p_68 == &g_2);
                    }
                    /* facts after branching */
                    assert (p_68 == &g_2 || p_68 == &g_110);
                }
                else
                { /* block id: 69 */
                    (*l_156) = &g_2;
                    /* statement id: 70 */
                    assert (l_74 == &g_2);
                }
                /* facts after branching */
                assert (p_68 == &g_2 || p_68 == &g_110);
                assert (l_74 == &g_2 || l_74 == 0);
                return p_67;
            }
            return p_67;
        }
        else
        { /* block id: 75 */
            int32_t l_200 = 0xB70EE5EEL;
            struct S1 *l_223 = &g_91;
            for (l_69 = 0; (l_69 != 27); l_69++)
            { /* block id: 78 */
                int32_t *l_185 = (void*)0;
                int32_t l_233 = (-9L);
                (*l_156) = &p_67;
                /* statement id: 79 */
                assert (l_74 == &p_67);
                (*l_156) = l_185;
                /* statement id: 80 */
                assert (l_74 == 0);
                if ((safe_sub_func_uint32_t_u_u((safe_add_func_int64_t_s_s((((safe_unary_minus_func_int16_t_s(g_108.f7)) == ((safe_sub_func_uint8_t_u_u(255UL, 0UL)) < 65535UL)) || (g_193 == (void*)0)), 0x2AE52791890F00B8LL)), ((((safe_mod_func_int16_t_s_s(((((p_67 | ((g_108.f2 ^ 255UL) || g_108.f1)) > g_2) & p_67) == 0x9574A338B79B9A59LL), g_108.f0)) != (*l_84)) != g_108.f2) & 0UL))))
                { /* block id: 81 */
                    int32_t l_201 = 0xEDAE182EL;
                    for (p_67 = 0; (p_67 > (-25)); --p_67)
                    { /* block id: 84 */
                        int64_t l_210 = 0x341BAEACE3552C83LL;
                        (*g_113) = l_200;
                        if (l_201)
                            break;
                        (*g_113) = (safe_sub_func_int8_t_s_s((safe_mod_func_int16_t_s_s(((safe_sub_func_int8_t_s_s((safe_sub_func_uint8_t_u_u(l_210, (safe_add_func_int32_t_s_s((*g_131), (safe_sub_func_uint16_t_u_u(p_67, (l_201 >= (l_210 <= 0x4CL)))))))), ((0UL != (safe_sub_func_uint16_t_u_u((((safe_lshift_func_int8_t_s_s(p_67, 0)) | (safe_lshift_func_int16_t_s_s(((p_67 >= 1UL) <= p_67), g_108.f3))) & l_200), 0x755CL))) >= 0x13L))) < g_91.f1), g_91.f1)), p_67));
                        (*g_113) = (safe_div_func_int64_t_s_s(((void*)0 == (*l_155)), g_110));
                    }
                    l_74 = &p_67;
                    /* statement id: 90 */
                    assert (l_74 == &p_67);
                    (*g_113) = l_200;
                }
                else
                { /* block id: 92 */
                    if ((*p_68))
                        break;
                    (*g_131) = ((l_223 != (void*)0) < (safe_sub_func_int32_t_s_s((safe_mod_func_int8_t_s_s(0x8BL, (safe_rshift_func_uint16_t_u_u(p_67, ((safe_lshift_func_int8_t_s_s((-3L), p_67)) | g_108.f4))))), ((void*)0 == l_232))));
                    if (l_233)
                        break;
                }
                /* facts after branching */
                assert (l_74 == 0 || l_74 == &p_67);
            }
            /* facts after for loop */
            assert (l_74 == 0 || l_74 == &p_67);
            return p_67;
        }
    }
    else
    { /* block id: 100 */
        return l_234;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_107 g_108.f7 g_2 g_91.f0 g_108.f0 g_108.f2 g_113 g_110 g_131
 * writes: g_110 g_113
 */
static int32_t * func_75(int32_t  p_76, int32_t * p_77, uint32_t  p_78)
{ /* block id: 22 */
    int32_t *l_109 = &g_110;
    for (p_78 = 11; (p_78 <= 24); p_78 = safe_add_func_uint64_t_u_u(p_78, 6))
    { /* block id: 25 */
        return &g_2;
        /* statement id: 26 */
        //assert (func_75_rv == &g_2);
    }
    (*l_109) = ((void*)0 == g_107);
    for (p_76 = 0; (p_76 > 28); ++p_76)
    { /* block id: 31 */
        int32_t **l_114 = &l_109;
        int32_t *l_127 = &g_110;
        g_113 = &p_76;
        /* statement id: 32 */
        assert (g_113 == &p_76);
        (*l_114) = &g_110;
        /* statement id: 33 */
        assert (l_109 == &g_110);
        (*l_114) = &g_2;
        /* statement id: 34 */
        assert (l_109 == &g_2);
        (*l_127) = (safe_sub_func_uint16_t_u_u(((void*)0 == &g_113), ((((safe_lshift_func_uint16_t_u_s((((void*)0 == l_114) != (safe_mod_func_uint16_t_u_u(((g_108.f7 >= (safe_lshift_func_int8_t_s_u((safe_add_func_uint8_t_u_u((safe_add_func_int16_t_s_s((p_78 ^ (*l_109)), ((((void*)0 != &g_113) == g_91.f0) <= 0xEFL))), p_76)), g_91.f0))) && (*l_109)), (*l_109)))), g_108.f0)) < g_108.f2) != 1L) != (*g_113))));
    }
    /* facts after for loop */
    assert (l_109 == &g_2 || l_109 == &g_110);
    //assert (g_113 == &p_76 || g_113 == &g_110 || g_113 == &g_2 || g_113 == dangling);
    for (p_78 = (-18); (p_78 > 39); p_78 = safe_add_func_uint16_t_u_u(p_78, 7))
    { /* block id: 39 */
        int32_t **l_130 = &g_113;
        (*l_130) = &g_2;
        /* statement id: 40 */
        assert (g_113 == &g_2);
        if ((*p_77))
        { /* block id: 41 */
            if ((*l_109))
                break;
        }
        else
        { /* block id: 43 */
            return &g_2;
            /* statement id: 44 */
            //assert (func_75_rv == &g_2);
        }
    }
    return g_131;
    /* statement id: 47 */
    //assert (g_113 == &g_2 || g_113 == dangling || g_113 == &g_110);
    //assert (func_75_rv == &g_110 || func_75_rv == &p_40 || func_75_rv == &g_2 || func_75_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_91
 * writes:
 */
inline static int32_t * func_80(uint32_t  p_81, int32_t * p_82, int32_t  p_83)
{ /* block id: 17 */
    int32_t *l_85 = &g_2;
    int32_t l_90 = (-1L);
    struct S1 l_92 = {0,-52};
    struct S0 l_93 = {83,738,0,17,745,-81,-0,0,23};
    struct S0 *l_94 = &l_93;
    l_90 = ((p_81 > p_83) >= (((((-1L) ^ (l_85 == &g_2)) & (((g_2 && (l_85 == l_85)) > ((safe_mod_func_int8_t_s_s(((safe_rshift_func_uint16_t_u_s(p_81, p_81)) <= g_2), g_2)) | 65527UL)) && (-1L))) <= 0x9AL) < p_81));
    l_92 = g_91;
    (*l_94) = l_93;
    return &g_2;
    /* statement id: 21 */
    //assert (func_80_rv == &g_2);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_91.f0, "g_91.f0", print_hash_value);
    transparent_crc(g_91.f1, "g_91.f1", print_hash_value);
    transparent_crc(g_108.f0, "g_108.f0", print_hash_value);
    transparent_crc(g_108.f1, "g_108.f1", print_hash_value);
    transparent_crc(g_108.f2, "g_108.f2", print_hash_value);
    transparent_crc(g_108.f3, "g_108.f3", print_hash_value);
    transparent_crc(g_108.f4, "g_108.f4", print_hash_value);
    transparent_crc(g_108.f5, "g_108.f5", print_hash_value);
    transparent_crc(g_108.f6, "g_108.f6", print_hash_value);
    transparent_crc(g_108.f7, "g_108.f7", print_hash_value);
    transparent_crc(g_108.f8, "g_108.f8", print_hash_value);
    transparent_crc(g_110, "g_110", print_hash_value);
    transparent_crc(g_301, "g_301", print_hash_value);
    transparent_crc(g_730, "g_730", print_hash_value);
    transparent_crc(g_812, "g_812", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 139
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 12
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 49
breakdown:
   indirect level: 0, occurrence: 13
   indirect level: 1, occurrence: 10
   indirect level: 2, occurrence: 8
   indirect level: 3, occurrence: 9
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 6
XXX full-bitfields structs in the program: 13
breakdown:
   indirect level: 0, occurrence: 13
XXX times a bitfields struct's address is taken: 17
XXX times a bitfields struct on LHS: 6
XXX times a bitfields struct on RHS: 15
XXX times a single bitfield on LHS: 4
XXX times a single bitfield on RHS: 149

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 138
   depth: 2, occurrence: 20
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 7, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 4
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 119

XXX times a variable address is taken: 163
XXX times a pointer is dereferenced on RHS: 123
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 25
   depth: 3, occurrence: 7
   depth: 4, occurrence: 9
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 97
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 20
   depth: 3, occurrence: 7
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 40
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 23
XXX times a pointer is qualified to be dereferenced: 447

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 378
   level: 2, occurrence: 102
   level: 3, occurrence: 53
   level: 4, occurrence: 22
   level: 5, occurrence: 17
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 39
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 18.5
XXX average alias set size: 1.24

XXX times a non-volatile is read: 904
XXX times a non-volatile is write: 298
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 120
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 39
   depth: 1, occurrence: 23
   depth: 2, occurrence: 17
   depth: 3, occurrence: 14
   depth: 4, occurrence: 12
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 17.5
XXX percentage an existing variable is used: 82.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

