/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --no-bitfields --checksum --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-jumps --no-longlong --no-force-non-uniform-arrays --math64 --no-muls --packed-struct --paranoid --pointers --structs --inline-function --return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      212598928
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = (-5);
static int32_t g_7 = 0xF23B1A95;
static struct S0 g_23 = {4294967295U};
static int32_t g_33 = 0xE55B65AB;
static struct S0 *g_55 = &g_23;
static struct S0 **g_54 = &g_55;
static int32_t *g_109 = &g_33;
static int32_t **g_108 = &g_109;
static uint32_t g_125 = 0xDB6C63C4;
static struct S0 g_192 = {0U};
static const struct S0 *g_221 = (void*)0;
static const struct S0 **g_220 = &g_221;
static const struct S0 ***g_219 = &g_220;
static const struct S0 ****g_218 = &g_219;
static const struct S0 *****g_217 = &g_218;
static int32_t ***g_391 = &g_108;
static int32_t **** const g_390 = &g_391;
static uint32_t g_456 = 0xD9327C20;


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_1(void);
static int32_t * func_8(int32_t * const  p_9);
static const uint16_t  func_13(int32_t  p_14, int32_t * p_15, uint8_t  p_16, uint32_t  p_17);
static int32_t * func_18(uint16_t  p_19, int32_t * p_20, struct S0  p_21);
inline static uint16_t  func_28(const struct S0  p_29);
static const struct S0 ** func_34(struct S0 * p_35, struct S0 * p_36);
inline static struct S0 * func_38(struct S0 * p_39, int16_t  p_40);
static int32_t  func_41(uint16_t  p_42, const int32_t  p_43, struct S0 ** p_44, struct S0 ** p_45);
inline static struct S0  func_56(const int8_t  p_57, struct S0 * p_58);
static uint8_t  func_66(int8_t  p_67, struct S0 * p_68, struct S0 ** p_69);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_456
 * writes: g_2 g_7
 */
inline static uint32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_441 = 0x6E1B;
    int32_t * const *l_445 = &g_109;
    int32_t * const **l_444 = &l_445;
    uint8_t l_446 = 0U;
    struct S0 *l_455 = &g_23;
    for (g_2 = 15; (g_2 >= 0); g_2--)
    { /* block id: 3 */
        int32_t l_5 = 0x45307222;
        int32_t *l_6 = &g_7;
        int32_t *l_435 = &g_7;
        (*l_6) = (g_2 || l_5);
    }
    return g_456;
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_23 g_54 g_2 g_33 g_108 g_55 g_109 g_125 g_217 g_218 g_219 g_192.f0 g_220 g_390 g_221 g_391
 * writes: g_7 g_23 g_33 g_125 g_109 g_192 g_220 g_54
 */
static int32_t * func_8(int32_t * const  p_9)
{ /* block id: 5 */
    const int32_t *l_10 = (void*)0;
    int32_t l_22 = 0xF27A4129;
    uint32_t l_332 = 0xE86C6B0A;
    struct S0 **l_383 = &g_55;
    uint16_t l_400 = 0U;
    (*p_9) = g_7;
    if (((&g_2 == p_9) < ((l_10 != &g_2) & ((safe_lshift_func_uint16_t_u_s(func_13(g_7, func_18(l_22, &l_22, g_23), l_332, g_7), g_2)) <= l_332))))
    { /* block id: 204 */
        (*g_109) = (*p_9);
        (*g_55) = (*g_55);
        g_54 = l_383;
    }
    else
    { /* block id: 208 */
        int16_t l_387 = 0x464E;
        int32_t ***l_389 = &g_108;
        int32_t ****l_388 = &l_389;
        struct S0 *l_406 = &g_23;
        uint32_t l_421 = 4294967290U;
        if ((safe_div_func_uint8_t_u_u((safe_unary_minus_func_int16_t_s((l_387 || (l_387 >= ((l_388 != g_390) != (safe_lshift_func_int8_t_s_s((***l_389), (((void*)0 == (*g_220)) > (safe_mod_func_int16_t_s_s((safe_mod_func_uint8_t_u_u((***l_389), (safe_rshift_func_uint16_t_u_s(l_400, l_22)))), l_22)))))))))), (****l_388))))
        { /* block id: 209 */
            const uint8_t l_403 = 0xC0;
            const struct S0 l_407 = {0U};
            for (g_7 = (-8); (g_7 == (-2)); g_7++)
            { /* block id: 212 */
                (*g_55) = (**l_383);
            }
            for (g_125 = 0; (g_125 > 21); ++g_125)
            { /* block id: 217 */
                uint32_t l_420 = 0x2A78D98D;
                (*g_55) = l_407;
                for (l_22 = 27; (l_22 <= 19); l_22 = safe_sub_func_uint16_t_u_u(l_22, 2))
                { /* block id: 221 */
                    const int32_t l_419 = 0;
                    l_421 = (g_7 == (+(((safe_div_func_int32_t_s_s((safe_add_func_int8_t_s_s(l_403, ((((0xF67A6DE4 == (((+3) == (g_125 && g_2)) > (+0x6D))) & ((safe_add_func_int8_t_s_s((((void*)0 == (**g_391)) == 0x41C65E76), l_419)) > l_420)) == g_33) < (***l_389)))), 0x33DB2431)) | g_33) == l_420)));
                    (**g_54) = (**l_383);
                }
            }
        }
        else
        { /* block id: 226 */
            (*g_55) = (*l_406);
        }
        (****g_390) = (0U != ((p_9 != (***g_390)) ^ (***l_389)));
        if ((**g_108))
        { /* block id: 230 */
            return (**l_389);
            /* statement id: 231 */
            //assert (func_8_rv == &g_7 || func_8_rv == &g_33);
        }
        else
        { /* block id: 232 */
            int32_t **l_422 = &g_109;
            (*l_422) = p_9;
            /* statement id: 233 */
            assert (g_109 == &g_7);
            (*g_55) = (*l_406);
            (**g_108) = (*p_9);
        }
        /* facts after branching */
        assert (g_109 == &g_7);
    }
    /* facts after branching */
    assert (g_109 == &g_7 || g_109 == &g_33);
    return (***g_390);
    /* statement id: 238 */
    //assert (func_8_rv == &g_7 || func_8_rv == &g_33);
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_33 g_108 g_55 g_23 g_109 g_125 g_2 g_192.f0 g_217 g_218 g_219 g_54
 * writes: g_109 g_33 g_23.f0 g_23 g_7
 */
static const uint16_t  func_13(int32_t  p_14, int32_t * p_15, uint8_t  p_16, uint32_t  p_17)
{ /* block id: 181 */
    struct S0 * const *l_346 = &g_55;
    struct S0 * const **l_345 = &l_346;
    int32_t l_349 = (-7);
    int32_t l_378 = 0;
    if ((*p_15))
    { /* block id: 182 */
        int8_t l_335 = (-1);
        struct S0 **l_340 = &g_55;
        int32_t ***l_348 = &g_108;
        int32_t ****l_347 = &l_348;
        struct S0 *l_350 = &g_23;
        uint32_t l_366 = 0x2A9CAC04;
        int32_t l_373 = 0xB6A1B359;
        (**l_348) = p_15;
        if (l_349)
        { /* block id: 184 */
            struct S0 l_353 = {0x27778E15};
            int32_t *l_354 = (void*)0;
            l_350 = (void*)0;
            /* statement id: 185 */
            assert (l_350 == 0);
            for (p_14 = 16; (p_14 > (-27)); p_14 = safe_sub_func_int16_t_s_s(p_14, 1))
            { /* block id: 188 */
                struct S0 *l_355 = &l_353;
                l_353 = (**l_346);
                (***l_347) = p_15;
                (***l_345) = func_56(g_23.f0, func_38(l_355, ((((**g_108) | (8U < (g_23.f0 & ((g_33 == (g_125 != ((safe_rshift_func_uint8_t_u_s((p_17 > 248U), l_349)) != g_2))) != g_192.f0)))) && l_349) && (-2))));
                /* statement id: 191 */
                assert (g_109 == &g_33);
                (**l_340) = (**l_340);
            }
            return p_17;
        }
        else
        { /* block id: 195 */
            (*g_109) = 2;
            (*p_15) = (safe_rshift_func_uint16_t_u_s((***l_348), g_192.f0));
        }
        (****l_347) = ((((l_349 != ((safe_sub_func_int16_t_s_s(p_17, (safe_mod_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u(((p_16 ^ g_125) <= (0xBE ^ ((void*)0 != &l_340))), (l_366 >= (safe_div_func_int16_t_s_s((((safe_rshift_func_int8_t_s_s((safe_mod_func_uint16_t_u_u(g_192.f0, g_33)), 6)) >= (-10)) <= 0x445A), l_373))))), g_23.f0)))) || l_349)) <= (****l_347)) & 0x8609) & 0x8F03);
    }
    else
    { /* block id: 200 */
        int32_t l_376 = 0xDF492D8E;
        (*p_15) = (safe_sub_func_int32_t_s_s(l_376, (~(l_376 || (((0U < l_378) <= (((((p_14 & (((safe_sub_func_uint16_t_u_u(((safe_lshift_func_uint8_t_u_u((l_376 >= 7U), 3)) == g_23.f0), ((*p_15) && (**g_108)))) || 0xEB) <= 0xD378)) | (*g_109)) || l_378) >= g_33) <= l_378)) | 7)))));
    }
    return l_349;
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_23.f0 g_54 g_2 g_33 g_108 g_55 g_23 g_109 g_125 g_217 g_218 g_219 g_192.f0 g_220
 * writes: g_23 g_33 g_125 g_109 g_192 g_220
 */
static int32_t * func_18(uint16_t  p_19, int32_t * p_20, struct S0  p_21)
{ /* block id: 7 */
    const struct S0 l_24 = {4294967291U};
    struct S0 *l_25 = &g_23;
    struct S0 ***l_311 = &g_54;
    struct S0 ****l_310 = &l_311;
    struct S0 *****l_309 = &l_310;
    (*l_25) = l_24;
    if ((0x268F && ((safe_lshift_func_int8_t_s_u((g_7 != func_28(p_21)), 6)) | (((safe_add_func_int16_t_s_s(l_24.f0, p_21.f0)) <= (+(*p_20))) > ((&l_24 != &p_21) > 0x259F18D4)))))
    { /* block id: 164 */
        int32_t l_307 = 0x656AE978;
        for (g_192.f0 = (-17); (g_192.f0 == 8); g_192.f0++)
        { /* block id: 167 */
            int32_t ***l_298 = (void*)0;
            int32_t ****l_297 = &l_298;
            (*g_109) = (safe_sub_func_uint16_t_u_u((safe_add_func_uint32_t_u_u(((void*)0 == l_297), (safe_sub_func_uint32_t_u_u(p_21.f0, ((safe_rshift_func_int16_t_s_s((safe_rshift_func_uint8_t_u_s((safe_lshift_func_uint8_t_u_u(l_307, 1)), 4)), (~(g_33 >= ((void*)0 != l_309))))) && (((safe_lshift_func_int16_t_s_u(((safe_div_func_int32_t_s_s((0x98B9 && (safe_rshift_func_uint16_t_u_u(0xAF09, 1))), g_7)) == p_21.f0), 2)) < g_7) >= g_2)))))), g_125));
        }
    }
    else
    { /* block id: 170 */
        for (g_33 = (-22); (g_33 != (-22)); g_33 = safe_add_func_int8_t_s_s(g_33, 8))
        { /* block id: 173 */
            int32_t *l_320 = &g_7;
            struct S0 ***l_331 = &g_54;
            (***l_311) = (*l_25);
            (*g_108) = l_320;
            /* statement id: 175 */
            assert (g_109 == &g_7);
            (*p_20) = ((safe_rshift_func_uint16_t_u_s(((safe_rshift_func_uint8_t_u_s((safe_mul_func_uint32_t_u_u(0xDF28E5AF, (((p_19 != g_7) < ((p_19 == (g_23.f0 & (safe_sub_func_int32_t_s_s(l_24.f0, ((g_23.f0 == (**g_108)) < ((safe_lshift_func_uint8_t_u_u(((l_331 == (*g_218)) > 0x0162), 0)) || (*p_20))))))) && p_19)) == p_21.f0))), 7)) >= l_24.f0), g_192.f0)) >= g_7);
        }
        /* facts after for loop */
        assert (g_109 == &g_7 || g_109 == &g_33);
        (*g_108) = (*g_108);
    }
    /* facts after branching */
    assert (g_109 == &g_7 || g_109 == &g_33);
    return (*g_108);
    /* statement id: 180 */
    //assert (func_18_rv == &g_7 || func_18_rv == &g_33);
}


/* ------------------------------------------ */
/* 
 * reads : g_23.f0 g_7 g_54 g_2 g_33 g_108 g_55 g_23 g_109 g_125 g_217 g_218 g_219 g_192.f0 g_220
 * writes: g_23.f0 g_33 g_23 g_125 g_109 g_192 g_220
 */
inline static uint16_t  func_28(const struct S0  p_29)
{ /* block id: 9 */
    struct S0 *l_37 = &g_23;
    int32_t l_53 = 0x77D900D2;
    for (g_23.f0 = (-6); (g_23.f0 > 9); g_23.f0++)
    { /* block id: 12 */
        int32_t *l_32 = &g_33;
        (*l_32) = 0x18B9628E;
    }
    (**g_218) = func_34(l_37, func_38(&g_23, ((func_41((!(0 > ((safe_mod_func_uint16_t_u_u(65535U, g_7)) >= 0xED))), (p_29.f0 >= (safe_sub_func_uint16_t_u_u(l_53, ((l_53 && p_29.f0) | p_29.f0)))), g_54, &l_37) & g_2) | l_53)));
    return g_33;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_192.f0 g_23.f0 g_108 g_109 g_33 g_218 g_219 g_220
 * writes: g_33
 */
static const struct S0 ** func_34(struct S0 * p_35, struct S0 * p_36)
{ /* block id: 158 */
    const struct S0 *l_279 = (void*)0;
    struct S0 ***l_282 = &g_54;
    int32_t l_283 = 0x91B15815;
    struct S0 ****l_285 = &l_282;
    struct S0 *****l_284 = &l_285;
    (**g_108) = ((safe_add_func_uint8_t_u_u((safe_sub_func_int16_t_s_s(((safe_div_func_int32_t_s_s(((safe_sub_func_int32_t_s_s((((safe_unary_minus_func_uint16_t_u(1U)) ^ g_2) && (((safe_sub_func_int32_t_s_s((p_36 != l_279), (safe_sub_func_int32_t_s_s(((((void*)0 == l_282) != l_283) && ((void*)0 == l_284)), 4294967289U)))) >= l_283) == g_192.f0)), l_283)) != l_283), 0x96C84C52)) != l_283), g_23.f0)), 0U)) < l_283);
    (**g_108) = (*g_109);
    return (**g_218);
    /* statement id: 161 */
    //assert (func_34_rv == &g_221);
}


/* ------------------------------------------ */
/* 
 * reads : g_217 g_218 g_219 g_23.f0 g_125 g_108 g_54 g_55
 * writes: g_33 g_109
 */
inline static struct S0 * func_38(struct S0 * p_39, int16_t  p_40)
{ /* block id: 152 */
    int8_t l_250 = 1;
    struct S0 ***l_263 = (void*)0;
    int32_t l_264 = 0;
    int32_t *l_265 = &g_33;
    int16_t l_266 = 0;
    const struct S0 *****l_267 = &g_218;
    (*l_265) = ((safe_div_func_uint32_t_u_u((safe_mod_func_int16_t_s_s((((safe_rshift_func_int8_t_s_u((((safe_rshift_func_int8_t_s_s((((safe_lshift_func_uint8_t_u_u(l_250, 2)) > l_250) ^ (safe_mod_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s((((safe_lshift_func_int16_t_s_u(((0x73540898 && (0x96 <= (safe_div_func_uint8_t_u_u((l_250 | ((l_263 != l_263) >= ((void*)0 == (**g_217)))), l_250)))) || 0x0A), l_250)) != g_23.f0) || l_264), 11)), 1U))), 1)) < g_125) & l_264), l_250)) ^ g_23.f0) == g_23.f0), l_264)), 0xD71842AC)) || p_40);
    (*g_108) = l_265;
    /* statement id: 154 */
    assert (g_109 == &g_33);
    (*l_265) = l_266;
    l_267 = &g_218;
    return (*g_54);
    /* statement id: 157 */
    //assert (func_38_rv == &g_23);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_33 g_23.f0 g_108 g_55 g_23 g_54 g_109 g_7 g_125 g_217
 * writes: g_33 g_23.f0 g_23 g_125 g_109 g_192
 */
static int32_t  func_41(uint16_t  p_42, const int32_t  p_43, struct S0 ** p_44, struct S0 ** p_45)
{ /* block id: 15 */
    int32_t *l_65 = &g_2;
    struct S0 **l_70 = (void*)0;
    struct S0 *l_71 = &g_23;
    struct S0 l_145 = {0x2609B7AB};
    int32_t l_158 = 7;
    int16_t l_205 = 0x7C98;
    int32_t ***l_209 = (void*)0;
    int32_t ****l_208 = &l_209;
    (**g_54) = func_56((p_43 == (g_2 != ((safe_lshift_func_int8_t_s_u((1U | (safe_sub_func_int32_t_s_s(0x3A47399D, (l_65 != (void*)0)))), (func_66((l_70 == &g_55), l_71, &l_71) < (*l_65)))) >= (*l_65)))), (*p_45));
    (*l_71) = func_56(g_7, l_71);
    for (g_23.f0 = 3; (g_23.f0 != 19); g_23.f0 = safe_add_func_uint16_t_u_u(g_23.f0, 8))
    { /* block id: 83 */
        struct S0 l_143 = {7U};
        int32_t **l_147 = &g_109;
        struct S0 **l_163 = &l_71;
        int32_t l_200 = (-1);
        int32_t ****l_210 = &l_209;
        const struct S0 *****l_222 = &g_218;
        int32_t *l_235 = &l_158;
        for (g_125 = 0; (g_125 < 52); ++g_125)
        { /* block id: 86 */
            struct S0 l_142 = {0xBE7324BB};
            (*g_108) = (*g_108);
            l_143 = l_142;
            (*g_108) = l_65;
            /* statement id: 89 */
            assert (g_109 == &g_2);
            if ((&p_43 == (void*)0))
            { /* block id: 90 */
                int32_t *l_144 = &g_33;
                (*g_108) = l_65;
                (*l_144) = 0xB2BE9FDC;
                if (l_143.f0)
                    break;
            }
            else
            { /* block id: 94 */
                uint8_t l_146 = 251U;
                l_145 = l_143;
                l_146 = (&g_108 != &g_108);
                if ((((l_146 == g_23.f0) ^ (g_125 != (((void*)0 == l_147) == ((safe_add_func_int8_t_s_s((safe_mod_func_uint8_t_u_u(((*p_44) != (*p_44)), g_125)), (safe_lshift_func_int8_t_s_s(((safe_div_func_int16_t_s_s((safe_mod_func_int8_t_s_s(l_158, g_2)), p_43)) <= 0x7702E8EB), p_43)))) ^ 1)))) != 0x22))
                { /* block id: 97 */
                    int32_t l_164 = 0;
                    struct S0 ***l_174 = (void*)0;
                    struct S0 ****l_173 = &l_174;
                    int32_t *l_175 = &l_158;
                    if (((safe_sub_func_uint16_t_u_u((safe_add_func_int16_t_s_s(((void*)0 != l_163), l_164)), ((((safe_rshift_func_uint16_t_u_u((p_43 | (!(((safe_sub_func_int8_t_s_s(p_42, (l_146 || (l_146 == (((safe_lshift_func_int8_t_s_s(((-1) > (65535U & 0xE451)), 4)) != g_23.f0) == p_43))))) | g_33) <= g_2))), p_43)) == (*l_65)) && g_33) >= g_2))) > g_125))
                    { /* block id: 98 */
                        int16_t l_172 = 0;
                        (*g_108) = (*g_108);
                        l_172 = (**g_108);
                    }
                    else
                    { /* block id: 101 */
                        l_158 = p_43;
                    }
                    (*l_173) = &g_54;
                    /* statement id: 104 */
                    assert (l_174 == &g_54);
                    (*l_175) = 0;
                }
                else
                { /* block id: 106 */
                    int32_t *l_201 = &l_200;
                    const int32_t *l_202 = &l_200;
                    if ((*g_109))
                    { /* block id: 107 */
                        int16_t l_184 = 1;
                        int32_t *l_191 = &g_33;
                        (*l_191) = (((void*)0 == &p_44) & (0U > ((safe_rshift_func_int16_t_s_s(((safe_rshift_func_int8_t_s_s((safe_add_func_uint16_t_u_u((safe_div_func_int32_t_s_s((*g_109), p_42)), l_184)), 1)) && p_43), (safe_rshift_func_int8_t_s_s((((((safe_add_func_int16_t_s_s((p_42 & (safe_sub_func_uint8_t_u_u((1U <= 0xEC947174), l_184))), g_125)) & 0xF62A) || 0U) & 6) ^ l_146), g_125)))) || 65530U)));
                    }
                    else
                    { /* block id: 109 */
                        int32_t ****l_193 = (void*)0;
                        int32_t ***l_195 = (void*)0;
                        int32_t ****l_194 = &l_195;
                        g_192 = (**p_44);
                        if ((*l_65))
                            continue;
                        (*l_194) = &g_108;
                        /* statement id: 112 */
                        assert (l_195 == &g_108);
                        l_200 = (7 ^ (safe_rshift_func_uint8_t_u_u(g_33, (p_43 >= (safe_mod_func_uint32_t_u_u((p_43 > (l_147 == (void*)0)), 0x90C61538))))));
                    }
                    (*l_201) = (*g_109);
                    l_202 = &p_43;
                    /* statement id: 116 */
                    assert (l_202 == &p_43);
                }
                l_205 = (safe_add_func_uint16_t_u_u(g_125, (**l_147)));
            }
        }
        if ((0xFDDE != ((safe_div_func_uint16_t_u_u(((**g_108) | 0xE9FF3C38), 0x43B6)) != (*l_65))))
        { /* block id: 121 */
            int32_t l_215 = 0xEE8E0418;
            int32_t *l_216 = &g_33;
            l_215 = (((l_208 != l_210) || g_2) <= (((safe_add_func_uint8_t_u_u(((*p_45) != (*g_54)), (l_147 == &g_109))) != (0x81 < (((safe_mod_func_int16_t_s_s(p_43, p_42)) == p_42) && g_23.f0))) < 0x9C1B1B48));
            (*l_216) = ((((void*)0 == &l_215) ^ (*g_109)) > (*g_109));
            l_222 = g_217;
        }
        else
        { /* block id: 125 */
            int32_t *l_233 = &g_33;
            struct S0 l_234 = {0x91009C59};
            for (p_42 = 0; (p_42 != 10); p_42++)
            { /* block id: 128 */
            }
            (*l_147) = (*g_108);
            l_234 = (*g_55);
        }
        (*l_235) = ((*l_208) != (*l_210));
        (*l_235) = ((((((g_125 <= (((safe_sub_func_int8_t_s_s(g_2, ((0x53087AE7 & g_2) & 0x384F36AF))) < (safe_div_func_int16_t_s_s((((*l_208) == (*l_210)) < g_23.f0), p_43))) > g_33)) < (*l_235)) != g_2) > p_43) ^ 2) > g_33);
    }
    /* facts after for loop */
    assert (g_109 == &g_2 || g_109 == &g_33);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads : g_33 g_23.f0 g_2 g_108 g_55 g_23 g_54 g_109
 * writes: g_33 g_23.f0 g_23
 */
inline static struct S0  func_56(const int8_t  p_57, struct S0 * p_58)
{ /* block id: 21 */
    const int32_t *l_87 = &g_2;
    const int32_t **l_86 = &l_87;
    const int32_t ***l_88 = &l_86;
    int32_t l_95 = 0x1D26016E;
    int32_t l_98 = 0xA127326B;
    (*l_88) = l_86;
    for (g_33 = 15; (g_33 > 10); g_33 = safe_sub_func_uint8_t_u_u(g_33, 8))
    { /* block id: 25 */
        int32_t *l_94 = &g_33;
        for (g_23.f0 = (-1); (g_23.f0 != 57); ++g_23.f0)
        { /* block id: 28 */
            int32_t *l_93 = (void*)0;
            (**l_88) = l_93;
            /* statement id: 29 */
            assert (l_87 == 0);
            if (g_23.f0)
                continue;
            (**l_88) = l_93;
        }
        /* facts after for loop */
        assert (l_87 == 0 || l_87 == &g_33 || l_87 == &g_2);
        (*l_86) = l_94;
        /* statement id: 33 */
        assert (l_87 == &g_33);
    }
    /* facts after for loop */
    assert (l_87 == &g_33 || l_87 == &g_2);
    l_95 = ((0U ^ ((void*)0 == &p_58)) & 0U);
    if ((safe_sub_func_uint8_t_u_u(((0x578636BC != (((l_98 | p_57) & ((safe_mod_func_int16_t_s_s(1, (safe_sub_func_int16_t_s_s((((((safe_lshift_func_uint8_t_u_u(((**l_86) & (((*l_87) & p_57) ^ ((*l_87) ^ (0 & (**l_86))))), 5)) != g_33) || 3U) || (-1)) ^ p_57), 2U)))) <= p_57)) != 0x4DCBD99A)) ^ (***l_88)), p_57)))
    { /* block id: 36 */
        int32_t * const l_131 = (void*)0;
        struct S0 l_135 = {0U};
        for (l_95 = 0; (l_95 != 9); l_95 = safe_add_func_int16_t_s_s(l_95, 9))
        { /* block id: 39 */
            int32_t *l_107 = &g_2;
            struct S0 *l_123 = (void*)0;
            int8_t l_130 = 1;
            uint32_t l_136 = 0xE8D53535;
            (**l_88) = l_107;
            /* statement id: 40 */
            assert (l_87 == &g_2);
            if ((g_108 == (*l_88)))
            { /* block id: 41 */
                uint8_t l_124 = 0x6D;
                int32_t *l_129 = (void*)0;
                (*p_58) = (*g_55);
                for (g_33 = 0; (g_33 <= (-23)); g_33 = safe_sub_func_int8_t_s_s(g_33, 7))
                { /* block id: 45 */
                    struct S0 l_114 = {0x8A2B653F};
                    int32_t * const l_126 = (void*)0;
                    int32_t **l_132 = &l_129;
                    for (g_23.f0 = 0; (g_23.f0 < 30); ++g_23.f0)
                    { /* block id: 48 */
                        struct S0 *l_115 = &l_114;
                        (*l_115) = l_114;
                    }
                }
                (**g_54) = (*p_58);
                if (l_136)
                    continue;
            }
            else
            { /* block id: 70 */
                int32_t **l_137 = &l_107;
                (*g_109) = 3;
                (*l_137) = l_131;
                /* statement id: 72 */
                assert (l_107 == 0);
            }
            /* facts after branching */
            assert (l_107 == 0 || l_107 == &g_2);
        }
    }
    else
    { /* block id: 75 */
        (**l_88) = (*l_86);
    }
    return (*p_58);
}


/* ------------------------------------------ */
/* 
 * reads : g_33 g_23.f0
 * writes: g_33
 */
static uint8_t  func_66(int8_t  p_67, struct S0 * p_68, struct S0 ** p_69)
{ /* block id: 16 */
    int16_t l_78 = 0x723F;
    int32_t l_83 = 0x8947DE68;
    int32_t *l_85 = &l_83;
    int32_t **l_84 = &l_85;
    l_83 = (((-7) != 0xB0) | (safe_lshift_func_uint8_t_u_u(((safe_lshift_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u(((l_78 | p_67) || ((safe_lshift_func_uint16_t_u_u((safe_mod_func_uint8_t_u_u(l_78, (255U & 0x1C))), (1 >= g_33))) == 0x7DCC)), 7)), 3)) <= g_23.f0), l_78)));
    (*l_84) = &g_33;
    /* statement id: 18 */
    assert (l_85 == &g_33);
    (*l_85) = ((*l_84) == &g_2);
    return p_67;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_7, "g_7", print_hash_value);
    transparent_crc(g_23.f0, "g_23.f0", print_hash_value);
    transparent_crc(g_33, "g_33", print_hash_value);
    transparent_crc(g_125, "g_125", print_hash_value);
    transparent_crc(g_192.f0, "g_192.f0", print_hash_value);
    transparent_crc(g_456, "g_456", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 85
   depth: 1, occurrence: 12
XXX total union variables: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 157
   depth: 2, occurrence: 24
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 26, occurrence: 1

XXX total number of pointers: 104

XXX times a variable address is taken: 100
XXX times a pointer is dereferenced on RHS: 111
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 26
   depth: 3, occurrence: 14
   depth: 4, occurrence: 4
XXX times a pointer is dereferenced on LHS: 75
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 16
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 25
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 342

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 275
   level: 2, occurrence: 141
   level: 3, occurrence: 31
   level: 4, occurrence: 21
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 55
XXX number of pointers point to scalars: 31
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 21.2
XXX average alias set size: 1.15

XXX times a non-volatile is read: 599
XXX times a non-volatile is write: 222
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 126
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 23
   depth: 2, occurrence: 31
   depth: 3, occurrence: 20
   depth: 4, occurrence: 9
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 19.7
XXX percentage an existing variable is used: 80.3
********************* end of statistics **********************/

