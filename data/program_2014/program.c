/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --checksum --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-jumps --no-longlong --force-non-uniform-arrays --no-math64 --no-muls --no-packed-struct --paranoid --pointers --structs --no-inline-function --return-structs --arg-structs --dangling-global-pointers
 * Seed:      13504571659554800225
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 15;
   signed f1 : 10;
   uint8_t  f2;
   const unsigned f3 : 6;
   signed f4 : 21;
   const signed f5 : 15;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_7 = 0xB1C0;
static int32_t g_79 = 0x870B1B9B;
static int32_t *g_78 = &g_79;
static int32_t g_96 = 0x3044B131;
static struct S0 * const g_99 = (void*)0;
static struct S0 g_102 = {104,-21,0x09,5,-1196,40};
static struct S0 *g_101 = &g_102;
static int32_t g_107 = (-1);
static int32_t **g_130 = &g_78;
static int32_t ***g_129 = &g_130;
static struct S0 **g_147 = &g_101;
static int32_t g_189 = 1;
static uint16_t g_292 = 0x661F;
static struct S0 ***g_452 = (void*)0;
static struct S0 ****g_451 = &g_452;
static int16_t g_492 = 0;
static int32_t **** const g_546 = &g_129;
static int32_t **** const *g_545 = &g_546;
static int32_t g_572 = (-9);


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int32_t * func_2(uint8_t  p_3, int32_t * p_4);
static uint32_t  func_14(int32_t * p_15, uint32_t  p_16, uint8_t  p_17);
static int32_t * func_22(int32_t * p_23, int32_t  p_24, int16_t  p_25);
static int32_t * func_26(uint8_t  p_27, int32_t  p_28, int32_t * p_29, int8_t  p_30, const uint16_t  p_31);
static int32_t * func_35(int32_t * p_36, int32_t * p_37, int32_t * p_38, int32_t * p_39, uint32_t  p_40);
static int32_t * func_41(int32_t * p_42, int32_t * p_43, int32_t * const  p_44, int32_t * const  p_45, uint8_t  p_46);
static int32_t * func_48(int16_t  p_49, int32_t  p_50);
static int8_t  func_68(uint16_t  p_69, uint32_t  p_70, int32_t * p_71);
static int8_t  func_72(uint16_t  p_73, uint8_t  p_74, int32_t * p_75);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_7 g_130 g_96 g_129 g_78 g_79 g_189 g_102.f1 g_102.f0 g_102.f5 g_147
 * writes: g_78 g_79 g_107 g_101
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_18 = (void*)0;
    int32_t l_19 = 0;
    int32_t l_186 = 1;
    uint8_t l_205 = 0x83;
    uint32_t l_206 = 1U;
    struct S0 *l_216 = &g_102;
    int32_t ***l_221 = &g_130;
    uint16_t l_306 = 0xEEEF;
    int32_t l_352 = (-1);
    int16_t l_421 = 2;
    struct S0 ***l_446 = &g_147;
    struct S0 ****l_445 = &l_446;
    int32_t ** const *l_450 = (void*)0;
    int32_t ** const * const *l_449 = &l_450;
    uint32_t l_485 = 0U;
    struct S0 *l_507 = &g_102;
    const int8_t l_588 = 0x6F;
    uint32_t l_601 = 0xC8555D86;
    int32_t l_615 = (-5);
    const int8_t l_616 = (-7);
    uint16_t l_619 = 0x1951;
    uint16_t l_621 = 1U;
    const int32_t l_636 = 0x76EEE8C3;
    int32_t l_641 = (-1);
    uint16_t l_644 = 65526U;
    uint16_t l_661 = 6U;
    uint8_t l_664 = 8U;
    uint32_t l_689 = 8U;
    uint16_t l_705 = 0x7DA6;
    uint32_t l_706 = 0x4607D39D;
    (**g_129) = func_2(((((0x39CB61D2 >= (safe_sub_func_int32_t_s_s(g_7, ((safe_rshift_func_uint8_t_u_s((safe_lshift_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(func_14(l_18, l_19, g_7), l_19)), 0)), 1)) <= (safe_add_func_int8_t_s_s(g_7, (&g_101 == &g_99))))))) > g_96) & 5) > l_186), &l_186);
    /* statement id: 61 */
    assert (g_78 == 0);
    for (g_79 = 29; (g_79 != 15); g_79 = safe_sub_func_int16_t_s_s(g_79, 1))
    { /* block id: 64 */
        uint16_t l_204 = 65533U;
        struct S0 *l_207 = &g_102;
        l_19 = g_189;
        g_107 = (((safe_lshift_func_uint8_t_u_u(0x15, 2)) , (((safe_sub_func_int32_t_s_s((((-2) >= (safe_add_func_uint16_t_u_u(((safe_lshift_func_int8_t_s_u((safe_mod_func_int16_t_s_s((1U && (((((void*)0 == &g_130) != (((safe_sub_func_uint16_t_u_u(g_7, (g_102.f1 & ((&g_101 != &g_101) == l_204)))) >= g_102.f0) , (-10))) > g_189) >= 0)), g_189)), g_102.f5)) && l_204), g_102.f1))) != g_102.f5), l_205)) >= g_189) == l_204)) , l_206);
        (*g_147) = l_207;
        (*g_130) = (void*)0;
    }
    for (l_205 = 0; (l_205 == 12); l_205 = safe_add_func_int32_t_s_s(l_205, 1))
    { /* block id: 72 */
        uint32_t l_215 = 4294967286U;
        struct S0 **l_240 = &g_101;
        uint32_t l_245 = 4294967295U;
        uint8_t l_290 = 1U;
        const int32_t *l_295 = &g_107;
        int32_t ***l_348 = &g_130;
        int32_t *** const l_434 = &g_130;
        int32_t * const l_437 = &l_19;
        const struct S0 *l_466 = &g_102;
        uint16_t l_479 = 0xE4A3;
        int32_t l_527 = (-4);
        struct S0 *****l_578 = &g_451;
        uint8_t l_660 = 0xB2;
    }
    return l_706;
}


/* ------------------------------------------ */
/* 
 * reads : g_129 g_130 g_78
 * writes:
 */
static int32_t * func_2(uint8_t  p_3, int32_t * p_4)
{ /* block id: 59 */
    return (**g_129);
    /* statement id: 60 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_130
 * writes: g_78
 */
static uint32_t  func_14(int32_t * p_15, uint32_t  p_16, uint8_t  p_17)
{ /* block id: 1 */
    int32_t *l_47 = (void*)0;
    uint32_t l_108 = 0U;
    uint32_t l_183 = 0x022BA7A0;
    for (p_17 = 0; (p_17 == 18); p_17 = safe_add_func_uint8_t_u_u(p_17, 1))
    { /* block id: 4 */
        int32_t l_32 = 0x9740826F;
        int32_t *l_106 = &g_107;
    }
    (*g_130) = l_47;
    /* statement id: 57 */
    assert (g_78 == 0);
    return l_183;
}


/* ------------------------------------------ */
/* 
 * reads : g_102.f5 g_102.f2 g_78 g_130
 * writes:
 */
static int32_t * func_22(int32_t * p_23, int32_t  p_24, int16_t  p_25)
{ /* block id: 49 */
    int32_t * const *l_176 = &g_78;
    int32_t * const **l_175 = &l_176;
    int32_t l_177 = 0x803A0833;
    int32_t *l_180 = &l_177;
    struct S0 *l_181 = &g_102;
    struct S0 **l_182 = &l_181;
    l_177 = (l_175 == &g_130);
    (*l_180) = (((((-8) < g_102.f5) < (g_102.f2 , (&g_102 == (void*)0))) , 1) | (((&p_24 == (*l_176)) <= (safe_sub_func_uint8_t_u_u((&l_176 == (void*)0), 0xF5))) , 4294967295U));
    (*l_182) = l_181;
    p_24 = p_25;
    return (*g_130);
    /* statement id: 54 */
    //assert (func_22_rv == 0 || func_22_rv == &l_186 || func_22_rv == &g_79);
}


/* ------------------------------------------ */
/* 
 * reads : g_102.f2 g_7 g_102 g_129 g_130 g_78
 * writes: g_102.f2 g_96 g_78
 */
static int32_t * func_26(uint8_t  p_27, int32_t  p_28, int32_t * p_29, int8_t  p_30, const uint16_t  p_31)
{ /* block id: 39 */
    int32_t l_159 = 0x10322505;
    struct S0 *l_163 = &g_102;
    int16_t l_164 = (-1);
    struct S0 **l_166 = (void*)0;
    struct S0 **l_167 = &l_163;
    int32_t l_174 = 0x66615888;
    for (g_102.f2 = 0; (g_102.f2 <= 47); g_102.f2 = safe_add_func_int16_t_s_s(g_102.f2, 8))
    { /* block id: 42 */
        const struct S0 l_158 = {110,-14,0U,3,278,49};
        int32_t *l_165 = &g_96;
        (*l_165) = ((((((safe_rshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_u((safe_rshift_func_uint8_t_u_u((((((p_27 | (l_158 , (((l_159 , (!(safe_sub_func_uint16_t_u_u((p_31 , (&l_158 == (void*)0)), (l_163 == &l_158))))) , &l_163) != &g_99))) , p_28) || l_158.f4) == 1U) , 1U), l_159)), p_28)), 4)) < 1U) <= l_164) , 2U) < g_7) >= l_164);
    }
    (*l_167) = l_163;
    l_174 = (safe_mod_func_int8_t_s_s((((safe_rshift_func_uint8_t_u_s((&l_159 != &l_159), ((*l_163) , ((**l_167) , p_27)))) >= (((safe_lshift_func_int16_t_s_s((&l_159 != (l_164 , func_41(&l_159, &l_159, (**g_129), (*g_130), p_30))), 12)) != l_164) < 4U)) < g_102.f0), l_159));
    /* statement id: 46 */
    assert (g_78 == 0);
    l_159 = ((void*)0 == (*l_167));
    return (*g_130);
    /* statement id: 48 */
    //assert (func_26_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_79 g_102.f5 g_107 g_129 g_102.f4 g_96 g_130
 * writes: g_79 g_78 g_107 g_147
 */
static int32_t * func_35(int32_t * p_36, int32_t * p_37, int32_t * p_38, int32_t * p_39, uint32_t  p_40)
{ /* block id: 20 */
    uint16_t l_113 = 0x6FE1;
    int32_t *l_114 = &g_107;
    struct S0 *l_125 = &g_102;
    uint8_t l_145 = 0xEC;
    for (g_79 = 2; (g_79 != (-18)); g_79 = safe_sub_func_int16_t_s_s(g_79, 5))
    { /* block id: 23 */
        struct S0 l_111 = {87,22,0xEE,2,961,-168};
        int32_t * const l_112 = (void*)0;
        int32_t **l_115 = (void*)0;
        int32_t **l_116 = &g_78;
        (*l_116) = func_41(func_41(p_38, (l_111 , p_39), p_36, l_112, l_113), l_114, l_114, p_38, g_102.f5);
        /* statement id: 24 */
        assert (g_78 == &g_107);
    }
    /* facts after for loop */
    assert (g_78 == &g_107 || g_78 == 0);
    for (g_79 = (-29); (g_79 >= 22); g_79++)
    { /* block id: 28 */
        int32_t *l_123 = &g_107;
        struct S0 l_124 = {44,-10,0U,0,-771,-156};
        int32_t l_128 = 5;
        int32_t ***l_131 = &g_130;
        uint32_t l_132 = 4294967295U;
        uint8_t l_144 = 0x48;
        struct S0 **l_146 = &l_125;
        if ((safe_add_func_int32_t_s_s((safe_lshift_func_uint16_t_u_s(((((((p_38 != l_123) == ((l_124 , l_125) != (void*)0)) & (safe_lshift_func_int8_t_s_s(((&l_125 != (void*)0) == (((((void*)0 != &l_123) && (*l_123)) , (void*)0) == &p_37)), l_128))) , g_129) != l_131) ^ l_132), 5)), (*p_37))))
        { /* block id: 29 */
            uint32_t l_133 = 8U;
            (*l_114) = (l_133 || (((safe_sub_func_uint32_t_u_u(((0xB622C330 >= (p_40 | g_79)) >= (~((-1) ^ ((safe_rshift_func_uint16_t_u_u(((((*l_123) & (safe_lshift_func_uint16_t_u_u(0U, (*l_114)))) | (+(0x35819B78 == (*l_114)))) >= p_40), (*l_114))) > g_102.f4)))), l_144)) == g_96) , g_96));
            l_145 = 0x9A429F2D;
        }
        else
        { /* block id: 32 */
            (*p_37) = (*l_123);
            (**g_129) = p_37;
            /* statement id: 34 */
            assert (g_78 == &g_107);
        }
        g_147 = l_146;
        /* statement id: 36 */
        assert (g_147 == &l_125);
    }
    /* facts after for loop */
    assert (g_147 == &l_125 || g_147 == &g_101);
    return p_36;
    /* statement id: 38 */
    //assert (g_147 == dangling || g_147 == &g_101);
    //assert (func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_78
 */
static int32_t * func_41(int32_t * p_42, int32_t * p_43, int32_t * const  p_44, int32_t * const  p_45, uint8_t  p_46)
{ /* block id: 16 */
    int32_t **l_103 = &g_78;
    struct S0 **l_104 = (void*)0;
    struct S0 **l_105 = &g_101;
    (*l_103) = (void*)0;
    /* statement id: 17 */
    assert (g_78 == 0);
    l_105 = l_104;
    /* statement id: 18 */
    assert (l_105 == 0);
    return p_43;
    /* statement id: 19 */
    //assert (func_41_rv == 0 || func_41_rv == &g_107 || func_41_rv == &l_159 || func_41_rv == &l_186);
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_78 g_79 g_96 g_99
 * writes: g_79 g_96 g_101
 */
static int32_t * func_48(int16_t  p_49, int32_t  p_50)
{ /* block id: 5 */
    uint8_t l_62 = 0U;
    int32_t *l_95 = &g_96;
    struct S0 **l_100 = (void*)0;
    (*l_95) = ((safe_rshift_func_uint16_t_u_s((safe_rshift_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_s((safe_add_func_int16_t_s_s((0x36 == (~(safe_sub_func_uint32_t_u_u(l_62, (safe_add_func_int8_t_s_s((~(g_7 , (safe_lshift_func_int16_t_s_s((func_68((func_72((safe_lshift_func_uint8_t_u_u(p_50, 2)), g_7, g_78) || ((g_79 , g_79) ^ (*g_78))), g_7, l_95) > (*l_95)), 15)))), (*l_95))))))), (-3))), p_49)), 5)), g_7)) >= p_50);
    g_101 = g_99;
    /* statement id: 14 */
    assert (g_101 == 0);
    return &g_79;
    /* statement id: 15 */
    //assert (func_48_rv == &g_79);
}


/* ------------------------------------------ */
/* 
 * reads : g_96
 * writes:
 */
static int8_t  func_68(uint16_t  p_69, uint32_t  p_70, int32_t * p_71)
{ /* block id: 10 */
    int32_t **l_98 = &g_78;
    int32_t ***l_97 = &l_98;
    (*l_97) = &p_71;
    /* statement id: 11 */
    assert (l_98 == &p_71);
    return g_96;
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_79 g_78
 * writes: g_79
 */
static int8_t  func_72(uint16_t  p_73, uint8_t  p_74, int32_t * p_75)
{ /* block id: 6 */
    int32_t ***l_80 = (void*)0;
    int32_t **l_82 = &g_78;
    int32_t ***l_81 = &l_82;
    (*l_81) = &g_78;
    (*g_78) = ((safe_rshift_func_int8_t_s_u((safe_mod_func_int32_t_s_s((g_7 | (safe_add_func_uint32_t_u_u((1U & ((-1) == ((!(((safe_add_func_int32_t_s_s((((safe_rshift_func_uint16_t_u_s((((void*)0 == &g_78) && 0x4FEC), 13)) <= ((void*)0 == &g_78)) | (((~(g_79 ^ g_7)) == p_73) | p_74)), g_7)) , p_73) , 0x3070B7B2)) , g_79))), (***l_81)))), (*g_78))), g_79)) , (*p_75));
    return (***l_81);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_7, "g_7", print_hash_value);
    transparent_crc(g_79, "g_79", print_hash_value);
    transparent_crc(g_96, "g_96", print_hash_value);
    transparent_crc(g_102.f0, "g_102.f0", print_hash_value);
    transparent_crc(g_102.f1, "g_102.f1", print_hash_value);
    transparent_crc(g_102.f2, "g_102.f2", print_hash_value);
    transparent_crc(g_102.f3, "g_102.f3", print_hash_value);
    transparent_crc(g_102.f4, "g_102.f4", print_hash_value);
    transparent_crc(g_102.f5, "g_102.f5", print_hash_value);
    transparent_crc(g_107, "g_107", print_hash_value);
    transparent_crc(g_189, "g_189", print_hash_value);
    transparent_crc(g_292, "g_292", print_hash_value);
    transparent_crc(g_492, "g_492", print_hash_value);
    transparent_crc(g_572, "g_572", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 149
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 26
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 9
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 7
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 87

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 8
   depth: 12, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 24, occurrence: 1

XXX total number of pointers: 106

XXX times a variable address is taken: 122
XXX times a pointer is dereferenced on RHS: 112
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 19
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
XXX times a pointer is dereferenced on LHS: 67
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 16
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 30
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 683

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 191
   level: 2, occurrence: 112
   level: 3, occurrence: 176
   level: 4, occurrence: 55
   level: 5, occurrence: 25
XXX number of pointers point to pointers: 55
XXX number of pointers point to scalars: 42
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 31.1
XXX average alias set size: 1.31

XXX times a non-volatile is read: 798
XXX times a non-volatile is write: 197
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 44
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 8
   depth: 2, occurrence: 4

XXX percentage a fresh-made variable is used: 14.7
XXX percentage an existing variable is used: 85.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

