/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --checksum --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-jumps --longlong --force-non-uniform-arrays --math64 --no-muls --no-packed-struct --paranoid --pointers --structs --no-inline-function --return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      11071871582852143226
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint8_t  f0;
   uint32_t  f1;
   int32_t  f2;
   uint32_t  f3;
   uint64_t  f4;
   int32_t  f5;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_4 = (-1L);
static int32_t g_48 = 0x2E8B5A47L;
static int32_t *g_52 = (void*)0;
static int32_t **g_51 = &g_52;
static int32_t g_54 = (-1L);
static int32_t g_57 = 0xA2D3C5EBL;
static int32_t g_60 = 0x19B17C08L;
static int32_t g_63 = (-1L);
static struct S0 g_124 = {6UL,18446744073709551615UL,0x84A9EC0CL,2UL,0UL,-1L};
static struct S0 *g_126 = &g_124;
static int32_t ***g_256 = &g_51;
static int32_t ****g_255 = &g_256;
static int32_t g_354 = 8L;
static int32_t *g_510 = (void*)0;
static struct S0 *g_541 = (void*)0;
static int8_t g_560 = 0x75L;
static struct S0 **g_598 = &g_126;
static struct S0 ***g_597 = &g_598;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t * func_6(int32_t * p_7, uint32_t  p_8, int32_t * p_9);
static int64_t  func_10(uint32_t  p_11, int16_t  p_12);
static int8_t  func_16(uint64_t  p_17, uint32_t  p_18, uint8_t  p_19);
static int32_t  func_22(int8_t  p_23, int16_t  p_24, uint32_t  p_25);
static int32_t * func_32(int32_t  p_33, uint16_t  p_34, int64_t  p_35, int32_t * p_36);
static uint32_t  func_37(uint32_t  p_38);
static int16_t  func_40(uint16_t  p_41, int32_t * p_42, int32_t * p_43, int32_t  p_44, uint16_t  p_45);
static int64_t  func_46(int32_t * p_47);
static int32_t * func_66(int16_t  p_67, int32_t ** p_68, uint8_t  p_69, int32_t  p_70, int32_t * p_71);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_48 g_51 g_54 g_63 g_52 g_60 g_57 g_124.f4 g_124.f2 g_124.f1 g_124.f3 g_126 g_124 g_255 g_256 g_510 g_354 g_541 g_597 g_560 g_598
 * writes: g_4 g_48 g_54 g_57 g_60 g_63 g_52 g_126 g_124 g_255
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int8_t l_2 = 0xBBL;
    int32_t *l_3 = &g_4;
    int16_t l_5 = 0x6338L;
    int64_t l_30 = 0x9ED02E889EC0021FLL;
    uint32_t l_31 = 4294967291UL;
    (*l_3) = l_2;
    (*l_3) = l_5;
    (**g_256) = func_6(((g_4 && func_10((*l_3), ((!(*l_3)) == (safe_sub_func_int8_t_s_s(func_16(((safe_sub_func_int32_t_s_s(func_22((*l_3), (*l_3), (((safe_rshift_func_int16_t_s_u((safe_mod_func_int64_t_s_s(((((l_30 > l_31) , &g_4) != &g_4) == (*l_3)), 0xCAAD901516EA3DE8LL)), 13)) <= g_4) != 6UL)), (*l_3))) != 0xFCCBL), g_354, g_354), g_560))))) , (void*)0), l_5, l_3);
    /* statement id: 394 */
    assert (g_52 == &g_60);
    //assert (g_126 == &g_124 || g_126 == 0 || g_126 == dangling);
    (**g_256) = l_3;
    /* statement id: 395 */
    assert (g_52 == &g_4);
    return (*l_3);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_124
 */
static int32_t * func_6(int32_t * p_7, uint32_t  p_8, int32_t * p_9)
{ /* block id: 391 */
    struct S0 l_818 = {0x95L,0x7ACBECB9L,4L,0UL,0x3E401DE5A59348C9LL,0L};
    struct S0 *l_819 = &g_124;
    int32_t *l_820 = &g_60;
    (*l_819) = l_818;
    return l_820;
    /* statement id: 393 */
    //assert (func_6_rv == &g_60);
}


/* ------------------------------------------ */
/* 
 * reads : g_255 g_256 g_51 g_54 g_63 g_124.f1 g_354 g_52 g_4 g_124.f0 g_124.f2 g_48 g_560 g_124.f3 g_57 g_597 g_598 g_124.f5 g_60 g_124.f4
 * writes: g_52 g_57 g_63 g_124 g_4
 */
static int64_t  func_10(uint32_t  p_11, int16_t  p_12)
{ /* block id: 287 */
    int32_t **l_603 = &g_52;
    int64_t l_604 = 0xCF0AD12C9894A632LL;
    uint64_t l_607 = 18446744073709551606UL;
    uint64_t l_617 = 0x81487B3E5EAF0BA9LL;
    struct S0 l_622 = {1UL,1UL,0x705A21D2L,8UL,1UL,1L};
    int32_t ****l_657 = (void*)0;
    int32_t l_686 = (-2L);
    int64_t l_687 = 0x7EA3AED44A4BE7DDLL;
    int32_t l_710 = (-6L);
    uint32_t l_729 = 0x2A0DDC87L;
    struct S0 l_777 = {0x44L,0x6BC56DFEL,-10L,0x361D446EL,0xD3C951A5BE333ABCLL,1L};
    int8_t l_813 = 0xC3L;
    int32_t *l_817 = &g_63;
    if (((0xA0CFF893L != p_11) || 0xEC00230EL))
    { /* block id: 288 */
        int32_t *l_601 = (void*)0;
        struct S0 *l_623 = &g_124;
        (***g_255) = l_601;
        if (p_11)
        { /* block id: 290 */
            int32_t ***l_602 = &g_51;
            int32_t l_608 = 0xA34A7A84L;
            int32_t *l_618 = &g_57;
            (**l_602) = func_66((l_602 == (*g_255)), l_603, (((p_12 ^ (g_54 == ((0x31L && l_604) > (safe_rshift_func_int8_t_s_u((g_63 > (((l_607 , g_124.f1) < 0UL) | g_354)), 6))))) < g_354) < 0x8D9F5DE02F41B75ALL), l_608, (***g_255));
            (*l_618) = (((((p_12 >= ((((**g_255) == (*g_256)) , (safe_add_func_uint8_t_u_u((((((((((((void*)0 == l_601) >= g_124.f0) & (!l_608)) && ((safe_lshift_func_uint16_t_u_u(((((~0xF96A17B4L) != (safe_rshift_func_uint16_t_u_s(g_63, 14))) , g_4) || 65535UL), 12)) , 0x02EDBEB6L)) == l_617) > g_63) <= g_63) , g_124.f2) < (-1L)) && p_12), p_12))) , (-1L))) | g_63) & 0xB8L) > 0xC509L) >= p_11);
        }
        else
        { /* block id: 293 */
            int8_t l_619 = (-10L);
            return l_619;
        }
        for (g_63 = 0; (g_63 != 18); g_63 = safe_add_func_uint64_t_u_u(g_63, 9))
        { /* block id: 298 */
            return g_48;
        }
        (*l_623) = l_622;
    }
    else
    { /* block id: 302 */
        int32_t l_628 = 8L;
        uint32_t l_641 = 0xE1A40446L;
        struct S0 l_649 = {1UL,1UL,0xBF4D6736L,6UL,0x6856A916DC7B25B3LL,0x8B658DFEL};
        int32_t *l_663 = &g_54;
        int32_t *l_672 = (void*)0;
        int32_t *l_673 = &g_124.f5;
        struct S0 ***l_674 = &g_598;
        struct S0 *l_685 = &l_649;
        int32_t l_705 = 0xA97D4829L;
        int32_t *****l_745 = &g_255;
        struct S0 l_792 = {0UL,18446744073709551612UL,-1L,0x3DA477A4L,0x6283B564713C11DALL,9L};
        int16_t l_796 = 0xA14BL;
        struct S0 l_816 = {0xF3L,0UL,0x6761BCDAL,18446744073709551607UL,0UL,2L};
        if (((((!(safe_rshift_func_uint8_t_u_s((!((g_124.f1 ^ ((((g_4 && (l_628 > (((p_11 > (safe_mod_func_int8_t_s_s((((((void*)0 == &l_622) <= (safe_sub_func_uint8_t_u_u((safe_add_func_uint32_t_u_u(1UL, (((safe_sub_func_int16_t_s_s((l_628 | (-3L)), p_11)) > p_11) , p_11))), 249UL))) == 0x6827L) != g_560), g_354))) == 0x98D8L) ^ g_124.f3))) | 0UL) != p_11) == 0UL)) < p_12)), 5))) > p_12) <= p_11) & l_628))
        { /* block id: 303 */
            int32_t *l_645 = &g_63;
            for (l_622.f3 = (-27); (l_622.f3 >= 39); l_622.f3 = safe_add_func_int8_t_s_s(l_622.f3, 1))
            { /* block id: 306 */
                return g_124.f0;
            }
            if ((g_57 , (g_354 >= ((safe_lshift_func_int16_t_s_u(l_628, 2)) < (l_641 == 0L)))))
            { /* block id: 309 */
                (*g_51) = (void*)0;
                (*g_51) = l_645;
                /* statement id: 311 */
                assert (g_52 == &g_63);
                l_645 = l_645;
            }
            else
            { /* block id: 313 */
                (**g_256) = l_645;
                /* statement id: 314 */
                assert (g_52 == &g_63);
            }
            /* facts after branching */
            assert (g_52 == &g_63);
        }
        else
        { /* block id: 316 */
            uint32_t l_652 = 0xF7B31893L;
            int32_t l_662 = 3L;
            for (g_4 = 0; (g_4 == 3); g_4++)
            { /* block id: 319 */
                uint32_t l_648 = 0UL;
                struct S0 *l_650 = &g_124;
                uint16_t l_651 = 0xD901L;
                l_628 = l_648;
                (*l_650) = l_649;
                if (l_651)
                    break;
            }
            l_662 = (((l_652 , (0xA0F46BCD9572BA5CLL >= (safe_lshift_func_int8_t_s_s(((safe_add_func_uint16_t_u_u(g_354, l_652)) || (&g_256 != l_657)), (p_11 , (safe_lshift_func_int16_t_s_u((safe_sub_func_int16_t_s_s(((0L | 1L) < 4294967286UL), g_124.f2)), g_124.f3))))))) , (*g_597)) != (void*)0);
            l_663 = (*g_51);
            /* statement id: 325 */
            assert (l_663 == 0);
            for (l_607 = 0; (l_607 == 7); l_607 = safe_add_func_uint32_t_u_u(l_607, 2))
            { /* block id: 328 */
                int64_t l_666 = (-4L);
                (***g_255) = &l_662;
                /* statement id: 329 */
                assert (g_52 == &l_662);
            }
            /* facts after for loop */
            assert (g_52 == &l_662 || g_52 == 0);
        }
        /* facts after branching */
        //assert (g_52 == dangling || g_52 == 0 || g_52 == &g_63);
        assert (l_663 == 0 || l_663 == &g_54);
        for (g_57 = 0; (g_57 == 29); g_57 = safe_add_func_int32_t_s_s(g_57, 2))
        { /* block id: 334 */
            struct S0 *l_669 = &l_649;
            struct S0 ***l_670 = &g_598;
            int32_t *l_671 = &g_60;
            (*l_669) = l_622;
            (***g_255) = (((void*)0 != l_670) , l_671);
            /* statement id: 336 */
            assert (g_52 == &g_60);
        }
        /* facts after for loop */
        //assert (g_52 == &g_60 || g_52 == dangling || g_52 == 0 || g_52 == &g_63);
        (*l_673) = (-1L);
        if ((((((((void*)0 != l_674) | (safe_add_func_uint8_t_u_u(g_124.f2, ((((safe_lshift_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_lshift_func_int8_t_s_s((safe_lshift_func_uint8_t_u_s((p_11 == (((l_685 != &l_649) == ((l_622 , 0L) >= ((((p_12 | 0xE0A2D795BA79787BLL) < g_48) , p_11) | 0xF2282522L))) == 0x192A7B3DL)), 0)), l_686)), 5)), l_687)) && p_12) , g_124.f5) == 0x9522L)))) && g_48) & g_4) , 0x8EEBL) | g_60))
        { /* block id: 339 */
            uint16_t l_702 = 65535UL;
            int32_t *l_707 = (void*)0;
            int8_t l_717 = 0x28L;
            (*l_603) = &l_628;
            /* statement id: 340 */
            assert (g_52 == &l_628);
            if ((((safe_mod_func_int32_t_s_s(((((p_11 == (((0x63CEBF54FBAC102ELL <= (g_60 , (safe_add_func_uint16_t_u_u((safe_add_func_int8_t_s_s((((safe_sub_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(0UL, g_57)), ((p_11 , (safe_mod_func_int8_t_s_s((l_702 || (safe_add_func_int32_t_s_s(((**l_603) != (((g_4 && p_11) != g_124.f4) >= g_560)), p_12))), p_12))) == 0UL))) != p_12) ^ 1L), 7UL)), (*l_673))))) , p_12) != l_705)) == p_11) , p_11) , p_12), p_11)) | g_124.f4) , p_12))
            { /* block id: 341 */
                (*g_52) = 0x1BB68E49L;
            }
            else
            { /* block id: 343 */
                int32_t *l_706 = (void*)0;
                (***g_256) = (**g_51);
                (*l_685) = (*l_685);
                l_707 = l_706;
                if ((((safe_mod_func_int8_t_s_s(((l_710 , (+((safe_rshift_func_uint16_t_u_s(((~(p_12 == (safe_lshift_func_uint8_t_u_s((l_717 | (safe_lshift_func_int16_t_s_s(1L, 8))), 2)))) && 18446744073709551615UL), 0)) >= (((((((safe_sub_func_uint8_t_u_u((g_4 == (safe_sub_func_int8_t_s_s((((((**g_51) , (((safe_lshift_func_uint8_t_u_s(0xB8L, (safe_lshift_func_int16_t_s_s(((((((!(p_11 | p_11)) , (-7L)) || 0x0AL) & 6UL) != (**l_603)) > g_48), p_11)))) < 0x2E63L) == p_12)) < 0x69L) < 0L) && g_354), 0x7CL))), l_729)) ^ g_57) || g_4) || p_12) >= 0x3A1EA945D926B495LL) , (void*)0) == (void*)0)))) ^ 0xBBL), p_11)) == 0x350FB7AA319BC4F5LL) <= 0xC9C312813191A5F1LL))
                { /* block id: 347 */
                    struct S0 *l_740 = &g_124;
                    int32_t l_748 = 0x7A6995A4L;
                    (*g_52) = (p_11 != (p_12 & (safe_mod_func_uint64_t_u_u(((safe_unary_minus_func_int16_t_s(g_124.f2)) != ((safe_add_func_uint8_t_u_u((+(safe_sub_func_int32_t_s_s(((safe_mod_func_uint16_t_u_u(((((void*)0 == l_740) || p_11) != (safe_lshift_func_int16_t_s_u((((safe_sub_func_uint8_t_u_u((((void*)0 == l_745) , (safe_lshift_func_uint16_t_u_u(g_124.f1, l_748))), l_748)) , g_54) <= g_57), 15))), g_354)) >= p_12), 0xAADBD382L))), p_12)) == p_12)), (**l_603)))));
                    (*l_740) = (*l_685);
                }
                else
                { /* block id: 350 */
                    (*g_51) = (****l_745);
                }
            }
        }
        else
        { /* block id: 354 */
            int32_t ***l_752 = &l_603;
            int32_t *l_762 = &g_60;
            struct S0 *l_788 = &l_622;
            struct S0 l_794 = {0x7EL,18446744073709551615UL,-1L,0xEA2B1D6FL,18446744073709551615UL,0xD209FA9CL};
            (*l_603) = (void*)0;
            /* statement id: 355 */
            assert (g_52 == 0);
            if (p_11)
            { /* block id: 356 */
                int8_t l_749 = 9L;
                uint8_t l_753 = 0xAAL;
                struct S0 ***l_778 = &g_598;
                (****l_745) = (*l_603);
                if ((((g_124.f1 & l_749) , ((safe_sub_func_uint8_t_u_u(p_12, (((void*)0 != l_752) <= l_753))) > (+(safe_sub_func_uint8_t_u_u((((safe_lshift_func_uint16_t_u_u(p_11, (p_12 >= (safe_mod_func_int32_t_s_s(p_11, p_12))))) , 1L) ^ 0x19L), (-5L)))))) && p_11))
                { /* block id: 358 */
                    int32_t *l_761 = &g_4;
                    struct S0 **l_791 = &l_685;
                    l_762 = l_761;
                    /* statement id: 359 */
                    assert (l_762 == &g_4);
                    for (l_628 = (-8); (l_628 == 23); l_628 = safe_add_func_uint8_t_u_u(l_628, 4))
                    { /* block id: 362 */
                        int32_t l_779 = 1L;
                        (*l_673) = 0x19EED8B2L;
                        l_779 = (safe_sub_func_uint64_t_u_u((safe_mod_func_int64_t_s_s((((safe_add_func_int32_t_s_s((safe_mod_func_uint64_t_u_u((g_54 < (safe_add_func_uint16_t_u_u(((p_12 && ((safe_rshift_func_int8_t_s_s(g_124.f5, 0)) < (l_777 , 0x88L))) <= (l_778 == (void*)0)), (((l_779 , 1L) == l_753) | p_12)))), 0xFBAA393B0EDFEDDDLL)), g_4)) || 8L) ^ (-5L)), p_12)), g_48));
                        (****l_745) = ((((((safe_add_func_int8_t_s_s(g_560, p_12)) , ((safe_mod_func_uint16_t_u_u((safe_sub_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(((p_12 ^ 0xD9L) , 4294967289UL), p_11)), 0xEF9CL)), g_124.f0)) > p_12)) , &g_124) != l_788) == p_12) , (void*)0);
                    }
                    if (((((safe_add_func_uint16_t_u_u(p_12, g_48)) | g_4) , (void*)0) != l_791))
                    { /* block id: 367 */
                        (*l_673) = 2L;
                        (*l_788) = l_792;
                    }
                    else
                    { /* block id: 370 */
                        return (*l_761);
                    }
                }
                else
                { /* block id: 373 */
                    int32_t l_793 = (-6L);
                    if (l_793)
                    { /* block id: 374 */
                        (*l_788) = l_794;
                    }
                    else
                    { /* block id: 376 */
                        struct S0 l_795 = {0xD3L,0UL,0x4D9AF407L,18446744073709551615UL,18446744073709551614UL,-1L};
                        int64_t l_802 = 0x8CCEA7E4E29A704ALL;
                        (*l_673) = (l_795 , (l_796 | (((safe_rshift_func_int8_t_s_s((safe_add_func_int64_t_s_s((0x07C61065L | (((p_12 == ((~((l_802 , ((l_793 , (((safe_rshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_s(((safe_add_func_uint32_t_u_u((((safe_add_func_int64_t_s_s(l_795.f1, p_11)) , ((safe_add_func_uint32_t_u_u(g_57, 0xA0C15527L)) != g_560)) != l_793), g_354)) <= p_11), l_813)), 4)) < 0xCEE2AF28L) ^ 0xFB8D6590ACFD62EELL)) != l_795.f5)) >= p_12)) == 0x58E8D2FD6A6E79A6LL)) || 0x546BL) <= p_11)), (*l_762))), 2)) && 18446744073709551606UL) >= p_11)));
                    }
                }
                /* facts after branching */
                assert (l_762 == &g_60 || l_762 == &g_4);
            }
            else
            { /* block id: 380 */
                for (l_617 = (-2); (l_617 == 53); ++l_617)
                { /* block id: 383 */
                    (*l_788) = l_816;
                }
            }
            /* facts after branching */
            assert (l_762 == &g_60 || l_762 == &g_4);
        }
        /* facts after branching */
        assert (g_52 == 0 || g_52 == &l_628);
    }
    /* facts after branching */
    //assert (g_52 == 0 || g_52 == dangling);
    (*l_817) = l_617;
    return g_124.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_124.f5 g_57 g_255 g_256 g_51 g_124.f2 g_60 g_63 g_541 g_52 g_124.f4 g_597 g_4
 * writes: g_63 g_52 g_124.f4
 */
static int8_t  func_16(uint64_t  p_17, uint32_t  p_18, uint8_t  p_19)
{ /* block id: 253 */
    int32_t l_512 = (-9L);
    int32_t *****l_521 = &g_255;
    int32_t l_525 = 0x5229BD18L;
    int32_t *l_526 = &g_63;
    int16_t l_540 = 0L;
    uint32_t l_582 = 4UL;
    int32_t *l_599 = &g_63;
    struct S0 ***l_600 = &g_598;
    (*l_526) = (((!l_512) && ((((!((safe_mod_func_uint8_t_u_u((((l_512 ^ (((((((safe_sub_func_uint32_t_u_u((~(safe_add_func_int64_t_s_s((((((l_521 == l_521) > (((safe_add_func_int64_t_s_s(g_124.f5, ((g_57 >= (safe_unary_minus_func_uint8_t_u((((***l_521) == (**g_255)) , (((p_17 , p_17) <= g_124.f2) ^ l_525))))) != g_60))) && (-1L)) < (-1L))) , &g_124) != (void*)0) || 0xB60DADA4L), g_60))), p_18)) , p_19) >= g_63) | g_60) >= g_124.f5) && 0xDEDEL) > 1L)) ^ l_512) ^ 0xAA3DL), g_124.f2)) ^ l_525)) == 0x9A509C77L) == p_17) ^ l_512)) >= 18446744073709551615UL);
    (*g_51) = (void*)0;
    /* statement id: 255 */
    assert (g_52 == 0);
    if ((*l_526))
    { /* block id: 256 */
        struct S0 l_527 = {0xA3L,0x3A25BEE8L,-1L,0xCC7CCA2DL,1UL,0L};
        struct S0 *l_528 = &l_527;
        (*l_528) = l_527;
    }
    else
    { /* block id: 258 */
        uint16_t l_529 = 0x1D05L;
        int32_t *l_542 = &g_60;
        uint16_t l_561 = 1UL;
        struct S0 *l_594 = (void*)0;
        (*l_526) = (l_529 >= ((safe_lshift_func_int16_t_s_s((safe_add_func_int8_t_s_s((!g_124.f2), (0xE0ED6515E152BCCALL ^ p_19))), ((safe_rshift_func_int8_t_s_s(((!(1L == l_529)) ^ (safe_rshift_func_uint8_t_u_u(251UL, 2))), l_540)) ^ (&g_124 == g_541)))) || g_63));
        (**g_256) = l_542;
        /* statement id: 260 */
        assert (g_52 == &g_60);
        (*l_526) = (safe_lshift_func_int8_t_s_s(0xDBL, 2));
        if (p_18)
        { /* block id: 262 */
            uint16_t l_552 = 0x6661L;
            int32_t *l_562 = &g_63;
            (*g_51) = l_562;
            /* statement id: 263 */
            assert (g_52 == &g_63);
            (**g_256) = (***g_255);
        }
        else
        { /* block id: 265 */
            uint8_t l_589 = 0x69L;
            for (g_124.f4 = 25; (g_124.f4 < 37); g_124.f4++)
            { /* block id: 268 */
                int16_t l_581 = 0x89DCL;
                int32_t *****l_590 = (void*)0;
                struct S0 l_591 = {0UL,0x44177C9FL,0xC0B4E08BL,0x71AA7F24L,18446744073709551608UL,0xECF0C196L};
                struct S0 **l_592 = &g_541;
            }
        }
        /* facts after branching */
        assert (g_52 == &g_60 || g_52 == &g_63);
    }
    /* facts after branching */
    assert (g_52 == &g_60 || g_52 == &g_63 || g_52 == 0);
    (***g_255) = func_66(((((safe_lshift_func_uint16_t_u_s(((((((g_597 != ((((void*)0 == (****l_521)) & ((p_17 & p_18) , ((****l_521) != l_599))) , l_600)) == 18446744073709551615UL) , (*l_526)) && (*l_599)) <= g_60) == (*l_599)), 4)) || 0L) , p_19) != g_57), (***l_521), p_18, p_17, (****l_521));
    /* statement id: 285 */
    assert (g_52 == 0);
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_48 g_51 g_54 g_63 g_52 g_60 g_57 g_124.f4 g_124.f2 g_124.f1 g_124.f3 g_126 g_124 g_255 g_256 g_510
 * writes: g_48 g_54 g_57 g_60 g_63 g_52 g_126 g_124 g_255
 */
static int32_t  func_22(int8_t  p_23, int16_t  p_24, uint32_t  p_25)
{ /* block id: 3 */
    int32_t *l_39 = &g_4;
    (**g_256) = func_32(((p_24 <= func_37((((void*)0 != l_39) && func_40((((*l_39) ^ ((-1L) < func_46(&g_4))) , (((*l_39) == ((safe_lshift_func_int16_t_s_u((((((void*)0 == l_39) >= (*l_39)) > p_25) && (*l_39)), 8)) ^ 1L)) , g_54)), l_39, l_39, g_4, g_4)))) & (-10L)), (*l_39), g_4, l_39);
    /* statement id: 251 */
    assert (g_52 == &g_4 || g_52 == &g_124.f5 || g_52 == 0);
    //assert (g_126 == &g_124 || g_126 == 0 || g_126 == dangling);
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads : g_124.f1 g_124.f2 g_124.f4 g_124.f3 g_126 g_124 g_60 g_57 g_51 g_48 g_63 g_4 g_52 g_54 g_255 g_256 g_510
 * writes: g_124 g_60 g_52 g_126 g_57 g_255 g_63
 */
static int32_t * func_32(int32_t  p_33, uint16_t  p_34, int64_t  p_35, int32_t * p_36)
{ /* block id: 48 */
    struct S0 l_143 = {0xA8L,0x09466F02L,-8L,9UL,0xD460A75574C4D6AALL,0x532EA630L};
    struct S0 *l_162 = &l_143;
    uint16_t l_185 = 65535UL;
    int32_t ***l_197 = &g_51;
    uint16_t l_314 = 0xB9C0L;
    uint8_t l_315 = 247UL;
    struct S0 **l_324 = &g_126;
    int32_t *****l_349 = &g_255;
    int32_t l_416 = 0x01123188L;
    if (((l_143 , (((safe_lshift_func_uint8_t_u_s(((safe_lshift_func_int16_t_s_s(0x2DABL, 13)) != g_124.f1), (((((~((4294967295UL & (g_124.f2 & ((g_124.f4 & (!g_124.f1)) < (l_143.f0 <= l_143.f5)))) & 0UL)) | 1L) ^ g_124.f3) < l_143.f0) , (-1L)))) <= (-1L)) , p_35)) != l_143.f1))
    { /* block id: 49 */
        int32_t *l_154 = &g_124.f5;
        struct S0 *l_173 = &l_143;
        uint16_t l_221 = 65535UL;
        uint8_t l_260 = 1UL;
        uint64_t l_281 = 0x20C1789064FA2586LL;
        int32_t ****l_304 = &g_256;
        (*g_126) = (*g_126);
        for (g_60 = 0; (g_60 != (-21)); --g_60)
        { /* block id: 53 */
            return l_154;
            /* statement id: 54 */
            //assert (func_32_rv == &g_124.f5);
        }
        if (l_143.f0)
        { /* block id: 56 */
            struct S0 *l_165 = &g_124;
            int32_t **l_172 = &l_154;
            struct S0 **l_179 = (void*)0;
            int32_t *l_183 = &g_124.f5;
            int32_t ****l_259 = (void*)0;
            if ((safe_sub_func_int64_t_s_s(p_34, ((safe_sub_func_uint8_t_u_u(((((safe_mod_func_int64_t_s_s((p_34 > ((~0x5103L) <= (-1L))), ((&l_143 == l_162) , (safe_rshift_func_int16_t_s_s(((((((((l_165 != ((safe_add_func_int16_t_s_s((safe_mod_func_int16_t_s_s(((((((safe_sub_func_int64_t_s_s(((void*)0 == l_172), (**l_172))) , &g_126) != (void*)0) , 0L) , (*l_154)) < g_124.f3), (*l_154))), g_57)) , l_173)) == 255UL) ^ (*l_154)) & (*l_154)) == 0xD7L) != (*l_154)) & 1UL) > p_34), 6))))) ^ 5L) > 0x4FE049F0L) || g_124.f2), (-1L))) , 0UL))))
            { /* block id: 57 */
                int32_t *l_174 = &g_57;
                int32_t ***l_175 = &l_172;
                (*g_51) = l_174;
                /* statement id: 58 */
                assert (g_52 == &g_57);
                (*l_175) = (void*)0;
                /* statement id: 59 */
                assert (l_172 == 0);
            }
            else
            { /* block id: 60 */
                struct S0 l_186 = {249UL,18446744073709551608UL,-3L,0xCD91B382L,0xD8845D90A4EEA325LL,-1L};
                int32_t ***l_191 = (void*)0;
                for (p_35 = 0; (p_35 == (-9)); p_35 = safe_sub_func_int64_t_s_s(p_35, 1))
                { /* block id: 63 */
                    struct S0 **l_178 = &l_165;
                    int32_t l_184 = 1L;
                    l_179 = l_178;
                    /* statement id: 64 */
                    assert (l_179 == &l_165);
                }
                /* facts after for loop */
                assert (l_179 == &l_165 || l_179 == 0);
                (**l_197) = (((-6L) ^ ((!((*l_183) >= ((safe_sub_func_int8_t_s_s((**l_172), ((&l_172 != l_197) < g_124.f5))) , (g_124.f2 > (((((g_48 <= ((safe_add_func_int64_t_s_s(g_57, (*l_154))) , g_124.f1)) , p_34) , p_33) <= 0x9292L) , g_63))))) <= 8L)) , &p_33);
                /* statement id: 86 */
                assert (g_52 == &p_33);
            }
            /* facts after branching */
            assert (g_52 == &p_33 || g_52 == &g_57);
            assert (l_172 == &l_154 || l_172 == 0);
            assert (l_179 == &l_165 || l_179 == 0);
            if (((safe_add_func_int16_t_s_s(0x36E2L, ((g_124.f3 , &g_124) != ((safe_sub_func_int8_t_s_s(((((safe_add_func_int32_t_s_s((*p_36), ((0xE7DB0B19L >= 0x2B5BEA17L) == (~(safe_mod_func_int8_t_s_s((p_33 == ((p_34 | ((((l_154 != (*g_51)) < 65533UL) , &p_33) != (*g_51))) == 0x2CL)), 0xB2L)))))) >= 0x049A3F908AAE12B9LL) < 0x25314CBBL) , (***l_197)), 255UL)) , &l_143)))) >= 0xC9L))
            { /* block id: 88 */
                struct S0 l_213 = {0x97L,18446744073709551615UL,0xC3E23C1EL,0xEDEB66DAL,1UL,0x9E49857DL};
                uint8_t l_235 = 255UL;
                int32_t ***l_237 = &g_51;
                struct S0 **l_242 = &g_126;
                if ((safe_sub_func_int16_t_s_s((***l_197), 65530UL)))
                { /* block id: 89 */
                    (*l_165) = l_213;
                }
                else
                { /* block id: 91 */
                    p_36 = l_154;
                    /* statement id: 92 */
                    assert (p_36 == &g_124.f5);
                    for (l_185 = 0; (l_185 > 28); l_185 = safe_add_func_uint32_t_u_u(l_185, 4))
                    { /* block id: 95 */
                        struct S0 **l_216 = &g_126;
                        (*l_216) = &l_143;
                        /* statement id: 96 */
                        assert (g_126 == &l_143);
                    }
                    /* facts after for loop */
                    assert (g_126 == &l_143 || g_126 == &g_124);
                }
                /* facts after branching */
                assert (g_126 == &l_143 || g_126 == &g_124);
                assert (p_36 == &g_124.f5 || p_36 == &g_4);
                if ((safe_lshift_func_int16_t_s_s((g_124.f1 >= ((((l_221 == ((safe_add_func_uint8_t_u_u((((**l_197) != &p_33) & p_34), (((l_173 == l_173) & (safe_rshift_func_int8_t_s_u(((g_54 >= p_34) >= (*l_154)), (***l_197)))) >= g_48))) < 0UL)) < 7L) <= g_48) == 0L)), p_35)))
                { /* block id: 99 */
                    int32_t *l_226 = &g_4;
                    return l_226;
                    /* statement id: 100 */
                    //assert (g_52 == dangling || g_52 == &g_57);
                    //assert (g_126 == dangling || g_126 == &g_124);
                    //assert (func_32_rv == &g_4);
                }
                else
                { /* block id: 101 */
                    int8_t l_227 = 0L;
                    int32_t *l_239 = &g_124.f5;
                    (*g_52) = (**g_51);
                    if (l_227)
                    { /* block id: 103 */
                        uint8_t l_238 = 0x9EL;
                        (***l_197) = (safe_lshift_func_uint8_t_u_s((safe_mod_func_int16_t_s_s(((l_213.f3 == (p_35 ^ ((safe_rshift_func_uint8_t_u_s((p_35 <= (((!(4294967290UL && ((l_235 >= (~((((l_237 != &g_51) , &l_183) == (void*)0) , p_34))) && l_238))) , g_57) , 0x40FD28B2L)), (***l_197))) ^ (*l_183)))) , 0x2013L), p_34)), p_33));
                        return l_239;
                        /* statement id: 105 */
                        //assert (g_52 == dangling || g_52 == &g_57);
                        //assert (g_126 == dangling || g_126 == &g_124);
                        //assert (func_32_rv == &g_124.f5);
                    }
                    else
                    { /* block id: 106 */
                        struct S0 **l_243 = &l_162;
                        int32_t ***l_246 = &l_172;
                        int32_t ****l_247 = &l_197;
                        (*g_52) = (((safe_add_func_uint64_t_u_u((6UL ^ ((l_242 == l_243) <= (&l_162 != &g_126))), (((void*)0 == l_237) & ((safe_rshift_func_int16_t_s_u(((g_57 < ((*p_36) >= 0x10DCDEB3L)) && 1UL), 10)) > g_54)))) >= p_34) | 0x29E3L);
                        (*g_126) = (*g_126);
                        p_36 = l_154;
                        /* statement id: 109 */
                        assert (p_36 == &g_124.f5);
                        (*l_247) = l_246;
                        /* statement id: 110 */
                        assert (l_197 == &l_172);
                    }
                    /* facts after branching */
                    assert (p_36 == &g_124.f5);
                    assert (l_197 == &l_172);
                    (*l_165) = (**l_242);
                }
                /* facts after branching */
                assert (p_36 == &g_124.f5);
                assert (l_197 == &l_172);
                for (g_124.f5 = (-8); (g_124.f5 < 26); g_124.f5 = safe_add_func_uint64_t_u_u(g_124.f5, 1))
                { /* block id: 116 */
                    int32_t *l_250 = &g_4;
                    return l_250;
                    /* statement id: 117 */
                    //assert (g_52 == dangling || g_52 == &g_57);
                    //assert (g_126 == dangling || g_126 == &g_124);
                    //assert (func_32_rv == &g_4);
                }
            }
            else
            { /* block id: 119 */
                int32_t **l_251 = &l_183;
                int32_t ****l_252 = &l_197;
                (*l_251) = (p_34 , func_66(p_34, l_251, p_34, (**g_51), (*l_251)));
                /* statement id: 120 */
                assert (g_52 == 0);
                assert (l_183 == 0);
                (*l_252) = l_197;
            }
            /* facts after branching */
            assert (g_52 == 0 || g_52 == &p_33 || g_52 == &g_57);
            assert (g_126 == &l_143 || g_126 == &g_124);
            assert (p_36 == &g_4 || p_36 == &g_124.f5);
            assert (l_183 == 0 || l_183 == &g_124.f5);
            assert (l_197 == &g_51 || l_197 == &l_172);
            (*l_154) = (((safe_rshift_func_int16_t_s_s((g_255 != (((&l_172 != &l_172) ^ (safe_mod_func_int32_t_s_s((((((((((g_57 , p_35) && (*l_154)) & (((g_48 == ((*g_255) != l_197)) , (void*)0) != l_259)) < p_34) > g_48) , (*g_256)) == (void*)0) >= p_34) , (*p_36)), (*p_36)))) , &g_256)), p_35)) & 0xC9L) | l_260);
        }
        else
        { /* block id: 124 */
            int32_t l_284 = 0xB3F62F70L;
            int32_t *l_302 = &g_48;
            struct S0 l_306 = {1UL,0x134EA958L,0x41D5164DL,0xCA8F3B58L,0xDF57AABA89AF6DF7LL,9L};
            for (g_57 = (-1); (g_57 < 6); ++g_57)
            { /* block id: 127 */
                (**g_256) = (**l_197);
            }
            for (p_34 = 23; (p_34 > 4); p_34 = safe_sub_func_uint64_t_u_u(p_34, 5))
            { /* block id: 132 */
                uint8_t l_280 = 0xC9L;
                int32_t *l_303 = &l_143.f5;
                int32_t *****l_305 = &g_255;
                if ((*p_36))
                { /* block id: 133 */
                    int32_t *l_268 = &l_143.f5;
                    int32_t *****l_271 = &g_255;
                    (*l_268) = (((((safe_add_func_int8_t_s_s((g_124.f1 > 18446744073709551614UL), ((*g_126) , (+(g_124.f5 <= p_35))))) != ((void*)0 != l_268)) & (safe_rshift_func_uint16_t_u_s(p_34, ((((void*)0 == &p_36) , (*l_268)) || 0x7879FF85L)))) > g_54) , 2L);
                    (*l_154) = (*p_36);
                    (*l_162) = (*l_173);
                    (*l_271) = &g_256;
                }
                else
                { /* block id: 138 */
                    int32_t l_272 = 0xE2A525CEL;
                    g_63 = (*p_36);
                    if (((p_35 , l_272) & (+((((7L == (safe_add_func_uint8_t_u_u((((65535UL | (safe_rshift_func_int16_t_s_u((safe_lshift_func_int8_t_s_u((0x170A34BB5C3AA3BELL | l_280), (l_281 == (safe_mod_func_uint8_t_u_u((l_280 ^ p_33), p_33))))), p_35))) , (void*)0) == (void*)0), l_272))) <= p_33) , &g_126) == &g_126))))
                    { /* block id: 140 */
                        if (l_272)
                            break;
                        (*g_126) = (*g_126);
                    }
                    else
                    { /* block id: 143 */
                        (*l_154) = (l_284 , (*p_36));
                    }
                    (*l_154) = (safe_rshift_func_uint16_t_u_u(((safe_add_func_int16_t_s_s(((((((safe_sub_func_uint16_t_u_u(p_33, ((!((255UL > p_34) , ((safe_add_func_uint64_t_u_u((+(safe_rshift_func_uint16_t_u_u(p_35, 14))), (*l_154))) <= ((((((*g_126) , ((*l_162) , (!0xA448L))) , ((safe_mod_func_int16_t_s_s(8L, p_34)) & g_124.f2)) , 0UL) > 2UL) , l_280)))) || l_284))) >= g_124.f0) != 0x7B24L) == 0xD064L) ^ p_33) | g_124.f0), 1L)) , 0xEAB4L), 0));
                }
                for (g_124.f4 = 24; (g_124.f4 < 18); g_124.f4 = safe_sub_func_int64_t_s_s(g_124.f4, 2))
                { /* block id: 150 */
                    if (l_280)
                        break;
                    (*g_51) = (void*)0;
                    /* statement id: 152 */
                    assert (g_52 == 0);
                    l_302 = l_302;
                }
                (**g_256) = l_303;
                /* statement id: 155 */
                assert (g_52 == &l_143.f5);
                (*l_305) = l_304;
            }
            /* facts after for loop */
            assert (g_52 == &l_143.f5 || g_52 == &g_4 || g_52 == 0);
            (*l_173) = l_306;
        }
        /* facts after branching */
        assert (g_52 == &l_143.f5 || g_52 == &g_4 || g_52 == 0 || g_52 == &p_33 || g_52 == &g_57);
        assert (g_126 == &l_143 || g_126 == &g_124);
        assert (p_36 == &g_4 || p_36 == &g_124.f5);
        //assert (l_197 == &g_51 || l_197 == dangling);
        (***g_255) = ((safe_lshift_func_int16_t_s_s(((safe_sub_func_int8_t_s_s((((safe_unary_minus_func_uint8_t_u(0xF4L)) , (((1UL >= (*l_154)) | (((g_124.f1 , l_143.f1) <= (g_63 != 0x6AL)) == ((safe_rshift_func_uint8_t_u_u(l_314, 7)) > l_315))) , (***l_304))) != &p_33), 0xEEL)) > 65535UL), g_57)) , (**g_256));
    }
    else
    { /* block id: 161 */
        int32_t *l_316 = &g_124.f5;
        uint8_t l_322 = 1UL;
        struct S0 l_323 = {8UL,18446744073709551607UL,1L,0xDB609271L,0x811A6040539E5067LL,-5L};
        (*l_316) = (*p_36);
        for (g_124.f2 = 0; (g_124.f2 == 19); g_124.f2 = safe_add_func_int64_t_s_s(g_124.f2, 3))
        { /* block id: 165 */
            uint32_t l_321 = 0xCB44A2E4L;
            for (p_33 = 28; (p_33 > (-25)); p_33 = safe_sub_func_int8_t_s_s(p_33, 1))
            { /* block id: 168 */
                return (*g_51);
                /* statement id: 169 */
                //assert (func_32_rv == &g_4 || func_32_rv == 0);
            }
            (*l_162) = (*l_162);
            if (l_321)
                continue;
            l_322 = 0x6B9D081BL;
        }
        (*g_126) = l_323;
        (*g_51) = l_316;
        /* statement id: 176 */
        assert (g_52 == &g_124.f5);
    }
    /* facts after branching */
    assert (g_52 == &g_124.f5 || g_52 == &l_143.f5 || g_52 == &g_4 || g_52 == 0 || g_52 == &p_33 || g_52 == &g_57);
    assert (g_126 == &l_143 || g_126 == &g_124);
    assert (p_36 == &g_4 || p_36 == &g_124.f5);
    //assert (l_197 == &g_51 || l_197 == dangling);
    (*l_324) = &l_143;
    /* statement id: 178 */
    assert (g_126 == &l_143);
    for (g_124.f1 = 0; (g_124.f1 >= 60); g_124.f1 = safe_add_func_int16_t_s_s(g_124.f1, 8))
    { /* block id: 181 */
        int8_t l_344 = 0xC7L;
        int32_t l_345 = 0x74E47811L;
        int32_t *****l_348 = &g_255;
        uint32_t l_486 = 0UL;
        struct S0 l_489 = {3UL,0x5319D9DAL,-1L,0xAA72EEDAL,0xB71BF53A79702607LL,0L};
        struct S0 *l_498 = &g_124;
        uint16_t l_508 = 0xD234L;
        for (l_143.f0 = (-17); (l_143.f0 > 22); l_143.f0 = safe_add_func_uint64_t_u_u(l_143.f0, 9))
        { /* block id: 184 */
            int16_t l_335 = 0x845FL;
            int32_t *****l_362 = (void*)0;
            struct S0 l_378 = {255UL,0x8FF6EEE8L,-2L,1UL,18446744073709551615UL,0L};
            uint32_t l_422 = 1UL;
            uint8_t l_429 = 255UL;
            l_345 = ((&p_33 != &p_33) == ((p_34 >= 0x362BL) | (safe_rshift_func_int16_t_s_s(0xE8AFL, ((((247UL == (safe_rshift_func_int8_t_s_u((safe_add_func_int32_t_s_s((l_335 == (safe_sub_func_uint32_t_u_u((p_33 >= (safe_mod_func_int32_t_s_s((safe_lshift_func_uint8_t_u_u(((safe_lshift_func_uint8_t_u_s(((((void*)0 != &l_162) == 1L) < p_33), 7)) , l_335), 6)), 1L))), l_335))), 0UL)), 1))) , l_335) >= l_344) , 0x593EL)))));
        }
        (****l_349) = (****l_348);
        (*l_324) = (void*)0;
        /* statement id: 236 */
        assert (g_126 == 0);
        for (l_185 = 16; (l_185 >= 12); l_185 = safe_sub_func_uint32_t_u_u(l_185, 2))
        { /* block id: 239 */
            uint8_t l_501 = 1UL;
            int32_t ****l_509 = &l_197;
            if ((safe_mod_func_uint8_t_u_u(g_63, (safe_sub_func_int8_t_s_s((l_498 != ((g_124.f0 > ((0L <= p_33) , (g_63 >= ((*p_36) | (safe_sub_func_int32_t_s_s(0x491E0087L, (*p_36))))))) , &g_124)), (-1L))))))
            { /* block id: 240 */
                (*g_51) = (**g_256);
            }
            else
            { /* block id: 242 */
                l_501 = (18446744073709551615UL & g_48);
                (**g_256) = (**g_256);
            }
            (*g_51) = func_66(((**l_348) == (*g_255)), &p_36, (safe_mod_func_int32_t_s_s((safe_rshift_func_uint8_t_u_u((p_34 > g_124.f5), 6)), ((((((g_124.f5 && 0xC4E1886731C44601LL) , (safe_mod_func_int64_t_s_s((0L == (&g_124 != &g_124)), 0x1A2BF89AC35681CDLL))) , g_4) > g_4) ^ g_57) || 1L))), l_508, (****l_348));
            /* statement id: 246 */
            assert (g_52 == 0);
            l_509 = l_509;
        }
    }
    /* facts after for loop */
    assert (g_126 == 0 || g_126 == &l_143);
    return g_510;
    /* statement id: 250 */
    //assert (g_52 == &g_124.f5 || g_52 == dangling || g_52 == &g_4 || g_52 == 0 || g_52 == &g_57);
    //assert (g_126 == 0 || g_126 == dangling);
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_54 g_63 g_4 g_60 g_124.f4 g_124.f2 g_124.f1 g_51 g_52
 * writes: g_48 g_60 g_126 g_52
 */
static uint32_t  func_37(uint32_t  p_38)
{ /* block id: 37 */
    uint32_t l_117 = 0UL;
    int32_t l_120 = 0x33EA39AEL;
    struct S0 **l_127 = (void*)0;
    g_48 = (p_38 == (safe_lshift_func_uint8_t_u_u((g_54 > (safe_add_func_uint8_t_u_u((((((1UL <= ((((+l_117) , ((l_117 >= p_38) , (safe_add_func_uint64_t_u_u(((-10L) && 0xF68EFB8CC5E00EF8LL), 4L)))) >= p_38) & 0x48D7427E885CFE2ALL)) <= l_117) || g_63) & g_4) > g_60), 0x33L))), l_120)));
    for (g_60 = 0; (g_60 < 1); g_60 = safe_add_func_int16_t_s_s(g_60, 9))
    { /* block id: 41 */
        struct S0 *l_123 = &g_124;
        struct S0 **l_125 = (void*)0;
        int32_t l_128 = 1L;
        int32_t **l_135 = &g_52;
        uint64_t l_139 = 0xDA4A6FB27AD419A6LL;
        int32_t *l_140 = &l_128;
        g_126 = l_123;
        if (l_117)
            break;
        (*g_51) = func_66(((((void*)0 != l_127) || (((l_128 , ((+(!((safe_lshift_func_uint8_t_u_s((safe_mod_func_int64_t_s_s(g_124.f4, g_124.f2)), (l_135 == &g_52))) != (+((((safe_add_func_uint8_t_u_u((&l_120 != (void*)0), 0x7AL)) ^ l_139) <= p_38) < g_60))))) <= 4L)) < 0x867A3060L) || g_124.f1)) > p_38), &g_52, g_124.f2, l_120, l_140);
        /* statement id: 44 */
        assert (g_52 == 0);
        (*l_140) = (safe_lshift_func_uint8_t_u_u(0xF7L, p_38));
    }
    return l_120;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_40(uint16_t  p_41, int32_t * p_42, int32_t * p_43, int32_t  p_44, uint16_t  p_45)
{ /* block id: 35 */
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads : g_48 g_51 g_54 g_63 g_4 g_52 g_60 g_57
 * writes: g_48 g_54 g_57 g_60 g_63 g_52
 */
static int64_t  func_46(int32_t * p_47)
{ /* block id: 4 */
    int32_t **l_53 = &g_52;
    int32_t l_72 = 0L;
    int32_t l_105 = 1L;
    int32_t l_106 = 0x635BD15AL;
    uint32_t l_107 = 4294967289UL;
    struct S0 l_108 = {2UL,18446744073709551615UL,-9L,18446744073709551615UL,0x15B33599DBF4B608LL,0x7AA087ACL};
    int32_t *l_109 = &g_48;
    for (g_48 = 0; (g_48 == 8); ++g_48)
    { /* block id: 7 */
        uint16_t l_81 = 1UL;
        l_53 = g_51;
        for (g_54 = 0; (g_54 == 19); g_54 = safe_add_func_uint16_t_u_u(g_54, 7))
        { /* block id: 11 */
            for (g_57 = 0; (g_57 == (-2)); g_57 = safe_sub_func_int64_t_s_s(g_57, 4))
            { /* block id: 14 */
                for (g_60 = 15; (g_60 < (-9)); g_60--)
                { /* block id: 17 */
                    for (g_63 = 0; (g_63 == (-13)); g_63--)
                    { /* block id: 20 */
                        return g_63;
                    }
                }
                (*l_53) = p_47;
                /* statement id: 24 */
                assert (g_52 == &g_4);
            }
        }
        /* facts after for loop */
        assert (g_52 == &g_4 || g_52 == 0);
        (*l_53) = func_66((l_72 , (!(safe_add_func_uint16_t_u_u(0xD593L, (safe_rshift_func_int16_t_s_u((safe_sub_func_uint32_t_u_u((!0xE96CL), ((g_63 , (*p_47)) >= (l_81 && (l_81 , (safe_rshift_func_uint16_t_u_s(l_81, ((~(+l_81)) , l_81)))))))), 1)))))), &g_52, l_81, (*p_47), (*l_53));
        /* statement id: 31 */
        assert (g_52 == 0);
    }
    (*l_109) = (safe_add_func_int32_t_s_s((((safe_add_func_int64_t_s_s(((((((((((((*g_51) != ((g_48 && l_72) , (((g_60 | (((!((0x348280EFL != ((safe_add_func_int8_t_s_s(((l_72 > (safe_lshift_func_int16_t_s_s((((g_54 , 0x3BB3L) , ((safe_rshift_func_int16_t_s_s((safe_add_func_uint64_t_u_u(((((((((((safe_rshift_func_int16_t_s_u(((l_72 && g_57) && 0x396AC63FL), 12)) != l_72) >= l_72) , g_4) | g_48) <= l_72) , 0x409BL) || 0x71AFL) ^ l_105) , 0xE450752D6847A7A0LL), l_72)), g_4)) != l_106)) != g_54), l_72))) , 0x32L), g_4)) < g_4)) != l_106)) != l_105) < 0x7DL)) & l_107) , (*l_53)))) , 18446744073709551615UL) , l_108) , l_72) , l_72) >= g_54) && 0x8AL) | 65535UL) && 0x983135CAF2BF2F77LL) , (void*)0) == (*g_51)), l_108.f4)) < (*p_47)) != (*p_47)), (*p_47)));
    return g_63;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_51 g_52
 * writes: g_52
 */
static int32_t * func_66(int16_t  p_67, int32_t ** p_68, uint8_t  p_69, int32_t  p_70, int32_t * p_71)
{ /* block id: 27 */
    int32_t l_86 = 4L;
    uint16_t l_87 = 0x3BC0L;
    l_87 = ((g_4 == ((l_86 && 8UL) & ((void*)0 == &l_86))) , (&g_52 != (void*)0));
    (*g_51) = (void*)0;
    /* statement id: 29 */
    assert (g_52 == 0);
    return (*g_51);
    /* statement id: 30 */
    //assert (func_66_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_48, "g_48", print_hash_value);
    transparent_crc(g_54, "g_54", print_hash_value);
    transparent_crc(g_57, "g_57", print_hash_value);
    transparent_crc(g_60, "g_60", print_hash_value);
    transparent_crc(g_63, "g_63", print_hash_value);
    transparent_crc(g_124.f0, "g_124.f0", print_hash_value);
    transparent_crc(g_124.f1, "g_124.f1", print_hash_value);
    transparent_crc(g_124.f2, "g_124.f2", print_hash_value);
    transparent_crc(g_124.f3, "g_124.f3", print_hash_value);
    transparent_crc(g_124.f4, "g_124.f4", print_hash_value);
    transparent_crc(g_124.f5, "g_124.f5", print_hash_value);
    transparent_crc(g_354, "g_354", print_hash_value);
    transparent_crc(g_560, "g_560", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 166
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 48
breakdown:
   depth: 1, occurrence: 217
   depth: 2, occurrence: 31
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 4
   depth: 18, occurrence: 4
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 4
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 3
   depth: 27, occurrence: 3
   depth: 31, occurrence: 1
   depth: 34, occurrence: 1
   depth: 36, occurrence: 1
   depth: 48, occurrence: 1

XXX total number of pointers: 116

XXX times a variable address is taken: 152
XXX times a pointer is dereferenced on RHS: 163
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 20
   depth: 3, occurrence: 17
   depth: 4, occurrence: 9
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 110
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 13
   depth: 3, occurrence: 9
   depth: 4, occurrence: 6
XXX times a pointer is compared with null: 27
XXX times a pointer is compared with address of another variable: 20
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 730

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 281
   level: 2, occurrence: 129
   level: 3, occurrence: 82
   level: 4, occurrence: 45
   level: 5, occurrence: 50
XXX number of pointers point to pointers: 50
XXX number of pointers point to scalars: 47
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 24.1
XXX average alias set size: 1.38

XXX times a non-volatile is read: 1123
XXX times a non-volatile is write: 330
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 182
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 32
   depth: 2, occurrence: 35
   depth: 3, occurrence: 37
   depth: 4, occurrence: 28
   depth: 5, occurrence: 19

XXX percentage a fresh-made variable is used: 15.3
XXX percentage an existing variable is used: 84.7
********************* end of statistics **********************/

