/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --jumps --longlong --no-force-non-uniform-arrays --no-math64 --muls --packed-struct --paranoid --pointers --structs --inline-function --no-return-structs --arg-structs --dangling-global-pointers
 * Seed:      3711228256
 */

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint32_t g_10 = 0xB9AE77ABL;
static int32_t *g_51 = (void*)0;
static int32_t g_72 = 0x48C84060L;
static int32_t g_116 = 0xB495AE89L;
static int32_t g_117 = 0xDF0EBE34L;


/* --- FORWARD DECLARATIONS --- */
inline static const int16_t  func_1(void);
inline static uint16_t  func_5(uint8_t  p_6, int8_t  p_7);
inline static int8_t  func_16(uint16_t  p_17, uint16_t  p_18);
inline static uint8_t  func_27(const uint8_t  p_28, int16_t  p_29, int32_t  p_30, int16_t  p_31);
inline static int8_t  func_32(uint32_t  p_33, uint16_t  p_34, int16_t  p_35, uint32_t  p_36);
inline static int32_t * func_37(const int16_t  p_38, int32_t  p_39, uint32_t  p_40, int8_t  p_41, int16_t  p_42);
static int32_t * func_53(int32_t  p_54);
inline static int32_t  func_55(int32_t  p_56, int32_t * p_57, int16_t  p_58, int32_t  p_59);
static int32_t * func_60(uint32_t  p_61, int32_t  p_62, const int32_t  p_63);
inline static int32_t * func_73(int32_t  p_74);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_10 g_51 g_72 g_117 g_116
 * writes: g_72 g_51 g_116 g_117
 */
inline static const int16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_11 = (-6L);
    int32_t *l_247 = &g_72;
    (*l_247) = (~(safe_add_func_uint16_t_u_u((func_5((safe_rshift_func_int8_t_s_s(g_10, 1)), l_11) & (safe_mod_func_int16_t_s_s(g_10, (safe_lshift_func_uint8_t_u_u((func_5(g_10, func_16(l_11, (((safe_mul_func_uint8_t_u_u(l_11, (safe_mod_func_int32_t_s_s((safe_div_func_int8_t_s_s((safe_div_func_uint32_t_u_u((func_27((func_32(l_11, l_11, l_11, l_11) ^ l_11), g_10, g_10, l_11) && g_117), g_10)), (-8L))), l_11)))) & g_10) && l_11))) & g_10), g_10))))), l_11)));
    /* statement id: 78 */
    assert (g_51 == &g_72);
    return g_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_5(uint8_t  p_6, int8_t  p_7)
{ /* block id: 1 */
    return p_7;
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_72
 * writes: g_72
 */
inline static int8_t  func_16(uint16_t  p_17, uint16_t  p_18)
{ /* block id: 73 */
    const int32_t * const l_243 = (void*)0;
    const int32_t * const *l_242 = &l_243;
    int32_t l_244 = 0x6A631387L;
    const int32_t **l_245 = (void*)0;
    const int32_t *l_246 = &g_117;
    l_244 = ((void*)0 == l_242);
    (*g_51) = (-4L);
    l_246 = (*l_242);
    /* statement id: 76 */
    assert (l_246 == 0);
    return g_72;
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_72
 * writes: g_72
 */
inline static uint8_t  func_27(const uint8_t  p_28, int16_t  p_29, int32_t  p_30, int16_t  p_31)
{ /* block id: 70 */
    int32_t **l_237 = (void*)0;
    uint32_t l_239 = 0x9B2AD007L;
    (*g_51) = ((l_237 != l_237) == (~((((*g_51) == l_239) == (0x1CL < (l_237 != l_237))) == ((safe_add_func_int32_t_s_s(p_31, (g_72 ^ 1UL))) || g_72))));
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_51 g_72 g_117 g_116
 * writes: g_72 g_51 g_116 g_117
 */
inline static int8_t  func_32(uint32_t  p_33, uint16_t  p_34, int16_t  p_35, uint32_t  p_36)
{ /* block id: 3 */
    uint16_t l_52 = 0x2B2FL;
    int32_t **l_236 = &g_51;
    (*l_236) = func_37((p_36 != g_10), g_10, p_33, (safe_sub_func_uint32_t_u_u(((((safe_add_func_uint32_t_u_u((safe_mod_func_int32_t_s_s(g_10, g_10)), (safe_rshift_func_int8_t_s_u(((0xBBL > ((void*)0 != g_51)) != 1UL), l_52)))) || p_34) || g_10) == 0x36L), 0UL)), l_52);
    /* statement id: 67 */
    assert (g_51 == &g_72);
    (*g_51) = (0L > 0L);
    return (**l_236);
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_72 g_51 g_117 g_116
 * writes: g_72 g_51 g_116 g_117
 */
inline static int32_t * func_37(const int16_t  p_38, int32_t  p_39, uint32_t  p_40, int8_t  p_41, int16_t  p_42)
{ /* block id: 4 */
    int16_t l_64 = 0x97E6L;
    int32_t * const l_71 = &g_72;
    int32_t **l_231 = (void*)0;
    int32_t **l_232 = &g_51;
    (*l_232) = func_53(func_55(g_10, func_60(l_64, ((safe_mod_func_uint32_t_u_u(p_40, 0x5ED761E7L)) <= (safe_rshift_func_int16_t_s_s((safe_div_func_int16_t_s_s(0x0187L, func_5((l_71 == (void*)0), p_38))), 4))), (*l_71)), g_10, p_40));
    /* statement id: 59 */
    assert (g_51 == &g_117);
    for (l_64 = (-21); (l_64 == (-5)); l_64 = safe_add_func_int8_t_s_s(l_64, 1))
    { /* block id: 62 */
        int32_t *l_235 = &g_72;
        (*l_232) = &g_117;
        (*l_71) = (((void*)0 == l_235) == 4294967295UL);
    }
    return &g_72;
    /* statement id: 66 */
    //assert (func_37_rv == &g_72);
}


/* ------------------------------------------ */
/* 
 * reads : g_72 g_10 g_116
 * writes: g_72
 */
static int32_t * func_53(int32_t  p_54)
{ /* block id: 53 */
    int32_t *l_209 = (void*)0;
    int32_t l_210 = 0xCAA545A5L;
    int32_t *l_229 = &g_72;
    int32_t **l_230 = &l_229;
    l_210 = 1L;
    (*l_229) = (safe_div_func_uint32_t_u_u((g_72 < ((safe_mod_func_int32_t_s_s((((safe_add_func_int16_t_s_s(g_72, ((p_54 > (safe_lshift_func_int16_t_s_u((safe_mul_func_int8_t_s_s(g_72, (safe_mod_func_uint32_t_u_u(((((void*)0 == &g_72) != 0x8B99L) | (3L == ((((safe_mul_func_int16_t_s_s(((safe_mod_func_int16_t_s_s((safe_sub_func_int32_t_s_s((-7L), g_10)), (-9L))) != (-1L)), 0xB385L)) == 255UL) > (-4L)) | g_116))), 0x652DBFB6L)))), 4))) != p_54))) == 0x803EL) != p_54), g_72)) <= 0xA1L)), (-2L)));
    (*l_230) = (void*)0;
    /* statement id: 56 */
    assert (l_229 == 0);
    g_72 = (p_54 > p_54);
    return &g_117;
    /* statement id: 58 */
    //assert (func_53_rv == &g_117);
}


/* ------------------------------------------ */
/* 
 * reads : g_117 g_72 g_116 g_10 g_51
 * writes: g_117 g_51 g_72
 */
inline static int32_t  func_55(int32_t  p_56, int32_t * p_57, int16_t  p_58, int32_t  p_59)
{ /* block id: 36 */
    int8_t l_164 = (-10L);
    int32_t l_188 = 0xEB54A4BBL;
    int32_t **l_189 = &g_51;
    int32_t *l_202 = &g_72;
    l_188 = (safe_sub_func_uint16_t_u_u((l_164 <= (((safe_mod_func_int32_t_s_s(((safe_mod_func_int8_t_s_s(((safe_mod_func_uint16_t_u_u((safe_mod_func_int32_t_s_s(((l_164 & (safe_rshift_func_uint8_t_u_u(l_164, ((safe_mul_func_int16_t_s_s(((*p_57) < (safe_rshift_func_uint16_t_u_u((0x1F82L == (0x4A44L == (safe_unary_minus_func_int32_t_s((safe_mod_func_uint32_t_u_u(((p_56 && (safe_rshift_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u((safe_mod_func_int32_t_s_s((*p_57), g_72)), g_116)) <= g_117), l_164))) ^ 5L), 0x4A936FBAL)))))), 3))), l_164)) <= 1UL)))) <= g_117), p_59)), g_72)) > l_164), g_10)) | p_56), l_164)) && (*p_57)) > l_164)), 65531UL));
    (*p_57) = ((void*)0 != l_189);
    (*p_57) = (safe_add_func_int16_t_s_s((-1L), ((safe_mod_func_uint32_t_u_u(((safe_mod_func_int16_t_s_s((safe_add_func_uint8_t_u_u(p_58, 1UL)), g_72)) != 0L), g_10)) > (safe_sub_func_uint16_t_u_u((safe_div_func_int32_t_s_s(((void*)0 != l_202), (*l_202))), 8UL)))));
    if (((*l_202) < ((((safe_div_func_uint32_t_u_u(0x34C0AFD8L, g_116)) || ((*l_189) == &g_72)) | (*l_202)) || (*l_202))))
    { /* block id: 40 */
        return g_116;
    }
    else
    { /* block id: 42 */
        int32_t l_208 = 0xC42B59B2L;
        for (g_117 = 0; (g_117 > 12); g_117++)
        { /* block id: 45 */
            (*l_189) = p_57;
            /* statement id: 46 */
            assert (g_51 == &g_117);
            (*l_189) = &g_72;
            /* statement id: 47 */
            assert (g_51 == &g_72);
            (*g_51) = ((safe_unary_minus_func_int16_t_s(((*g_51) < (((void*)0 != &g_51) <= l_208)))) < g_117);
        }
        (*l_202) = 0L;
    }
    return g_116;
}


/* ------------------------------------------ */
/* 
 * reads : g_72 g_10 g_51 g_117
 * writes: g_72 g_51 g_116 g_117
 */
static int32_t * func_60(uint32_t  p_61, int32_t  p_62, const int32_t  p_63)
{ /* block id: 5 */
    int32_t l_77 = 0L;
    int32_t l_104 = 0x80627DBDL;
    int16_t l_105 = 0xC80BL;
    int32_t **l_160 = (void*)0;
    int32_t *l_161 = &g_72;
    l_161 = func_73(((safe_div_func_uint16_t_u_u(l_77, ((safe_mod_func_uint32_t_u_u(((safe_add_func_uint16_t_u_u(((safe_mul_func_uint8_t_u_u((7L ^ 0x62CCL), (+((safe_rshift_func_uint16_t_u_u(((safe_lshift_func_int8_t_s_u(((safe_mod_func_uint32_t_u_u((safe_rshift_func_uint8_t_u_s(255UL, 3)), (safe_add_func_int8_t_s_s((+g_72), ((0L | g_72) | (((safe_rshift_func_int8_t_s_u((safe_add_func_int8_t_s_s(((safe_sub_func_uint8_t_u_u((safe_mod_func_uint16_t_u_u((g_10 ^ g_10), 1UL)), g_72)) & 0L), g_10)), 4)) | l_77) >= l_77)))))) == g_10), l_77)) == p_63), 11)) | l_104)))) >= 0xCF56L), l_104)) > l_77), 0x8F29ADBEL)) & l_105))) == l_77));
    /* statement id: 34 */
    assert (g_51 == &g_72 || g_51 == 0);
    return &g_117;
    /* statement id: 35 */
    //assert (func_60_rv == &g_117);
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_72 g_117 g_10
 * writes: g_72 g_51 g_116 g_117
 */
inline static int32_t * func_73(int32_t  p_74)
{ /* block id: 6 */
    int32_t *l_111 = &g_72;
    int32_t l_112 = (-1L);
    const uint8_t l_141 = 0xE7L;
    uint32_t l_159 = 1UL;
    for (p_74 = 4; (p_74 == (-8)); --p_74)
    { /* block id: 9 */
        int32_t l_115 = 0x93330862L;
        for (g_72 = 5; (g_72 < 12); g_72 = safe_add_func_uint8_t_u_u(g_72, 6))
        { /* block id: 12 */
            int32_t **l_110 = &g_51;
            (*l_110) = &g_72;
            /* statement id: 13 */
            assert (g_51 == &g_72);
            if (((void*)0 != l_111))
            { /* block id: 14 */
                if (p_74)
                    break;
                l_112 = 0xE0EF155DL;
                (*l_110) = (*l_110);
            }
            else
            { /* block id: 18 */
                uint32_t l_113 = 0xC5CA36B4L;
                uint16_t l_114 = 3UL;
                l_113 = (*l_111);
                if (l_114)
                    continue;
                g_116 = l_115;
            }
            g_117 = (&l_112 == (void*)0);
        }
        for (l_115 = 26; (l_115 != 28); ++l_115)
        { /* block id: 27 */
            if (p_74)
                break;
        }
    }
    /* facts after for loop */
    assert (g_51 == &g_72 || g_51 == 0);
    (*l_111) = (+((safe_add_func_int8_t_s_s(p_74, (safe_rshift_func_uint8_t_u_u(((safe_unary_minus_func_int32_t_s(((+(safe_div_func_int16_t_s_s((((((safe_sub_func_int8_t_s_s(((*l_111) | (!(safe_lshift_func_int16_t_s_u((p_74 || (safe_sub_func_int32_t_s_s((((&l_111 == (void*)0) < (safe_unary_minus_func_int32_t_s((safe_add_func_int32_t_s_s(((((((void*)0 == &g_117) ^ (g_72 ^ (safe_mod_func_int16_t_s_s(((((((65529UL != 65532UL) >= p_74) >= g_72) ^ 0x66F6C633L) == (*l_111)) <= p_74), (-1L))))) != 0x29F9L) >= p_74) >= p_74), (*l_111)))))) <= (*l_111)), l_141))), p_74)))), (-8L))) ^ 0x1417L) && (*l_111)) != 0x87DFL) != (*l_111)), (*l_111)))) ^ (*l_111)))) ^ 0x12E2L), (*l_111))))) ^ g_117));
    (*l_111) = ((safe_div_func_uint8_t_u_u(((safe_rshift_func_uint8_t_u_s((safe_sub_func_int8_t_s_s((0L > (safe_add_func_int8_t_s_s((safe_rshift_func_int8_t_s_u(((*l_111) && (safe_sub_func_uint32_t_u_u((((void*)0 == &l_112) ^ ((safe_div_func_int8_t_s_s(g_10, (*l_111))) || ((safe_unary_minus_func_int32_t_s(0x66B1C03AL)) > (safe_div_func_uint16_t_u_u((p_74 || (((*l_111) & 8UL) >= p_74)), (-10L)))))), l_159))), 4)), 1UL))), 252UL)), 6)) ^ 5L), p_74)) ^ (*l_111));
    return &g_72;
    /* statement id: 33 */
    //assert (func_73_rv == &g_72);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_10;
    csmith_sink_ = g_72;
    csmith_sink_ = g_116;
    csmith_sink_ = g_117;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 31
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 57
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 2
   depth: 33, occurrence: 1

XXX total number of pointers: 26

XXX times a variable address is taken: 28
XXX times a pointer is dereferenced on RHS: 28
breakdown:
   depth: 1, occurrence: 27
   depth: 2, occurrence: 1
XXX times a pointer is dereferenced on LHS: 20
breakdown:
   depth: 1, occurrence: 20
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 76

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 55
   level: 2, occurrence: 9
XXX number of pointers point to pointers: 10
XXX number of pointers point to scalars: 16
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 34.6
XXX average alias set size: 1.15

XXX times a non-volatile is read: 194
XXX times a non-volatile is write: 55
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 51
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 7
   depth: 2, occurrence: 7
   depth: 3, occurrence: 6

XXX percentage a fresh-made variable is used: 15.6
XXX percentage an existing variable is used: 84.4
********************* end of statistics **********************/

