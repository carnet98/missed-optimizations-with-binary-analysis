/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --jumps --longlong --force-non-uniform-arrays --math64 --muls --packed-struct --paranoid --pointers --structs --inline-function --return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      14820316233057251931
 */

#include "csmith.h"

volatile uint64_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int64_t  f0;
   unsigned f1 : 17;
   uint8_t  f2;
   uint64_t  f3;
   int16_t  f4;
   int8_t  f5;
   uint32_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0x97A888ADL;
static int32_t *g_92 = (void*)0;
static struct S0 g_100 = {0xE3F4D67785DC571ELL,127,2UL,0x94BA75048CB00984LL,0x105AL,0xB5L,0x19AF7C76L};
static struct S0 g_110 = {0xC58F83956885487ELL,60,0x75L,0UL,0x4BACL,0x94L,0xC95D4E09L};
static struct S0 *g_109 = &g_110;
static int32_t g_114 = 0xB8BF77F6L;
static int8_t g_146 = (-1L);
static struct S0 ***g_186 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
inline static int32_t  func_5(int32_t  p_6, uint16_t  p_7, uint8_t  p_8, int32_t  p_9);
inline static uint64_t  func_14(uint32_t  p_15, int32_t  p_16, int32_t  p_17, uint32_t  p_18);
inline static int32_t  func_21(int32_t  p_22, int32_t  p_23, uint16_t  p_24, uint64_t  p_25);
inline static int32_t  func_26(uint8_t  p_27, int32_t  p_28, uint32_t  p_29);
static uint64_t  func_36(int16_t  p_37, int32_t  p_38, int8_t  p_39);
static int16_t  func_43(uint32_t  p_44, int64_t  p_45, uint32_t  p_46, int8_t  p_47, uint32_t  p_48);
inline static uint8_t  func_49(uint32_t  p_50, uint32_t  p_51);
static uint32_t  func_52(int16_t  p_53, uint8_t  p_54, int32_t  p_55, uint64_t  p_56, int32_t  p_57);
static uint8_t  func_59(uint32_t  p_60, int32_t  p_61);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_100 g_109 g_110.f5 g_110.f0 g_110.f6 g_110.f3 g_146 g_114 g_92 g_110.f4 g_186
 * writes: g_2 g_92 g_100 g_114 g_109 g_110 g_186
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_161 = 255UL;
    struct S0 *l_201 = &g_110;
    struct S0 *l_202 = &g_100;
    struct S0 ****l_203 = &g_186;
    for (g_2 = 0; (g_2 > 16); ++g_2)
    { /* block id: 3 */
        uint32_t l_32 = 4294967295UL;
        int32_t l_179 = 0xA0EE20FBL;
        uint32_t l_180 = 0xA1F86F26L;
        struct S0 **l_198 = &g_109;
        struct S0 **l_199 = &g_109;
        int32_t *l_200 = &g_114;
        if (g_2)
        { /* block id: 4 */
            int64_t l_40 = 0x1C36B586FA66FA4BLL;
            int32_t **l_196 = &g_92;
            if (func_5((safe_mul_func_uint8_t_u_u(0xABL, (safe_mod_func_uint64_t_u_u(func_14(g_2, ((safe_add_func_int32_t_s_s(func_21(g_2, func_26((safe_mul_func_int16_t_s_s(l_32, g_2)), g_2, (0x5FB57A67L | ((+(safe_lshift_func_uint8_t_u_s((func_36(((0x45L & g_2) <= l_32), g_2, l_40) && l_161), 1))) ^ l_40))), g_146, g_146), l_32)) > g_146), g_2, g_146), l_40)))), g_146, l_179, l_180))
            { /* block id: 102 */
                int32_t **l_191 = (void*)0;
                int32_t **l_192 = &g_92;
                (*l_192) = &l_179;
                /* statement id: 103 */
                assert (g_92 == &l_179);
                for (g_114 = (-4); (g_114 == 27); g_114 = safe_add_func_int16_t_s_s(g_114, 9))
                { /* block id: 106 */
                    return g_100.f5;
                    /* statement id: 107 */
                    //assert (g_92 == dangling);
                }
            }
            else
            { /* block id: 109 */
                int32_t **l_195 = &g_92;
                (*l_195) = &g_2;
                /* statement id: 110 */
                assert (g_92 == &g_2);
            }
            /* facts after branching */
            assert (g_92 == &g_2 || g_92 == &l_179);
            (*l_196) = &l_179;
            /* statement id: 112 */
            assert (g_92 == &l_179);
            (*g_92) = (-3L);
            (*l_196) = &g_114;
            /* statement id: 114 */
            assert (g_92 == &g_114);
        }
        else
        { /* block id: 115 */
            int32_t **l_197 = &g_92;
            (*l_197) = &g_2;
            /* statement id: 116 */
            assert (g_92 == &g_2);
        }
        /* facts after branching */
        assert (g_92 == &g_2 || g_92 == &g_114);
        (*l_200) = ((g_114 <= ((void*)0 == &l_179)) && (l_198 == l_199));
    }
    /* facts after for loop */
    assert (g_92 == &g_2 || g_92 == &g_114 || g_92 == 0);
    assert (g_109 == &g_100 || g_109 == &g_110);
    l_202 = l_201;
    /* statement id: 120 */
    assert (l_202 == &g_110);
    (*l_203) = g_186;
    return l_161;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_5(int32_t  p_6, uint16_t  p_7, uint8_t  p_8, int32_t  p_9)
{ /* block id: 91 */
    struct S0 **l_181 = &g_109;
    struct S0 ***l_182 = &l_181;
    int32_t l_185 = (-5L);
    (*l_182) = l_181;
    return p_8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_14(uint32_t  p_15, int32_t  p_16, int32_t  p_17, uint32_t  p_18)
{ /* block id: 89 */
    uint16_t l_178 = 0x0BE2L;
    return l_178;
}


/* ------------------------------------------ */
/* 
 * reads : g_110.f4 g_100.f2 g_92
 * writes: g_114
 */
inline static int32_t  func_21(int32_t  p_22, int32_t  p_23, uint16_t  p_24, uint64_t  p_25)
{ /* block id: 86 */
    int32_t **l_177 = (void*)0;
    (*g_92) = (((void*)0 == &g_109) | ((p_23 != ((safe_mod_func_uint64_t_u_u(((safe_mul_func_uint8_t_u_u((~(safe_mod_func_uint16_t_u_u(p_24, (p_25 ^ p_23)))), (safe_lshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s(p_24, ((safe_mod_func_int64_t_s_s((~((l_177 == l_177) >= 0xEC59EFA1EB4E8513LL)), p_24)) < p_23))), g_110.f4)))) > g_100.f2), 1UL)) ^ p_25)) >= p_25));
    return p_24;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_92
 */
inline static int32_t  func_26(uint8_t  p_27, int32_t  p_28, uint32_t  p_29)
{ /* block id: 83 */
    int32_t **l_162 = &g_92;
    (*l_162) = &g_114;
    /* statement id: 84 */
    assert (g_92 == &g_114);
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_100 g_109 g_110.f5 g_110.f0 g_110.f6 g_110.f3 g_146 g_114 g_92
 * writes: g_92 g_100 g_114 g_109 g_110
 */
static uint64_t  func_36(int16_t  p_37, int32_t  p_38, int8_t  p_39)
{ /* block id: 5 */
    uint16_t l_58 = 0xD0C0L;
    struct S0 *l_111 = &g_110;
    uint32_t l_142 = 18446744073709551615UL;
    int32_t *l_159 = (void*)0;
    if ((safe_mul_func_int8_t_s_s((func_43((func_49(func_52(l_58, func_59((0x117A540FL & (0UL < l_58)), p_37), ((safe_sub_func_int8_t_s_s((((g_109 == l_111) != (l_111 == (void*)0)) >= p_39), 246UL)) || p_39), g_110.f5, p_39), l_142) != l_58), p_38, p_37, p_38, g_146) <= p_37), 253UL)))
    { /* block id: 76 */
        int32_t **l_160 = &g_92;
        (*g_92) = (l_142 <= ((safe_rshift_func_uint8_t_u_s(g_114, ((((p_39 < (&g_114 == (void*)0)) ^ (safe_add_func_uint8_t_u_u(p_39, g_100.f4))) == ((void*)0 != l_159)) | 0x1DBEL))) || p_37));
        (*l_160) = &p_38;
        /* statement id: 78 */
        assert (g_92 == &p_38);
    }
    else
    { /* block id: 79 */
        return g_146;
    }
    /* facts after branching */
    assert (g_92 == &p_38);
    return g_100.f6;
    /* statement id: 82 */
    //assert (g_92 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_109 g_100.f3
 * writes: g_100 g_110 g_92
 */
static int16_t  func_43(uint32_t  p_44, int64_t  p_45, uint32_t  p_46, int8_t  p_47, uint32_t  p_48)
{ /* block id: 72 */
    struct S0 l_152 = {0x9D7E73FBCBB49EDBLL,232,0xAAL,7UL,0x40A9L,0x13L,0xEA6424E3L};
    int32_t *l_153 = &g_114;
    int32_t **l_154 = &g_92;
    (*g_109) = l_152;
    (*l_154) = l_153;
    /* statement id: 74 */
    assert (g_92 == &g_114);
    return g_100.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_100.f1 g_100.f2 g_146
 * writes:
 */
inline static uint8_t  func_49(uint32_t  p_50, uint32_t  p_51)
{ /* block id: 69 */
    int32_t l_147 = 0x8255C92AL;
    int32_t *l_150 = &l_147;
    int32_t l_151 = 0x83F17E09L;
    (*l_150) = (((safe_unary_minus_func_int32_t_s(g_100.f1)) == (safe_lshift_func_int16_t_s_u(p_51, (((g_100.f2 >= g_146) ^ l_147) <= (safe_lshift_func_int8_t_s_s(((void*)0 != &l_147), (p_51 <= (l_147 > p_51)))))))) >= l_147);
    return l_151;
}


/* ------------------------------------------ */
/* 
 * reads : g_100.f6 g_109 g_100 g_110.f0 g_110.f6 g_2 g_110.f3
 * writes: g_114 g_100.f6 g_109 g_100.f5 g_100.f3 g_110
 */
static uint32_t  func_52(int16_t  p_53, uint8_t  p_54, int32_t  p_55, uint64_t  p_56, int32_t  p_57)
{ /* block id: 35 */
    int32_t *l_112 = (void*)0;
    int32_t *l_113 = &g_114;
    struct S0 l_119 = {-9L,312,0xB7L,0UL,1L,-1L,0x63F42B18L};
    (*l_113) = 1L;
    for (g_100.f6 = 0; (g_100.f6 != 41); ++g_100.f6)
    { /* block id: 39 */
        struct S0 **l_117 = &g_109;
        int32_t **l_118 = &l_112;
        (*l_117) = &g_100;
        /* statement id: 40 */
        assert (g_109 == &g_100);
        if (p_53)
            break;
        (*l_118) = &g_114;
        /* statement id: 42 */
        assert (l_112 == &g_114);
        l_119 = (**l_117);
    }
    /* facts after for loop */
    assert (l_112 == &g_114 || l_112 == 0);
    for (g_100.f5 = 6; (g_100.f5 >= (-12)); g_100.f5 = safe_sub_func_int64_t_s_s(g_100.f5, 2))
    { /* block id: 47 */
        int32_t *l_122 = &g_2;
        int32_t **l_123 = &l_113;
        struct S0 l_140 = {0L,293,0xC5L,18446744073709551609UL,0x535CL,-3L,18446744073709551610UL};
        (*l_123) = l_122;
        /* statement id: 48 */
        assert (l_113 == &g_2);
        for (g_100.f3 = 9; (g_100.f3 > 55); g_100.f3 = safe_add_func_uint8_t_u_u(g_100.f3, 7))
        { /* block id: 51 */
            int64_t l_130 = 0xBE0F627EED8CCA49LL;
            g_114 = (safe_rshift_func_int8_t_s_u(((safe_mod_func_int64_t_s_s(((l_130 >= (g_110.f0 | g_110.f6)) != (safe_lshift_func_uint16_t_u_s((((&g_92 == &l_112) & (((g_100.f6 > (+(((safe_rshift_func_uint8_t_u_s(((((-3L) < (p_57 || ((-4L) ^ 0xD709L))) >= 0xCC1CL) && g_100.f6), (*l_122))) != 1UL) <= (**l_123)))) <= (*l_122)) < (*l_113))) == l_130), 12))), 0xD3F6C24A69B921A3LL)) == (*l_122)), 5));
        }
        for (p_54 = 0; (p_54 == 40); ++p_54)
        { /* block id: 56 */
            struct S0 *l_141 = &g_110;
            for (g_100.f3 = 0; (g_100.f3 >= 45); g_100.f3 = safe_add_func_int32_t_s_s(g_100.f3, 1))
            { /* block id: 59 */
                return g_110.f3;
            }
            (*l_123) = &g_114;
            /* statement id: 62 */
            assert (l_113 == &g_114);
            (*l_141) = l_140;
            (*l_123) = (void*)0;
            /* statement id: 64 */
            assert (l_113 == 0);
        }
        /* facts after for loop */
        assert (l_113 == 0 || l_113 == &g_2);
        return g_110.f0;
    }
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_100
 * writes: g_92 g_100
 */
static uint8_t  func_59(uint32_t  p_60, int32_t  p_61)
{ /* block id: 6 */
    int32_t l_91 = 0L;
    struct S0 l_93 = {0xCA20838156AC6DEALL,14,0UL,0UL,8L,4L,18446744073709551615UL};
    struct S0 *l_94 = &l_93;
    int32_t l_103 = (-5L);
    for (p_60 = 0; (p_60 > 42); p_60 = safe_add_func_int16_t_s_s(p_60, 6))
    { /* block id: 9 */
        int32_t l_64 = 0x743E62C9L;
        l_91 = ((((l_64 ^ (((((((safe_sub_func_uint8_t_u_u((safe_mul_func_uint8_t_u_u((((safe_mul_func_uint16_t_u_u(g_2, (l_64 ^ (safe_mul_func_int8_t_s_s(5L, (safe_rshift_func_uint8_t_u_s((safe_mul_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u(((((safe_add_func_int8_t_s_s(3L, (g_2 & ((safe_lshift_func_uint16_t_u_s(p_60, 15)) ^ (((safe_add_func_int16_t_s_s((safe_sub_func_int64_t_s_s((safe_sub_func_int8_t_s_s(p_60, ((safe_mod_func_int8_t_s_s(((-4L) < g_2), p_60)) > 0x14L))), p_60)), 7L)) & 0UL) <= 0x9FE2L))))) <= g_2) & 0UL) ^ p_60), g_2)), l_64)), 5))))))) < g_2) > l_64), g_2)), g_2)) ^ 0x7E338AE633C574C3LL) >= g_2) | p_60) & 4294967295UL) && p_60) <= p_61)) > p_61) >= l_64) >= g_2);
        if (g_2)
            break;
        if (g_2)
            break;
        g_92 = &l_91;
        /* statement id: 13 */
        assert (g_92 == &l_91);
    }
    /* facts after for loop */
    assert (g_92 == &l_91 || g_92 == 0 || g_92 == &g_2 || g_92 == &g_114);
    (*l_94) = l_93;
    for (l_91 = 0; (l_91 <= 6); l_91++)
    { /* block id: 18 */
        int32_t l_104 = 2L;
        int32_t *l_105 = (void*)0;
        int32_t *l_106 = &l_103;
        for (l_93.f5 = 0; (l_93.f5 <= 24); ++l_93.f5)
        { /* block id: 21 */
            int32_t *l_99 = &g_2;
            if ((l_99 == &l_91))
            { /* block id: 22 */
                struct S0 *l_101 = (void*)0;
                struct S0 *l_102 = &g_100;
                if (p_60)
                    break;
                (*l_102) = g_100;
            }
            else
            { /* block id: 25 */
                return g_100.f1;
                /* statement id: 26 */
                //assert (g_92 == dangling || g_92 == 0 || g_92 == &g_2 || g_92 == &g_114);
            }
            if (l_93.f1)
                continue;
        }
        l_103 = 1L;
        (*l_106) = l_104;
        if (p_61)
            continue;
    }
    return g_100.f6;
    /* statement id: 34 */
    //assert (g_92 == dangling || g_92 == 0 || g_92 == &g_2 || g_92 == &g_114);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_2;
    csmith_sink_ = g_100.f0;
    csmith_sink_ = g_100.f1;
    csmith_sink_ = g_100.f2;
    csmith_sink_ = g_100.f3;
    csmith_sink_ = g_100.f4;
    csmith_sink_ = g_100.f5;
    csmith_sink_ = g_100.f6;
    csmith_sink_ = g_110.f0;
    csmith_sink_ = g_110.f1;
    csmith_sink_ = g_110.f2;
    csmith_sink_ = g_110.f3;
    csmith_sink_ = g_110.f4;
    csmith_sink_ = g_110.f5;
    csmith_sink_ = g_110.f6;
    csmith_sink_ = g_114;
    csmith_sink_ = g_146;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 5
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 8
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 5
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 3

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 11
   depth: 5, occurrence: 1
   depth: 11, occurrence: 2
   depth: 17, occurrence: 1
   depth: 22, occurrence: 1
   depth: 26, occurrence: 1
   depth: 30, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 40

XXX times a variable address is taken: 52
XXX times a pointer is dereferenced on RHS: 7
breakdown:
   depth: 1, occurrence: 5
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 30
breakdown:
   depth: 1, occurrence: 30
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 39

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 70
   level: 2, occurrence: 7
XXX number of pointers point to pointers: 20
XXX number of pointers point to scalars: 12
XXX number of pointers point to structs: 8
XXX percent of pointers has null in alias set: 22.5
XXX average alias set size: 1.27

XXX times a non-volatile is read: 162
XXX times a non-volatile is write: 76
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 67
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 21
   depth: 2, occurrence: 12
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1

XXX percentage a fresh-made variable is used: 20.1
XXX percentage an existing variable is used: 79.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

