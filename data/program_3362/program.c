/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --jumps --no-longlong --no-force-non-uniform-arrays --math64 --muls --no-packed-struct --paranoid --pointers --no-structs --no-inline-function --no-return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      18259906535632486525
 */


#define NO_LONGLONG

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int16_t g_2 = 0x37BC;
static int32_t g_12 = 0xED6F1860;
static int32_t g_18 = 0x8D927F7B;
static int32_t *g_93 = &g_18;
static int32_t **g_92 = &g_93;
static uint32_t g_152 = 4294967294U;
static int32_t *g_256 = &g_18;
static int32_t ***g_297 = &g_92;
static int32_t ****g_382 = (void*)0;
static int32_t ***** const g_381 = &g_382;
static const int32_t *g_506 = &g_18;
static const int32_t **g_505 = &g_506;
static const int32_t ***g_504 = &g_505;
static const int32_t ****g_503 = &g_504;
static const int32_t ***** const g_502 = &g_503;
static int32_t g_535 = 0xA3FA2306;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static uint32_t  func_3(int32_t  p_4, int32_t  p_5, int32_t  p_6, const uint8_t  p_7);
static uint32_t  func_13(int32_t  p_14, int32_t * p_15, int8_t  p_16);
static int32_t * func_45(uint8_t  p_46, int32_t * const  p_47, int32_t * p_48);
static int32_t ** func_52(const uint8_t  p_53, int32_t ** p_54, const uint8_t  p_55, uint16_t  p_56);
static int32_t  func_65(int16_t  p_66, int32_t * p_67, uint16_t  p_68, int16_t  p_69, uint32_t  p_70);
static int32_t * func_72(int32_t  p_73, int32_t ** p_74, int32_t  p_75, int32_t ** p_76, int16_t  p_77);
static int32_t ** func_78(int16_t  p_79);
static int32_t * func_82(uint16_t  p_83);
static int32_t * const * func_84(int32_t ** p_85, int32_t ** p_86, uint32_t  p_87, int32_t * p_88, int32_t ** p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_12 g_18 g_256 g_382 g_502 g_503 g_92 g_93 g_535
 * writes: g_12 g_18 g_2
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_9 = 0x4185A1FA;
    int32_t *l_17 = &g_18;
    int32_t **l_482 = &g_256;
    int32_t *****l_486 = &g_382;
    int32_t l_493 = 0xDDD20A62;
    const int32_t *l_520 = &g_12;
    uint8_t l_549 = 0x1B;
    int32_t ***l_566 = &l_482;
    if (((g_2 == func_3((safe_unary_minus_func_int16_t_s(((g_2 > l_9) & g_2))), l_9, l_9, l_9)) & func_13(l_9, l_17, (*l_17))))
    { /* block id: 6 */
        int32_t *l_49 = (void*)0;
        const int32_t l_51 = (-1);
        int32_t ***l_497 = &l_482;
        int32_t l_518 = 0xEE99539F;
        uint16_t l_522 = 65533U;
        (*l_17) = (*l_17);
        for (g_2 = 27; (g_2 == 6); g_2 = safe_sub_func_uint32_t_u_u(g_2, 1))
        { /* block id: 10 */
            uint8_t l_50 = 0x35;
            int32_t **l_64 = (void*)0;
            int32_t l_533 = 7;
            int32_t *l_534 = &g_535;
        }
    }
    else
    { /* block id: 201 */
        int8_t l_559 = 0xC9;
        (**g_92) = (~(safe_sub_func_uint32_t_u_u((safe_mul_func_uint16_t_u_u((safe_add_func_uint8_t_u_u(((safe_lshift_func_uint8_t_u_u((((-10) ^ l_559) == l_559), (**l_482))) == ((*l_486) == (*g_502))), (((void*)0 != l_486) < 0U))), (*l_520))), l_559)));
    }
    if ((safe_mod_func_int8_t_s_s((safe_lshift_func_uint16_t_u_u((safe_sub_func_int8_t_s_s(((void*)0 == l_566), (safe_lshift_func_int8_t_s_s(0, 0)))), (safe_mul_func_uint16_t_u_u((&g_382 == &g_503), (!(((safe_add_func_int16_t_s_s((***l_566), 9)) || 4294967288U) && (**l_482))))))), 0x48)))
    { /* block id: 204 */
        return g_18;
    }
    else
    { /* block id: 206 */
        return g_535;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_12
 * writes: g_12
 */
static uint32_t  func_3(int32_t  p_4, int32_t  p_5, int32_t  p_6, const uint8_t  p_7)
{ /* block id: 1 */
    int16_t l_10 = (-1);
    int32_t *l_11 = &g_12;
    (*l_11) = l_10;
    return (*l_11);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_13(int32_t  p_14, int32_t * p_15, int8_t  p_16)
{ /* block id: 4 */
    uint16_t l_19 = 9U;
    return l_19;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_18 g_12
 */
static int32_t * func_45(uint8_t  p_46, int32_t * const  p_47, int32_t * p_48)
{ /* block id: 11 */
    (*p_47) = 0x587697AB;
    return p_48;
    /* statement id: 13 */
    //assert (func_45_rv == 0 || func_45_rv == &g_12 || func_45_rv == &g_18);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_256 g_18 g_12 g_297 g_92 g_93 g_152
 * writes: g_18 g_12 g_93 g_92 g_256
 */
static int32_t ** func_52(const uint8_t  p_53, int32_t ** p_54, const uint8_t  p_55, uint16_t  p_56)
{ /* block id: 15 */
    uint8_t l_71 = 0x5A;
    int32_t **l_280 = &g_256;
    int32_t l_281 = 0x0B8EACD4;
    int32_t ****l_342 = &g_297;
    (**l_280) = func_65(g_2, (*l_280), p_56, l_281, (**l_280));
    /* statement id: 117 */
    assert (g_93 == &g_12 || g_93 == &g_18);
    (**g_297) = (*g_92);
    for (l_71 = 0; (l_71 != 5); l_71++)
    { /* block id: 121 */
        (**g_297) = func_45((safe_mod_func_uint8_t_u_u((safe_add_func_uint32_t_u_u(4294967286U, (((**g_92) == (**l_280)) <= p_55))), (safe_rshift_func_int8_t_s_u((-7), g_18)))), (*l_280), (*g_92));
    }
    if ((**g_92))
    { /* block id: 124 */
        int32_t ****l_327 = &g_297;
        (*l_280) = func_82((safe_mod_func_int8_t_s_s((((p_56 | g_18) ^ (safe_rshift_func_int16_t_s_u((safe_mul_func_int8_t_s_s((safe_add_func_int32_t_s_s(((g_152 > (&g_297 != l_327)) == (safe_rshift_func_uint16_t_u_s((g_152 == (((+p_55) >= ((0x089725B4 < (4294967290U || p_55)) > (****l_327))) < p_53)), 14))), (-4))), (****l_327))), p_53))) && 0x8494), (**l_280))));
        /* statement id: 125 */
        assert (g_93 == &g_12 || g_93 == &g_18 || g_93 == 0);
        assert (g_92 == &g_93 || g_92 == 0);
        assert (g_256 == &g_12);
        (**l_280) = (p_56 ^ 0x9DCE);
    }
    else
    { /* block id: 127 */
        uint8_t l_343 = 0x30;
        int32_t ***l_344 = &l_280;
        uint32_t l_448 = 0U;
        int32_t l_458 = 0x00A3AFB4;
        int32_t l_461 = 0x7DF8C571;
        int32_t l_481 = 0x9ECE6004;
        if (((safe_mul_func_int8_t_s_s((safe_mul_func_int16_t_s_s((safe_unary_minus_func_uint32_t_u((((safe_rshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_u(65535U, (safe_lshift_func_int8_t_s_u((**l_280), ((l_342 != (void*)0) ^ (g_2 > l_343)))))), (l_344 == &p_54))) < (safe_sub_func_int16_t_s_s(p_55, (***l_344)))) < (***l_344)))), p_55)), g_18)) ^ 0x0B0F))
        { /* block id: 128 */
            int8_t l_363 = (-1);
            const int32_t l_394 = (-7);
            int32_t *l_399 = (void*)0;
            uint16_t l_415 = 65530U;
            int32_t * const ** const *l_446 = (void*)0;
            int32_t * const ** const ** const l_445 = &l_446;
            const int32_t l_447 = 0x4864215C;
            uint32_t l_449 = 4294967295U;
        }
        else
        { /* block id: 167 */
            int32_t *l_468 = &g_12;
            for (g_18 = (-24); (g_18 >= 7); g_18 = safe_add_func_int8_t_s_s(g_18, 2))
            { /* block id: 170 */
                if ((**l_280))
                    break;
                (**g_297) = l_468;
                /* statement id: 172 */
                assert (g_93 == &g_12);
            }
        }
        (**l_280) = ((safe_rshift_func_uint16_t_u_u((!(****l_342)), (***l_344))) > (((-1) >= g_12) || ((safe_rshift_func_uint16_t_u_u(((safe_lshift_func_int8_t_s_s((!0x4FAC), 1)) ^ ((safe_mod_func_uint32_t_u_u(p_55, (***l_344))) > (((0x9BD7 | (&g_382 == &l_342)) ^ (**l_280)) <= g_18))), l_481)) != p_53)));
    }
    /* facts after branching */
    assert (g_93 == &g_12 || g_93 == &g_18 || g_93 == 0);
    assert (g_92 == &g_93 || g_92 == 0);
    assert (g_256 == &g_18 || g_256 == &g_12);
    return (**l_342);
    /* statement id: 177 */
    //assert (func_52_rv == &g_93 || func_52_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_18 g_297 g_256 g_92 g_93
 * writes: g_18 g_12 g_93
 */
static int32_t  func_65(int16_t  p_66, int32_t * p_67, uint16_t  p_68, int16_t  p_69, uint32_t  p_70)
{ /* block id: 108 */
    int32_t l_296 = (-1);
    int32_t ** const *l_305 = (void*)0;
    int32_t ** const **l_304 = &l_305;
    (*p_67) = 0xB4AD64C4;
    for (g_12 = 2; (g_12 == (-6)); --g_12)
    { /* block id: 112 */
        int16_t l_298 = (-5);
        int32_t *l_310 = &g_12;
        (**g_297) = func_72((safe_mod_func_uint8_t_u_u((0x4E970706 && (safe_rshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u(g_18, (safe_mul_func_uint8_t_u_u(((g_18 <= (((&p_67 == &g_256) & (safe_mul_func_int8_t_s_s(((safe_sub_func_uint8_t_u_u(l_296, (((g_297 != (void*)0) == ((g_18 > l_296) ^ 0x02)) ^ 0xD8))) && (*g_256)), g_18))) || 0x17)) & p_70), l_296)))), 3))), g_12)), (*g_297), l_298, (*g_297), g_18);
        /* statement id: 113 */
        assert (g_93 == 0);
        (*g_92) = l_310;
        /* statement id: 114 */
        assert (g_93 == &g_12);
    }
    /* facts after for loop */
    assert (g_93 == &g_12 || g_93 == &g_18);
    return (*p_67);
}


/* ------------------------------------------ */
/* 
 * reads : g_256 g_92 g_93
 * writes: g_256 g_93
 */
static int32_t * func_72(int32_t  p_73, int32_t ** p_74, int32_t  p_75, int32_t ** p_76, int16_t  p_77)
{ /* block id: 104 */
    (*p_76) = (void*)0;
    /* statement id: 105 */
    assert (g_93 == &g_12 || g_93 == 0);
    assert (g_256 == 0 || g_256 == &g_18);
    (*g_92) = (*p_76);
    /* statement id: 106 */
    assert (g_93 == 0);
    return (*g_92);
    /* statement id: 107 */
    //assert (func_72_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_92
 * writes: g_93
 */
static int32_t ** func_78(int16_t  p_79)
{ /* block id: 16 */
    int32_t *l_81 = &g_12;
    int32_t **l_80 = &l_81;
    (*g_92) = (*l_80);
    /* statement id: 101 */
    assert (g_93 == &g_12);
    (*l_80) = (*l_80);
    return &g_93;
    /* statement id: 103 */
    //assert (func_78_rv == &g_93);
}


/* ------------------------------------------ */
/* 
 * reads : g_92 g_18 g_93 g_2 g_12 g_152 g_256
 * writes: g_93 g_18 g_12 g_92
 */
static int32_t * func_82(uint16_t  p_83)
{ /* block id: 17 */
    int32_t *l_91 = &g_12;
    int32_t **l_90 = &l_91;
    int32_t * const *l_269 = &l_91;
    int32_t * const **l_268 = &l_269;
    (*l_268) = func_84(l_90, g_92, g_18, (*g_92), &l_91);
    /* statement id: 98 */
    assert (l_91 == &g_18 || l_91 == 0 || l_91 == &g_12);
    assert (g_93 == &g_12 || g_93 == &g_18 || g_93 == 0);
    assert (g_92 == &g_93 || g_92 == 0);
    assert (l_269 == &g_93);
    (*g_256) = 8;
    return &g_12;
    /* statement id: 100 */
    //assert (func_82_rv == &g_12);
}


/* ------------------------------------------ */
/* 
 * reads : g_92 g_93 g_2 g_12 g_18 g_152 g_256
 * writes: g_93 g_18 g_12 g_92
 */
static int32_t * const * func_84(int32_t ** p_85, int32_t ** p_86, uint32_t  p_87, int32_t * p_88, int32_t ** p_89)
{ /* block id: 18 */
    uint16_t l_98 = 8U;
    uint16_t l_105 = 0x0E51;
    int32_t *l_112 = (void*)0;
    uint32_t l_254 = 0x3F9AC471;
    (*p_86) = (*g_92);
    (**p_86) = ((g_2 ^ (((((safe_mul_func_int8_t_s_s((((((&g_93 != &p_88) ^ 1U) ^ (((&g_93 == &g_93) ^ l_98) == (0x06 && g_12))) != p_87) > l_98), p_87)) < l_98) >= p_87) && l_98) < 0x57EEBE84)) >= (*p_88));
    if ((((safe_mul_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u((((safe_mod_func_uint8_t_u_u(l_105, g_18)) <= g_2) > (safe_sub_func_int16_t_s_s(((safe_mul_func_uint16_t_u_u((safe_rshift_func_int8_t_s_s(((*p_85) != l_112), (l_112 == (*p_89)))), ((65529U >= (safe_unary_minus_func_int32_t_s((safe_lshift_func_int8_t_s_s((safe_rshift_func_int16_t_s_u((safe_mod_func_uint16_t_u_u((safe_unary_minus_func_uint8_t_u(((void*)0 != &g_93))), g_18)), 9)), p_87))))) & 0x83))) | g_18), g_2))), g_2)), l_98)) < l_105) ^ g_18))
    { /* block id: 21 */
        int32_t * const *l_121 = &g_93;
        (*p_85) = (*p_85);
        return l_121;
        /* statement id: 23 */
        //assert (func_84_rv == &g_93);
    }
    else
    { /* block id: 24 */
        const int32_t l_138 = (-9);
        int32_t **l_162 = &l_112;
        int32_t ***l_228 = &l_162;
        int32_t **** const l_227 = &l_228;
        for (l_98 = (-12); (l_98 <= 14); l_98 = safe_add_func_uint8_t_u_u(l_98, 4))
        { /* block id: 27 */
            int32_t *l_126 = &g_18;
            for (g_12 = 0; (g_12 > 28); g_12 = safe_add_func_uint32_t_u_u(g_12, 1))
            { /* block id: 30 */
                (*p_85) = l_126;
                /* statement id: 31 */
                //assert (l_91 == &g_18);
                if ((**p_89))
                    break;
                for (l_105 = 0; (l_105 >= 45); l_105++)
                { /* block id: 35 */
                    uint8_t l_131 = 0x3E;
                    for (g_18 = 0; (g_18 >= 29); g_18 = safe_add_func_uint16_t_u_u(g_18, 2))
                    { /* block id: 38 */
                        (*p_89) = (void*)0;
                        /* statement id: 39 */
                        //assert (l_91 == 0);
                        (*p_85) = (*g_92);
                        /* statement id: 40 */
                        //assert (l_91 == &g_18 || l_91 == &g_12);
                    }
                    /* facts after for loop */
                    //assert (l_91 == &g_18 || l_91 == &g_12);
                    if (l_131)
                        break;
                    return &g_93;
                    /* statement id: 43 */
                    //assert (func_84_rv == &g_93);
                }
                /* facts after for loop */
                //assert (l_91 == &g_18 || l_91 == &g_12);
            }
            /* facts after for loop */
            //assert (l_91 == &g_18 || l_91 == &g_12);
            (*g_92) = (void*)0;
            /* statement id: 46 */
            assert (g_93 == 0);
            (*p_88) = (safe_mod_func_uint32_t_u_u((g_2 != 0), (safe_mul_func_uint16_t_u_u(l_138, (safe_mul_func_uint8_t_u_u(g_2, (safe_mod_func_int8_t_s_s((safe_rshift_func_int8_t_s_u((((safe_lshift_func_int8_t_s_u((((((safe_mul_func_int16_t_s_s((-1), 0x41B9)) && (((safe_add_func_uint16_t_u_u((l_138 & (((0U < ((((safe_unary_minus_func_int32_t_s(((((*p_89) == (*g_92)) || 1U) >= g_18))) == (*l_126)) & (-6)) && (*l_126))) || (*l_126)) ^ 0x14)), 0x6BBB)) ^ g_18) || p_87)) && g_2) > g_152) != 4294967291U), 4)) ^ 253U) ^ 0x91), 5)), 0xE4))))))));
            return &g_93;
            /* statement id: 48 */
            //assert (func_84_rv == &g_93);
        }
        if ((safe_mod_func_int16_t_s_s(((safe_mul_func_uint8_t_u_u((0xB948F0CD < (((safe_add_func_int16_t_s_s(((void*)0 != &g_93), 0)) != ((void*)0 == (*g_92))) > (g_2 || (((*g_93) | g_18) > 0x090DF5CE)))), g_12)) | 0x87175307), g_18)))
        { /* block id: 50 */
            int32_t *l_159 = &g_12;
            int32_t ***l_160 = &g_92;
            int32_t **l_161 = &l_159;
            (*p_85) = (*p_89);
            (*l_160) = (void*)0;
            /* statement id: 52 */
            assert (g_92 == 0);
            if ((l_161 != l_162))
            { /* block id: 53 */
                int32_t * const l_163 = (void*)0;
                int32_t * const *l_173 = &l_159;
                (*p_86) = (*l_162);
                /* statement id: 54 */
                assert (g_93 == 0);
                for (g_12 = (-11); (g_12 <= (-26)); g_12 = safe_sub_func_uint16_t_u_u(g_12, 8))
                { /* block id: 57 */
                    uint32_t l_172 = 0U;
                    l_172 = g_18;
                    (*p_86) = (*l_161);
                    /* statement id: 59 */
                    assert (g_93 == &g_12);
                    return &g_93;
                    /* statement id: 60 */
                    //assert (func_84_rv == &g_93);
                }
            }
            else
            { /* block id: 62 */
                int8_t l_178 = 0x8D;
                int32_t ***l_196 = (void*)0;
            }
            /* facts after branching */
            assert (g_93 == &g_18 || g_93 == 0 || g_93 == &g_12);
        }
        else
        { /* block id: 90 */
            int8_t l_266 = (-7);
            int32_t *l_267 = &g_12;
            (*p_89) = (void*)0;
            /* statement id: 91 */
            //assert (l_91 == 0);
            (*p_86) = g_256;
            (**l_228) = func_45(p_87, (*g_92), func_45(((!(((((safe_sub_func_uint8_t_u_u(0x05, (((*g_92) != (*p_86)) ^ ((&g_92 != &p_85) != (safe_rshift_func_int8_t_s_s(p_87, 0)))))) | (safe_mul_func_uint16_t_u_u(((safe_add_func_uint32_t_u_u(p_87, (*p_88))) || l_266), g_152))) <= l_266) || p_87) <= 0x1B)) != g_2), (*g_92), l_267));
            /* statement id: 93 */
            assert (l_112 == &g_12);
        }
        /* facts after branching */
        assert (g_93 == &g_18 || g_93 == 0 || g_93 == &g_12);
        assert (g_92 == &g_93 || g_92 == 0);
        //assert (l_91 == 0 || l_91 == &g_12);
        assert (l_112 == &g_12 || l_112 == 0);
        (*g_256) = (*g_256);
    }
    /* facts after branching */
    assert (g_93 == &g_18 || g_93 == 0 || g_93 == &g_12);
    assert (g_92 == &g_93 || g_92 == 0);
    //assert (l_91 == 0 || l_91 == &g_12);
    assert (l_112 == &g_12 || l_112 == 0);
    return &g_93;
    /* statement id: 97 */
    //assert (func_84_rv == &g_93);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_2;
    csmith_sink_ = g_12;
    csmith_sink_ = g_18;
    csmith_sink_ = g_152;
    csmith_sink_ = g_535;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 85
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 11
   depth: 6, occurrence: 2
   depth: 9, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 77

XXX times a variable address is taken: 100
XXX times a pointer is dereferenced on RHS: 136
breakdown:
   depth: 1, occurrence: 84
   depth: 2, occurrence: 28
   depth: 3, occurrence: 19
   depth: 4, occurrence: 5
XXX times a pointer is dereferenced on LHS: 62
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 19
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 19
XXX times a pointer is compared with another pointer: 17
XXX times a pointer is qualified to be dereferenced: 329

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 287
   level: 2, occurrence: 85
   level: 3, occurrence: 31
   level: 4, occurrence: 15
   level: 5, occurrence: 11
XXX number of pointers point to pointers: 49
XXX number of pointers point to scalars: 28
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 33.8
XXX average alias set size: 1.29

XXX times a non-volatile is read: 732
XXX times a non-volatile is write: 171
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 71
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 17
   depth: 2, occurrence: 11
   depth: 3, occurrence: 7
   depth: 4, occurrence: 6
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 11.6
XXX percentage an existing variable is used: 88.4
********************* end of statistics **********************/

