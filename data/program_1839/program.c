/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --arrays --bitfields --checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --jumps --no-longlong --no-force-non-uniform-arrays --no-math64 --no-muls --no-packed-struct --paranoid --pointers --structs --no-inline-function --no-return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      1089418856
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S1 {
   uint32_t  f0;
   uint16_t  f1;
   uint16_t  f2;
   uint32_t  f3;
};

/* --- GLOBAL VARIABLES --- */
static uint16_t g_2[1][7] = {{0x1FC3, 0xDE2B, 0x1FC3, 0xDE2B, 0x1FC3, 0xDE2B, 0x1FC3}};
static int32_t g_3 = 0x65121AC4;
static int32_t g_6 = (-5);
static int32_t g_8 = 0xA55F07C7;
static int32_t *g_15 = (void*)0;
static int32_t **g_14[4][10] = {{&g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15}, {&g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15}, {&g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15}, {&g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15}};
static struct S1 g_71 = {0U,0xAF57,0x6627,0x1A9F1398};
static int32_t g_82[9] = {1, 1, 2, 1, 1, 2, 1, 1, 2};
static uint32_t g_104 = 1U;
static int32_t ***g_158 = &g_14[2][4];
static int32_t ****g_157 = &g_158;
static int32_t *****g_160[7] = {&g_157, &g_157, &g_157, &g_157, &g_157, &g_157, &g_157};
static uint8_t g_183 = 7U;
static int32_t g_208 = 0xC17DBC78;
static uint32_t g_308 = 0x268C0C08;
static int32_t *g_482 = &g_6;
static const int16_t g_523 = 1;
static uint16_t g_598 = 65526U;
static struct S1 g_626 = {5U,0x885D,0x3CCE,1U};
static int32_t *g_668 = &g_82[6];
static int32_t g_789 = 0x1891E8ED;
static struct S1 *** const g_815 = (void*)0;
static const int32_t *g_828 = &g_6;
static const int32_t **g_827 = &g_828;
static const int32_t ***g_826[9] = {&g_827, &g_827, &g_827, &g_827, &g_827, &g_827, &g_827, &g_827, &g_827};
static const int32_t ****g_825[1] = {&g_826[7]};
static int32_t ***g_839[5][4][2] = {{{&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}}, {{&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}}, {{&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}}, {{&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}}, {{&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}, {&g_14[2][4], &g_14[2][4]}}};
static int32_t *g_840 = &g_3;
static uint16_t g_901 = 0xC1E7;
static struct S1 *g_934 = (void*)0;
static struct S1 **g_933 = &g_934;


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_1(void);
static uint16_t  func_4(uint16_t  p_5);
static int32_t * func_9(uint8_t  p_10, int32_t  p_11, int32_t * p_12);
static int32_t * func_17(uint16_t  p_18);
static uint32_t  func_29(uint32_t  p_30);
static int32_t * func_35(int32_t ** p_36, uint32_t  p_37, int32_t *** p_38);
static int16_t  func_47(int32_t *** p_48, int32_t  p_49);
static int32_t *** func_50(int32_t ** p_51, uint32_t  p_52, int32_t *** p_53);
static uint16_t  func_57(int32_t  p_58, uint32_t  p_59);
static uint32_t  func_64(int16_t  p_65, struct S1  p_66, int32_t * p_67, int32_t ** const  p_68, int32_t * p_69);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_8 g_626.f2
 * writes: g_3 g_8
 */
static uint8_t  func_1(void)
{ /* block id: 0 */
    struct S1 *l_869 = &g_71;
    int32_t l_873 = 0x3F9EAEFC;
    uint8_t l_878[10] = {0x1E, 0U, 0x1E, 0U, 0x1E, 0U, 0x1E, 0U, 0x1E, 0U};
    int32_t *l_921[2][4];
    uint16_t l_945 = 0x1715;
    int16_t l_1047 = 0xDA62;
    int16_t l_1048 = (-1);
    int i, j;
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 4; j++)
            l_921[i][j] = &g_82[1];
    }
    for (g_3 = 0; (g_3 >= 0); g_3 -= 1)
    { /* block id: 3 */
        const struct S1 *l_868 = &g_71;
        int32_t l_870 = (-9);
        uint16_t l_916 = 65534U;
        int32_t *l_940 = &g_82[3];
    }
    for (g_8 = 0; (g_8 >= (-14)); g_8 = safe_sub_func_uint32_t_u_u(g_8, 2))
    { /* block id: 677 */
        int32_t ***l_953 = (void*)0;
        int32_t l_956 = 0x81CCA369;
        int8_t l_971 = 0;
        int8_t l_982 = 0x41;
        int32_t *l_987[7];
        struct S1 l_1025[2] = {{0xC8BDBD4C,65535U,1U,4294967295U}, {0xC8BDBD4C,65535U,1U,4294967295U}};
        int32_t l_1045 = 0x34A6B060;
        int32_t l_1046 = 0xED5CF17D;
        int8_t l_1049[5] = {3, 0xC6, 3, 0xC6, 3};
        int i;
        for (i = 0; i < 7; i++)
            l_987[i] = (void*)0;
    }
    return g_626.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_6 g_8 g_789
 * writes: g_6 g_8
 */
static uint16_t  func_4(uint16_t  p_5)
{ /* block id: 4 */
    for (p_5 = 0; (p_5 <= 0); p_5 += 1)
    { /* block id: 7 */
        int32_t *l_842 = &g_208;
        if (g_2[0][4])
            break;
        for (g_6 = 0; (g_6 <= 0); g_6 += 1)
        { /* block id: 11 */
            int32_t *l_7 = &g_8;
            int i, j;
            (*l_7) = g_2[g_6][(g_6 + 5)];
            for (g_8 = 0; (g_8 >= 0); g_8 -= 1)
            { /* block id: 15 */
                int32_t *l_13 = &g_6;
                int32_t l_848 = 0;
                int i, j;
            }
        }
    }
    return g_789;
}


/* ------------------------------------------ */
/* 
 * reads : g_14 g_2 g_6 g_8 g_15 g_71 g_308 g_157 g_158 g_104 g_3 g_208 g_183 g_482 g_82 g_598 g_626.f2 g_668 g_626 g_523 g_827 g_840
 * writes: g_14 g_71 g_482 g_308 g_15 g_208 g_104 g_82 g_183 g_626.f2 g_626 g_598 g_158 g_825 g_828
 */
static int32_t * func_9(uint8_t  p_10, int32_t  p_11, int32_t * p_12)
{ /* block id: 16 */
    int32_t ***l_16 = &g_14[3][7];
    int32_t l_567 = 1;
    int32_t *l_841 = &g_3;
    (*l_16) = g_14[2][4];
    p_12 = func_17((((g_2[0][3] <= ((safe_lshift_func_uint8_t_u_u(0x08, (safe_add_func_int8_t_s_s(p_11, 0)))) | ((safe_sub_func_int32_t_s_s((*p_12), (safe_mod_func_uint8_t_u_u(((safe_sub_func_uint32_t_u_u(func_29((g_8 >= (safe_mod_func_int16_t_s_s(g_6, (safe_mod_func_uint8_t_u_u((0x8A36 ^ 0x7D77), p_11)))))), p_11)) || p_10), (-1))))) | l_567))) < (*p_12)) > l_567));
    /* statement id: 586 */
    assert ((p_12 >= &g_82[0] && p_12 <= &g_82[8]) || p_12 == &g_6 || p_12 == &g_3);
    assert (g_15 == &g_8 || g_15 == 0);
    assert (g_482 == 0 || g_482 == &g_6 || (g_482 >= &g_82[0] && g_482 <= &g_82[8]));
    //assert (g_828 == &g_6 || g_828 == dangling);
    //assert (g_825[0] == 0 || (g_825[0] >= &g_826[0] && g_825[0] <= &g_826[8]));
    return l_841;
    /* statement id: 587 */
    //assert (func_9_rv == &g_3);
}


/* ------------------------------------------ */
/* 
 * reads : g_482 g_6 g_82 g_598 g_71.f0 g_183 g_626.f2 g_3 g_14 g_668 g_208 g_626 g_71.f3 g_8 g_157 g_104 g_2 g_523 g_158 g_71.f2 g_308 g_71 g_827 g_840
 * writes: g_15 g_71.f0 g_183 g_82 g_208 g_626.f2 g_71 g_482 g_626 g_598 g_158 g_825 g_828
 */
static int32_t * func_17(uint16_t  p_18)
{ /* block id: 362 */
    int32_t l_568 = (-1);
    int32_t l_570 = 3;
    int32_t l_596 = (-5);
    int32_t ***** const l_597 = &g_157;
    struct S1 *l_616[3];
    uint16_t l_693 = 65532U;
    int32_t *l_698 = &g_82[6];
    struct S1 *l_708 = &g_626;
    int i;
    for (i = 0; i < 3; i++)
        l_616[i] = &g_71;
    if ((l_568 < 1U))
    { /* block id: 363 */
        int32_t **l_569 = &g_15;
        (*l_569) = (void*)0;
        /* statement id: 364 */
        assert (g_15 == 0);
        l_570 = (*g_482);
        for (l_570 = 6; (l_570 > (-6)); l_570 = safe_sub_func_uint8_t_u_u(l_570, 7))
        { /* block id: 368 */
            int32_t *l_575[5][7][7] = {{{(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}}, {{(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}}, {{(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}}, {{(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}}, {{(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}, {(void*)0, (void*)0, &g_82[7], &g_82[6], &l_570, &g_82[4], (void*)0}}};
            int32_t ** const *l_582 = &g_14[2][4];
            int32_t ** const **l_581 = &l_582;
            int32_t ** const ***l_580 = &l_581;
            struct S1 l_584[9][7] = {{{8U,0xFF47,0x7F68,0U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {9U,1U,1U,5U}, {0x2CC59CD8,0x1DB2,0xD3CD,9U}, {9U,1U,1U,5U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {8U,0xFF47,0x7F68,0U}}, {{8U,0xFF47,0x7F68,0U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {9U,1U,1U,5U}, {0x2CC59CD8,0x1DB2,0xD3CD,9U}, {9U,1U,1U,5U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {8U,0xFF47,0x7F68,0U}}, {{8U,0xFF47,0x7F68,0U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {9U,1U,1U,5U}, {0x2CC59CD8,0x1DB2,0xD3CD,9U}, {9U,1U,1U,5U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {8U,0xFF47,0x7F68,0U}}, {{8U,0xFF47,0x7F68,0U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {9U,1U,1U,5U}, {0x2CC59CD8,0x1DB2,0xD3CD,9U}, {9U,1U,1U,5U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {8U,0xFF47,0x7F68,0U}}, {{8U,0xFF47,0x7F68,0U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {9U,1U,1U,5U}, {0x2CC59CD8,0x1DB2,0xD3CD,9U}, {9U,1U,1U,5U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {8U,0xFF47,0x7F68,0U}}, {{8U,0xFF47,0x7F68,0U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {9U,1U,1U,5U}, {0x2CC59CD8,0x1DB2,0xD3CD,9U}, {9U,1U,1U,5U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {8U,0xFF47,0x7F68,0U}}, {{8U,0xFF47,0x7F68,0U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {9U,1U,1U,5U}, {0x2CC59CD8,0x1DB2,0xD3CD,9U}, {9U,1U,1U,5U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {8U,0xFF47,0x7F68,0U}}, {{8U,0xFF47,0x7F68,0U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {9U,1U,1U,5U}, {0x2CC59CD8,0x1DB2,0xD3CD,9U}, {9U,1U,1U,5U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {8U,0xFF47,0x7F68,0U}}, {{8U,0xFF47,0x7F68,0U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {9U,1U,1U,5U}, {0x2CC59CD8,0x1DB2,0xD3CD,9U}, {9U,1U,1U,5U}, {4294967295U,0x2927,0x32E7,0x602001DA}, {8U,0xFF47,0x7F68,0U}}};
            struct S1 l_585 = {4294967292U,1U,0x8174,0xE4E32368};
            int i, j, k;
        }
    }
    else
    { /* block id: 397 */
        l_596 = (l_597 != (void*)0);
    }
    if (g_598)
    { /* block id: 400 */
        int32_t l_604 = 0x2B030D81;
        int32_t ** const ***l_607 = (void*)0;
        uint8_t l_612 = 0xDA;
        int32_t *l_656 = &l_604;
        struct S1 l_671[8][2][2] = {{{{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}, {{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}}, {{{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}, {{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}}, {{{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}, {{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}}, {{{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}, {{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}}, {{{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}, {{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}}, {{{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}, {{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}}, {{{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}, {{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}}, {{{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}, {{0xB4C01A84,6U,0xCEE5,0xC5C25D91}, {0x609A01F7,0x0471,65532U,1U}}}};
        int32_t ***l_676 = &g_14[2][4];
        uint32_t l_684 = 4294967288U;
        int i, j, k;
        for (g_71.f0 = 0; (g_71.f0 != 12); g_71.f0 = safe_add_func_uint16_t_u_u(g_71.f0, 3))
        { /* block id: 403 */
            int32_t * const *l_602 = (void*)0;
            const int32_t *l_618 = &l_570;
            int32_t l_623 = 3;
            const int32_t * const ***l_667 = (void*)0;
            for (g_183 = 0; (g_183 <= 8); g_183 += 1)
            { /* block id: 406 */
                int32_t *l_603 = &l_596;
                int i;
                g_82[g_183] = (~(g_82[g_183] < (l_602 == (void*)0)));
                if (g_82[g_183])
                    continue;
                for (g_208 = 3; (g_208 >= 0); g_208 -= 1)
                { /* block id: 411 */
                    int i, j;
                    l_603 = &g_82[g_183];
                    /* statement id: 412 */
                    assert ((l_603 >= &g_82[0] && l_603 <= &g_82[8]));
                }
                /* facts after for loop */
                assert ((l_603 >= &g_82[0] && l_603 <= &g_82[8]) || l_603 == &l_596);
            }
            if (l_604)
                break;
        }
        for (l_570 = 0; (l_570 <= (-28)); l_570--)
        { /* block id: 468 */
            uint16_t l_681 = 65531U;
            struct S1 l_687 = {6U,0U,0xEEEB,0x116CA6AF};
            l_671[5][0][1] = l_671[5][0][1];
            for (g_626.f2 = 0; (g_626.f2 <= 58); ++g_626.f2)
            { /* block id: 472 */
                uint32_t l_685 = 0xE88929F2;
                struct S1 l_686 = {0xE75DBA60,0U,4U,0x679DBFFC};
                (*l_656) = ((safe_sub_func_uint16_t_u_u(((void*)0 != l_676), (safe_rshift_func_int16_t_s_s(((((((safe_lshift_func_uint8_t_u_s(g_6, 2)) < (((l_681 < (safe_mod_func_int16_t_s_s((0x10EB7D0C != p_18), 9))) > (*l_656)) >= 0x1703D373)) | g_3) ^ 1) > 65533U) && l_684), g_183)))) && l_685);
                if (l_685)
                    break;
                l_687 = l_686;
            }
        }
        (*g_668) = ((void*)0 == (*l_676));
        g_71 = l_671[6][0][0];
    }
    else
    { /* block id: 480 */
        int32_t *l_690 = &g_82[0];
        int16_t l_709 = (-10);
        int32_t ***l_723 = &g_14[2][4];
        int32_t l_745 = 0xF1B11CD1;
        int32_t *****l_778 = &g_157;
        uint32_t l_812[7][3][3] = {{{0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}}, {{0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}}, {{0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}}, {{0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}}, {{0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}}, {{0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}}, {{0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}, {0x88581490, 0U, 0x88581490}}};
        int8_t l_823[9];
        int32_t *l_835 = &g_8;
        int32_t *l_836 = &l_596;
        int i, j, k;
        for (i = 0; i < 9; i++)
            l_823[i] = 0xC1;
        for (l_596 = 0; (l_596 <= 6); l_596 += 1)
        { /* block id: 483 */
            int32_t l_688[8] = {1, 1, 1, 1, 1, 1, 1, 1};
            int32_t *l_692 = &g_6;
            int i;
            for (g_71.f1 = 1; (g_71.f1 <= 6); g_71.f1 += 1)
            { /* block id: 486 */
                int32_t *l_689 = &l_570;
                for (g_183 = 0; (g_183 <= 6); g_183 += 1)
                { /* block id: 489 */
                    int i;
                    l_688[4] = p_18;
                    if (p_18)
                        break;
                }
                l_690 = l_689;
                /* statement id: 493 */
                assert (l_690 == &l_570);
            }
            l_690 = &l_570;
            /* statement id: 495 */
            assert (l_690 == &l_570);
            for (g_208 = 0; (g_208 <= 6); g_208 += 1)
            { /* block id: 498 */
                int32_t **l_691 = &g_482;
                int i;
                (*l_691) = (void*)0;
                /* statement id: 499 */
                assert (g_482 == 0);
                return l_692;
                /* statement id: 500 */
                //assert (func_17_rv == &g_6);
            }
        }
        /* facts after for loop */
        assert (l_690 == &l_570 || (l_690 >= &g_82[0] && l_690 <= &g_82[8]));
        g_626 = g_626;
        if (((p_18 & l_693) | (safe_rshift_func_uint16_t_u_u(g_71.f3, 9))))
        { /* block id: 504 */
            int32_t *l_696 = &g_82[4];
            int32_t **l_697[9] = {&g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15, &g_15};
            const int16_t l_753 = (-2);
            struct S1 l_754 = {4294967295U,9U,0x82CE,0x9948C19C};
            int32_t **l_760 = (void*)0;
            int i;
lbl_756:
            l_698 = l_696;
            if (((((~((safe_sub_func_int16_t_s_s((((safe_add_func_int16_t_s_s((*l_696), ((p_18 ^ ((safe_add_func_int32_t_s_s(((void*)0 != &l_697[7]), (safe_lshift_func_uint16_t_u_s((l_708 != &g_71), (p_18 && p_18))))) > ((g_8 && p_18) <= 0))) && 0x1A))) || 0x4A563222) || (*l_698)), p_18)) > l_709)) > (-2)) && (-5)) & (*l_690)))
            { /* block id: 506 */
                int32_t l_720 = 0x6427ABC0;
                for (g_183 = 16; (g_183 == 27); g_183 = safe_add_func_uint16_t_u_u(g_183, 3))
                { /* block id: 509 */
                    for (g_598 = 4; (g_598 >= 25); g_598 = safe_add_func_uint32_t_u_u(g_598, 6))
                    { /* block id: 512 */
                        if ((*g_482))
                            break;
                    }
                    (*l_696) = (((void*)0 == (*l_597)) <= ((g_104 != 0x55CDB4B3) && ((((((g_626.f0 == ((safe_lshift_func_uint16_t_u_u(g_2[0][4], 7)) > ((safe_rshift_func_uint8_t_u_u((safe_sub_func_int32_t_s_s(((l_720 != (*l_690)) < (6U == 0xBDD8)), (*l_690))), (*l_690))) & g_2[0][3]))) ^ p_18) >= p_18) < g_523) < p_18) == 0x5A88)));
                }
                (*g_668) = (*l_698);
                l_690 = l_690;
                (*g_668) = (safe_lshift_func_uint8_t_u_s(250U, (((p_18 ^ (((*g_157) != l_723) != g_71.f2)) > ((g_626.f2 | (g_208 || ((0x435F | (safe_sub_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_u((((((safe_add_func_uint16_t_u_u(((((-5) ^ 0x499427B7) || g_71.f0) || g_104), 0xE30E)) >= l_720) || 7) & g_8) ^ 250U), (*l_698))) || 0xCD8AC970), 8)), p_18))) > p_18))) | 0x801C)) > g_82[6])));
            }
            else
            { /* block id: 520 */
                uint32_t l_752 = 4294967295U;
                struct S1 l_755 = {1U,0xEB4C,65528U,0x1C3D45CA};
                int32_t *l_761 = (void*)0;
                if (((*l_696) <= (safe_lshift_func_uint16_t_u_s((((((*l_690) | (((void*)0 != l_597) <= (1U <= ((g_183 >= (safe_rshift_func_uint16_t_u_s(p_18, 11))) > g_2[0][4])))) | (((*l_723) == (***l_597)) || g_183)) | 0x6D70) && g_71.f2), p_18))))
                { /* block id: 521 */
                    int32_t *l_740 = &g_82[7];
                    (*l_708) = g_626;
                    for (g_71.f3 = 0; (g_71.f3 != 46); ++g_71.f3)
                    { /* block id: 525 */
                        l_740 = l_740;
                        l_698 = l_740;
                        l_690 = l_690;
                        (*l_696) = (safe_sub_func_int8_t_s_s((((((safe_sub_func_uint16_t_u_u(l_745, g_626.f0)) || (((safe_sub_func_int16_t_s_s((safe_mod_func_uint8_t_u_u((0xA4AF07C3 >= 0U), g_523)), ((safe_lshift_func_uint16_t_u_u(65529U, 0)) && g_183))) & (((1 > l_752) | g_308) | 9)) >= 0xA8E5)) >= (-1)) & 6) >= l_753), 3));
                    }
                    l_755 = l_754;
                    if (l_754.f0)
                        goto lbl_756;
                }
                else
                { /* block id: 533 */
                    const int32_t *l_758 = &l_570;
                    const int32_t **l_757 = &l_758;
                    int32_t *l_759 = &g_82[6];
                    for (g_626.f1 = 0; (g_626.f1 <= 6); g_626.f1 += 1)
                    { /* block id: 536 */
                        l_757 = (void*)0;
                        /* statement id: 537 */
                        assert (l_757 == 0);
                        return l_759;
                        /* statement id: 538 */
                        //assert ((func_17_rv >= &g_82[0] && func_17_rv <= &g_82[8]));
                    }
                    (*l_757) = l_761;
                    /* statement id: 540 */
                    assert (l_758 == 0);
                    g_626 = g_71;
                    (*l_757) = l_761;
                }
            }
        }
        else
        { /* block id: 545 */
            int32_t *l_762 = &g_82[6];
            uint32_t l_788 = 0xDD1A980D;
            const int32_t ****l_822 = (void*)0;
            const int32_t *****l_824 = (void*)0;
            struct S1 **l_838 = &l_708;
            struct S1 *** const l_837 = &l_838;
            for (g_626.f3 = 0; (g_626.f3 <= 8); g_626.f3 += 1)
            { /* block id: 548 */
                struct S1 **l_817 = &l_616[2];
                struct S1 *** const l_816 = &l_817;
                int i;
                if (g_82[g_626.f3])
                    break;
                if (p_18)
                    continue;
                for (l_709 = 0; (l_709 <= 3); l_709 += 1)
                { /* block id: 553 */
                    int8_t l_775[5];
                    uint8_t l_804 = 252U;
                    int i, j;
                    for (i = 0; i < 5; i++)
                        l_775[i] = 0x69;
                    l_698 = (void*)0;
                    /* statement id: 554 */
                    assert (l_698 == 0);
                }
                if (l_823[5])
                    continue;
            }
            /* facts after for loop */
            assert (l_698 == 0 || (l_698 >= &g_82[0] && l_698 <= &g_82[8]));
            (*g_157) = (**l_778);
            g_825[0] = l_822;
            /* statement id: 580 */
            //assert (g_825[0] == 0 || (g_825[0] >= &g_826[0] && g_825[0] <= &g_826[8]));
            (*l_836) = ((((safe_rshift_func_uint16_t_u_s((+(+(p_18 & ((l_835 != l_836) & ((g_308 || p_18) < ((void*)0 != l_837)))))), p_18)) & g_208) && 0x794096D9) && 0x70);
        }
        /* facts after branching */
        assert (l_698 == 0 || (l_698 >= &g_82[0] && l_698 <= &g_82[8]));
        //assert (g_825[0] == 0 || (g_825[0] >= &g_826[0] && g_825[0] <= &g_826[8]));
    }
    /* facts after branching */
    assert (l_698 == 0 || (l_698 >= &g_82[0] && l_698 <= &g_82[8]));
    //assert (g_825[0] == 0 || (g_825[0] >= &g_826[0] && g_825[0] <= &g_826[8]));
    (*g_827) = &l_596;
    /* statement id: 584 */
    assert (g_828 == &l_596);
    return g_840;
    /* statement id: 585 */
    //assert (g_828 == dangling);
    //assert (func_17_rv == &g_3);
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_71 g_308 g_6 g_157 g_158 g_104 g_3 g_208 g_183 g_482 g_82
 * writes: g_71 g_482 g_308 g_15 g_208 g_104 g_82
 */
static uint32_t  func_29(uint32_t  p_30)
{ /* block id: 18 */
    int32_t *l_566 = &g_82[7];
    l_566 = func_35(&g_15, p_30, &g_14[1][7]);
    /* statement id: 360 */
    assert (g_15 == &g_8 || g_15 == 0);
    assert (g_482 == &g_6 || (g_482 >= &g_82[0] && g_482 <= &g_82[8]));
    assert (l_566 == &g_8 || l_566 == 0);
    return p_30;
}


/* ------------------------------------------ */
/* 
 * reads : g_15 g_71 g_308 g_6 g_157 g_158 g_104 g_3 g_208 g_183 g_482 g_82
 * writes: g_71 g_482 g_308 g_15 g_208 g_104 g_82
 */
static int32_t * func_35(int32_t ** p_36, uint32_t  p_37, int32_t *** p_38)
{ /* block id: 19 */
    int32_t **l_54 = &g_15;
    int32_t l_70[4] = {1, 0xF123EFBB, 1, 0xF123EFBB};
    int16_t l_542 = 0x899C;
    int i;
    if ((safe_sub_func_uint16_t_u_u((((*p_36) != (void*)0) == ((safe_add_func_int32_t_s_s((safe_lshift_func_int16_t_s_u(((253U != 255U) && (safe_rshift_func_int8_t_s_u(((func_47(func_50(l_54, ((safe_add_func_uint16_t_u_u(func_57((safe_sub_func_uint8_t_u_u((((safe_mod_func_uint32_t_u_u(((*p_36) != (*l_54)), func_64(((l_70[2] != (l_70[0] >= 0x88A0)) != p_37), g_71, (*l_54), &g_15, (*l_54)))) > 0xD2) < p_37), (-7))), g_6), 0xBFFE)) >= p_37), (*g_157)), l_70[1]) != l_70[2]) >= p_37), 4))), g_104)), 0)) == g_3)), l_70[1])))
    { /* block id: 317 */
        uint16_t l_539 = 1U;
        struct S1 l_559 = {0x06E3CAB8,65529U,0xC234,0xADA5B92E};
        for (g_308 = (-29); (g_308 >= 58); g_308 = safe_add_func_int8_t_s_s(g_308, 1))
        { /* block id: 320 */
            (*p_36) = (*l_54);
        }
        for (g_308 = 0; (g_308 <= 3); g_308 += 1)
        { /* block id: 325 */
            int8_t l_555 = 0;
            uint16_t l_556 = 0x4058;
            for (g_71.f1 = 0; (g_71.f1 <= 3); g_71.f1 += 1)
            { /* block id: 328 */
                int32_t * const *l_554 = &g_482;
                int32_t * const **l_553 = &l_554;
                int32_t * const *** const l_552 = &l_553;
                int32_t *l_557 = &g_208;
                int i, j;
                (*l_54) = (void*)0;
                if (l_539)
                    break;
                (*l_557) = (p_37 > ((safe_add_func_int32_t_s_s((((((((l_542 & (safe_rshift_func_uint8_t_u_u(((safe_unary_minus_func_uint16_t_u(((safe_mod_func_uint16_t_u_u(l_539, 0xF0B8)) | ((safe_add_func_int16_t_s_s(((((safe_mod_func_uint32_t_u_u((1U > (g_208 >= (((l_552 == &p_38) | l_555) & g_183))), l_555)) >= 1) && (**l_554)) & p_37), p_37)) || p_37)))) != g_308), p_37))) != l_539) != g_82[5]) <= 0x1B76) & 0x10) >= p_37) == l_555), l_539)) <= l_556));
            }
            if ((*g_482))
                break;
            for (l_542 = 0; (l_542 <= 3); l_542 += 1)
            { /* block id: 336 */
                struct S1 *l_560 = &l_559;
                int32_t *l_561 = &g_8;
                if ((0xD5 | g_6))
                { /* block id: 337 */
                    (*p_36) = (*p_36);
                }
                else
                { /* block id: 339 */
                    struct S1 *l_558 = &g_71;
                    (*l_558) = g_71;
                    (*p_36) = (*p_36);
                }
                (*l_560) = l_559;
                return l_561;
                /* statement id: 344 */
                //assert (func_35_rv == &g_8);
            }
        }
    }
    else
    { /* block id: 347 */
        int32_t *l_562 = &g_8;
        (*p_36) = l_562;
        /* statement id: 348 */
        assert (g_15 == &g_8);
        for (g_208 = 27; (g_208 >= 0); --g_208)
        { /* block id: 351 */
            for (g_104 = 0; (g_104 <= 6); g_104 += 1)
            { /* block id: 354 */
                int32_t *l_565 = &g_82[6];
                (*l_565) = ((1U < 0) < 0);
            }
        }
    }
    /* facts after branching */
    assert (g_15 == &g_8 || g_15 == 0);
    assert (g_482 == &g_6 || (g_482 >= &g_82[0] && g_482 <= &g_82[8]));
    return (*l_54);
    /* statement id: 359 */
    //assert (func_35_rv == &g_8 || func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_482
 */
static int16_t  func_47(int32_t *** p_48, int32_t  p_49)
{ /* block id: 314 */
    int32_t *l_535 = &g_82[6];
    int32_t **l_536 = &g_482;
    (*l_536) = l_535;
    /* statement id: 315 */
    assert ((g_482 >= &g_82[0] && g_482 <= &g_82[8]));
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** func_50(int32_t ** p_51, uint32_t  p_52, int32_t *** p_53)
{ /* block id: 310 */
    int32_t *l_532 = (void*)0;
    int32_t l_533 = 0;
    int32_t ***l_534 = (void*)0;
    l_532 = l_532;
    l_533 = l_533;
    return l_534;
    /* statement id: 313 */
    //assert (func_50_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_157 g_158
 * writes:
 */
static uint16_t  func_57(int32_t  p_58, uint32_t  p_59)
{ /* block id: 307 */
    uint32_t l_527 = 0x46A8C86F;
    int32_t ***l_528 = &g_14[2][4];
    int32_t *****l_529 = &g_157;
    int32_t l_530 = 5;
    uint16_t l_531 = 0x3956;
    l_530 = ((safe_rshift_func_uint16_t_u_u(l_527, 0)) > (((*g_157) != l_528) <= (l_529 == (void*)0)));
    return l_531;
}


/* ------------------------------------------ */
/* 
 * reads : g_71 g_308
 * writes: g_71
 */
static uint32_t  func_64(int16_t  p_65, struct S1  p_66, int32_t * p_67, int32_t ** const  p_68, int32_t * p_69)
{ /* block id: 20 */
    struct S1 *l_72 = &g_71;
    int32_t l_73 = 7;
    int32_t *l_79 = &g_6;
    uint32_t l_130 = 0xB2834994;
    int16_t l_176 = 0x98DF;
    int32_t l_184 = (-5);
    int32_t ***** const l_203[3] = {&g_157, &g_157, &g_157};
    int32_t *l_210 = &g_6;
    int32_t *l_214 = &g_82[2];
    int32_t *l_276 = (void*)0;
    int32_t *****l_404 = &g_157;
    uint8_t l_457 = 0xFD;
    int16_t l_469 = 3;
    int16_t l_470 = 1;
    uint32_t l_491 = 0xDED5D887;
    int32_t ****l_505 = &g_158;
    int i;
    (*l_72) = g_71;
    return g_308;
}




/* ---------------------------------------- */
int main (void)
{
    int i, j, k;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 7; j++)
        {
            transparent_crc(g_2[i][j], "g_2[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_71.f0, "g_71.f0", print_hash_value);
    transparent_crc(g_71.f1, "g_71.f1", print_hash_value);
    transparent_crc(g_71.f2, "g_71.f2", print_hash_value);
    transparent_crc(g_71.f3, "g_71.f3", print_hash_value);
    for (i = 0; i < 9; i++)
    {
        transparent_crc(g_82[i], "g_82[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_104, "g_104", print_hash_value);
    transparent_crc(g_183, "g_183", print_hash_value);
    transparent_crc(g_208, "g_208", print_hash_value);
    transparent_crc(g_308, "g_308", print_hash_value);
    transparent_crc(g_523, "g_523", print_hash_value);
    transparent_crc(g_598, "g_598", print_hash_value);
    transparent_crc(g_626.f0, "g_626.f0", print_hash_value);
    transparent_crc(g_626.f1, "g_626.f1", print_hash_value);
    transparent_crc(g_626.f2, "g_626.f2", print_hash_value);
    transparent_crc(g_626.f3, "g_626.f3", print_hash_value);
    transparent_crc(g_789, "g_789", print_hash_value);
    transparent_crc(g_901, "g_901", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 253
   depth: 1, occurrence: 24
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 119
   depth: 2, occurrence: 31
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 11, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 190

XXX times a variable address is taken: 379
XXX times a pointer is dereferenced on RHS: 156
breakdown:
   depth: 1, occurrence: 142
   depth: 2, occurrence: 10
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 127
breakdown:
   depth: 1, occurrence: 121
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 49
XXX times a pointer is compared with address of another variable: 25
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 2405

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 557
   level: 2, occurrence: 187
   level: 3, occurrence: 151
   level: 4, occurrence: 101
   level: 5, occurrence: 39
XXX number of pointers point to pointers: 98
XXX number of pointers point to scalars: 78
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 34.7
XXX average alias set size: 1.6

XXX times a non-volatile is read: 1153
XXX times a non-volatile is write: 454
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 13

XXX stmts: 112
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 17
   depth: 2, occurrence: 20
   depth: 3, occurrence: 26
   depth: 4, occurrence: 17
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 14.6
XXX percentage an existing variable is used: 85.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

