/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --no-bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --jumps --longlong --force-non-uniform-arrays --no-math64 --muls --packed-struct --paranoid --pointers --no-structs --inline-function --no-return-structs --arg-structs --dangling-global-pointers
 * Seed:      844905513265777869
 */

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0xFE0A8EACL;
static int32_t g_6 = 0xFE77DD68L;
static int32_t g_28 = 1L;
static int32_t g_55 = (-5L);
static int32_t g_100 = 1L;
static int32_t *g_99 = &g_100;
static int32_t ****g_131 = (void*)0;
static int32_t *****g_142 = &g_131;
static int32_t **g_145 = &g_99;
static int32_t ***g_144 = &g_145;
static int32_t ****g_143 = &g_144;
static uint16_t g_466 = 0x8343L;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static uint8_t  func_11(uint32_t  p_12, int32_t * p_13, int32_t * p_14, const uint32_t  p_15);
static int32_t * func_16(uint32_t  p_17, uint8_t  p_18, int32_t * p_19);
static int32_t * func_23(int32_t  p_24, uint8_t  p_25);
inline static int32_t  func_32(int32_t * p_33, int32_t * p_34, int8_t  p_35, int8_t  p_36);
inline static uint8_t  func_45(int32_t * p_46, uint32_t  p_47, int16_t  p_48, int32_t * p_49);
static int32_t  func_52(int32_t * p_53);
inline static int32_t  func_58(uint32_t  p_59);
inline static int32_t * func_60(uint32_t  p_61, int32_t * p_62, int32_t * p_63, int32_t * p_64);
static int32_t * func_68(int32_t * const  p_69, int32_t * const  p_70, int32_t * p_71, uint32_t  p_72);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_6 g_144 g_145 g_99 g_28 g_143 g_100 g_55 g_466
 * writes: g_2 g_6 g_28 g_100 g_99 g_142
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_21 = &g_6;
    int32_t * const l_22 = &g_6;
    int32_t *l_26 = &g_6;
    const int16_t l_434 = (-7L);
    int32_t ****l_464 = (void*)0;
    int32_t *l_465 = &g_2;
    for (g_2 = 25; (g_2 <= (-17)); --g_2)
    { /* block id: 3 */
        int32_t *l_5 = &g_6;
        (*l_5) = (-1L);
    }
    if ((safe_rshift_func_uint16_t_u_u((safe_mul_func_uint8_t_u_u(func_11(g_2, func_16((g_6 > (+(l_21 != l_22))), (l_21 != l_22), func_23(g_6, (((((void*)0 != l_26) != (*l_21)) != 0xF7D2L) != g_2))), (**g_144), l_434), g_100)), g_100)))
    { /* block id: 215 */
        int32_t ****l_438 = &g_144;
        (***g_144) = ((void*)0 != l_438);
        (***g_143) = (***g_143);
    }
    else
    { /* block id: 218 */
        int32_t *l_439 = &g_100;
        (**g_144) = func_60(g_6, l_439, (*g_145), l_26);
        /* statement id: 219 */
        assert (g_142 == 0);
    }
    /* facts after branching */
    assert (g_142 == 0 || g_142 == &g_131);
    (*g_145) = func_60((safe_sub_func_int16_t_s_s((safe_lshift_func_int8_t_s_s(((!((g_100 && (2L || ((safe_add_func_uint8_t_u_u((safe_mul_func_int8_t_s_s((safe_add_func_int16_t_s_s(((((safe_add_func_int8_t_s_s(g_6, (safe_rshift_func_uint8_t_u_u((safe_mod_func_uint16_t_u_u((*l_22), (safe_add_func_int32_t_s_s((safe_add_func_uint16_t_u_u((safe_unary_minus_func_uint16_t_u((safe_add_func_uint8_t_u_u(((*l_22) <= ((void*)0 == l_464)), g_55)))), ((*l_21) < g_28))), (**g_145))))), (*l_22))))) < (*l_26)) & 0xC4B7L) || 0xABL), (*l_26))), g_55)), g_28)) || (*l_26)))) >= (*l_22))) >= g_6), g_100)), g_28)), (**g_144), l_21, l_465);
    /* statement id: 221 */
    assert (g_142 == 0);
    (***g_143) = (**g_144);
    return g_466;
}


/* ------------------------------------------ */
/* 
 * reads : g_28 g_143 g_144 g_145 g_99 g_100
 * writes: g_28
 */
static uint8_t  func_11(uint32_t  p_12, int32_t * p_13, int32_t * p_14, const uint32_t  p_15)
{ /* block id: 207 */
    for (g_28 = 0; (g_28 > (-10)); g_28 = safe_sub_func_uint16_t_u_u(g_28, 3))
    { /* block id: 210 */
        int8_t l_437 = (-7L);
        if ((****g_143))
            break;
        if (l_437)
            continue;
    }
    return p_12;
}


/* ------------------------------------------ */
/* 
 * reads : g_6
 * writes: g_6 g_28
 */
static int32_t * func_16(uint32_t  p_17, uint8_t  p_18, int32_t * p_19)
{ /* block id: 10 */
    int16_t l_50 = 0x6B78L;
    int32_t *l_51 = &g_2;
    for (g_6 = (-2); (g_6 != 25); g_6 = safe_add_func_int32_t_s_s(g_6, 3))
    { /* block id: 13 */
        int32_t *l_31 = &g_6;
        (*p_19) = (l_31 == &g_28);
    }
    return l_51;
    /* statement id: 206 */
    //assert (func_16_rv == &g_2);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_28
 */
static int32_t * func_23(int32_t  p_24, uint8_t  p_25)
{ /* block id: 6 */
    int32_t *l_27 = &g_28;
    (*l_27) = p_24;
    (*l_27) = 1L;
    return l_27;
    /* statement id: 9 */
    //assert (func_23_rv == &g_28);
}


/* ------------------------------------------ */
/* 
 * reads : g_28 g_142 g_131 g_143 g_144 g_2 g_100 g_145 g_99
 * writes: g_28 g_100 g_99
 */
inline static int32_t  func_32(int32_t * p_33, int32_t * p_34, int8_t  p_35, int8_t  p_36)
{ /* block id: 128 */
    int32_t l_241 = 0xE1DA1D93L;
    int16_t l_243 = 0xE76CL;
    uint16_t l_244 = 0x2401L;
    int32_t *****l_255 = &g_143;
    if ((safe_add_func_uint16_t_u_u((g_28 > ((p_35 <= (safe_sub_func_uint8_t_u_u(((void*)0 != (*g_142)), (safe_mod_func_int32_t_s_s(((!l_241) >= (p_36 ^ ((+((*g_143) != (*g_143))) > l_243))), l_244))))) >= g_2)), l_241)))
    { /* block id: 129 */
        uint16_t l_245 = 0x5DECL;
        (*p_34) = l_245;
        (*p_33) = l_243;
    }
    else
    { /* block id: 132 */
        int32_t *****l_254 = &g_143;
        uint8_t l_364 = 0xB8L;
    }
    for (l_243 = (-14); (l_243 > 29); l_243 = safe_add_func_uint8_t_u_u(l_243, 9))
    { /* block id: 193 */
        uint32_t l_433 = 4294967295UL;
        for (g_100 = (-30); (g_100 >= 22); ++g_100)
        { /* block id: 196 */
            (***g_143) = p_33;
            /* statement id: 197 */
            assert (g_99 == &g_28);
        }
        /* facts after for loop */
        assert (g_99 == &g_28 || g_99 == &g_100);
        return l_433;
    }
    (*p_33) = (***g_144);
    (*g_145) = (***g_143);
    return (****g_143);
}


/* ------------------------------------------ */
/* 
 * reads : g_55 g_143 g_144 g_145 g_99 g_28 g_100 g_2 g_6
 * writes: g_55 g_100
 */
inline static uint8_t  func_45(int32_t * p_46, uint32_t  p_47, int16_t  p_48, int32_t * p_49)
{ /* block id: 15 */
    int32_t *l_54 = &g_28;
    if (func_52(l_54))
    { /* block id: 120 */
        (****g_143) = (((void*)0 == p_46) <= ((safe_lshift_func_int16_t_s_s(((*l_54) && ((p_47 < (safe_mul_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((&g_131 == (void*)0), 11)), ((*l_54) || (safe_add_func_uint32_t_u_u(0x1DCC64ACL, (p_48 == (**g_145)))))))) != p_47)), p_47)) == g_100));
        (***g_144) = (*p_49);
    }
    else
    { /* block id: 123 */
        int32_t l_222 = 0x5E883FB5L;
        int32_t *l_233 = &g_55;
        (*g_99) = ((((((safe_rshift_func_uint16_t_u_s(0xEB04L, g_6)) <= l_222) || (safe_mul_func_int8_t_s_s((safe_mul_func_int16_t_s_s((safe_add_func_int8_t_s_s(((safe_mul_func_uint8_t_u_u(g_2, p_48)) != (&g_143 == &g_131)), ((safe_sub_func_uint8_t_u_u(((*g_144) == &p_46), 0x65L)) & 0x4BBE8292L))), p_47)), p_48))) > 0xE8L) != (*l_54)) > 0x55L);
        l_233 = (void*)0;
        /* statement id: 125 */
        assert (l_233 == 0);
    }
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads : g_55 g_143 g_144 g_145 g_99 g_28
 * writes: g_55 g_100
 */
static int32_t  func_52(int32_t * p_53)
{ /* block id: 16 */
    const int32_t *l_162 = (void*)0;
    const int32_t **l_161 = &l_162;
    const int32_t ***l_160 = &l_161;
    const int32_t ****l_159 = &l_160;
    int32_t *l_175 = (void*)0;
    uint16_t l_205 = 0x5AE7L;
    uint32_t l_206 = 18446744073709551615UL;
    for (g_55 = (-8); (g_55 != (-6)); ++g_55)
    { /* block id: 19 */
        int8_t l_164 = (-3L);
        int32_t l_165 = 0L;
        int8_t l_172 = 0xCFL;
        uint32_t l_192 = 8UL;
        int32_t l_199 = 0xFFEE22BCL;
        int32_t *l_201 = &l_199;
    }
    (****g_143) = (!0xF101BA2FL);
    (**l_160) = (***g_143);
    /* statement id: 118 */
    assert (l_162 == &g_100);
    return (*p_53);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_55 g_28 g_6 g_99 g_100 g_131 g_143 g_145
 * writes: g_99 g_142 g_100
 */
inline static int32_t  func_58(uint32_t  p_59)
{ /* block id: 20 */
    const int16_t l_65 = (-4L);
    int32_t *l_67 = &g_55;
    int32_t **l_154 = (void*)0;
    l_67 = func_60((l_65 & (safe_unary_minus_func_int32_t_s(((void*)0 != l_67)))), &g_55, func_68(&g_55, l_67, l_67, (safe_add_func_uint32_t_u_u(g_2, g_2))), &g_2);
    /* statement id: 63 */
    assert (l_67 == &g_100);
    //assert (g_99 == &g_6 || g_99 == &g_2 || g_99 == dangling || g_99 == &g_100 || g_99 == &g_55 || g_99 == &g_28);
    assert (g_142 == 0);
    (*l_67) = (safe_sub_func_int32_t_s_s((p_59 != ((&l_67 == l_154) || ((*l_67) < (safe_lshift_func_int16_t_s_u(((!p_59) > ((*l_67) || (l_67 != l_67))), 12))))), (((+(l_67 == l_67)) != p_59) <= p_59)));
    (*g_145) = l_67;
    return (*l_67);
}


/* ------------------------------------------ */
/* 
 * reads : g_143
 * writes: g_142 g_100
 */
inline static int32_t * func_60(uint32_t  p_61, int32_t * p_62, int32_t * p_63, int32_t * p_64)
{ /* block id: 59 */
    int32_t * const *l_148 = &g_99;
    int32_t * const **l_147 = &l_148;
    int32_t * const ***l_146 = &l_147;
    int32_t *l_149 = &g_100;
    g_142 = (void*)0;
    /* statement id: 60 */
    assert (g_142 == 0);
    (*l_149) = (g_143 == l_146);
    return l_149;
    /* statement id: 62 */
    //assert (func_60_rv == &g_100);
}


/* ------------------------------------------ */
/* 
 * reads : g_55 g_28 g_2 g_6 g_99 g_100 g_131
 * writes: g_99
 */
static int32_t * func_68(int32_t * const  p_69, int32_t * const  p_70, int32_t * p_71, uint32_t  p_72)
{ /* block id: 21 */
    uint32_t l_77 = 0x89D0E131L;
    int32_t l_97 = 0L;
    int32_t *l_122 = &g_100;
    for (p_72 = 0; (p_72 <= 50); ++p_72)
    { /* block id: 24 */
        int32_t **l_115 = &g_99;
        int32_t l_141 = (-2L);
        if (l_77)
            break;
        if ((*p_71))
        { /* block id: 26 */
            int32_t l_98 = 3L;
            int32_t *l_102 = (void*)0;
            int32_t ** const *l_120 = &l_115;
            if (((safe_sub_func_uint32_t_u_u(p_72, (safe_rshift_func_uint16_t_u_s((safe_sub_func_int8_t_s_s((safe_rshift_func_uint16_t_u_u(((*p_69) && 2UL), (0x7DC0L != (((((safe_lshift_func_uint16_t_u_u(((!0x5115L) > (safe_add_func_int16_t_s_s(1L, (((safe_lshift_func_uint8_t_u_u((((!p_72) < (g_55 & (!(safe_rshift_func_int8_t_s_s(((p_70 != &g_28) == l_77), 6))))) || l_97), 7)) ^ 0xBA70L) && 3L)))), g_28)) <= l_98) > 0xB42EL) == g_28) != g_2)))), 1L)), g_28)))) ^ g_2))
            { /* block id: 27 */
                int32_t **l_101 = (void*)0;
                g_99 = &g_6;
                /* statement id: 28 */
                assert (g_99 == &g_6);
                l_102 = &g_6;
                /* statement id: 29 */
                assert (l_102 == &g_6);
                return p_71;
                /* statement id: 30 */
                //assert (func_68_rv == &g_55 || func_68_rv == &g_28);
            }
            else
            { /* block id: 31 */
                int32_t l_135 = (-10L);
                if ((safe_lshift_func_uint16_t_u_s((((safe_sub_func_int16_t_s_s(((0x045C746EL != (safe_sub_func_uint32_t_u_u((((void*)0 != &p_70) == (((safe_rshift_func_uint8_t_u_u(((safe_sub_func_int16_t_s_s((&g_99 != &p_70), (safe_rshift_func_int16_t_s_s((&g_99 != l_115), 13)))) >= ((safe_lshift_func_int8_t_s_u(p_72, 0)) & 0x9C31L)), g_55)) ^ (*p_70)) <= g_6)), (*g_99)))) < (-1L)), g_100)) && 1UL) & (-10L)), (**l_115))))
                { /* block id: 32 */
                    (*l_115) = p_71;
                    /* statement id: 33 */
                    assert (g_99 == &g_55 || g_99 == &g_28);
                }
                else
                { /* block id: 34 */
                    for (l_98 = (-15); (l_98 > 23); l_98++)
                    { /* block id: 37 */
                        int32_t ** const **l_121 = &l_120;
                        (*l_115) = &l_97;
                        /* statement id: 38 */
                        assert (g_99 == &l_97);
                        (**l_115) = (*p_71);
                        (*g_99) = (*p_69);
                        (*l_121) = l_120;
                    }
                    l_122 = &g_28;
                    /* statement id: 43 */
                    assert (l_122 == &g_28);
                    if ((*p_71))
                        break;
                }
                (*l_115) = (**l_120);
                l_97 = (safe_sub_func_int8_t_s_s((safe_sub_func_int16_t_s_s(((safe_mod_func_int8_t_s_s((safe_mul_func_uint16_t_u_u(p_72, (((g_131 != g_131) && (0xA9C08A91L >= ((*g_99) >= (+0x6508L)))) <= (safe_sub_func_uint32_t_u_u(l_135, ((safe_mod_func_uint32_t_u_u((safe_unary_minus_func_uint32_t_u(((((void*)0 != &g_99) && g_6) > g_2))), 1L)) != (-7L))))))), 255UL)) || p_72), g_28)), g_28));
            }
            if ((*g_99))
                break;
            (*l_115) = (*l_115);
        }
        else
        { /* block id: 51 */
            int32_t * const l_139 = &g_2;
            int32_t **l_140 = &g_99;
            (*l_115) = p_70;
            /* statement id: 52 */
            assert (g_99 == &g_55 || g_99 == &g_100);
            (*l_140) = l_139;
            /* statement id: 53 */
            assert (g_99 == &g_2);
            if ((*g_99))
                continue;
        }
        l_141 = (((*l_115) != (void*)0) != g_2);
    }
    /* facts after for loop */
    assert (g_99 == &g_2 || g_99 == &l_97 || g_99 == &g_100 || g_99 == &g_55 || g_99 == &g_28);
    assert (l_122 == &g_28 || l_122 == &g_100);
    return p_71;
    /* statement id: 58 */
    //assert (g_99 == &g_2 || g_99 == dangling || g_99 == &g_100 || g_99 == &g_55 || g_99 == &g_28);
    //assert (func_68_rv == &g_55 || func_68_rv == &g_28);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_2;
    csmith_sink_ = g_6;
    csmith_sink_ = g_28;
    csmith_sink_ = g_55;
    csmith_sink_ = g_100;
    csmith_sink_ = g_466;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 77
XXX total union variables: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
   depth: 5, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 73

XXX times a variable address is taken: 73
XXX times a pointer is dereferenced on RHS: 120
breakdown:
   depth: 1, occurrence: 58
   depth: 2, occurrence: 20
   depth: 3, occurrence: 17
   depth: 4, occurrence: 10
   depth: 5, occurrence: 15
XXX times a pointer is dereferenced on LHS: 66
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 13
   depth: 3, occurrence: 12
   depth: 4, occurrence: 5
   depth: 5, occurrence: 3
XXX times a pointer is compared with null: 25
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 354

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 239
   level: 2, occurrence: 60
   level: 3, occurrence: 43
   level: 4, occurrence: 33
   level: 5, occurrence: 28
XXX number of pointers point to pointers: 32
XXX number of pointers point to scalars: 41
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 16.4
XXX average alias set size: 1.34

XXX times a non-volatile is read: 666
XXX times a non-volatile is write: 225
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 71
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 18
   depth: 2, occurrence: 7
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 15.1
XXX percentage an existing variable is used: 84.9
********************* end of statistics **********************/

