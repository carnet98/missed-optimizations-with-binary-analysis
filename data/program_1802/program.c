/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --no-bitfields --checksum --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-jumps --longlong --no-force-non-uniform-arrays --no-math64 --muls --no-packed-struct --paranoid --pointers --structs --inline-function --return-structs --arg-structs --dangling-global-pointers
 * Seed:      16224885048979297175
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
};

struct S1 {
   const struct S0  f0;
};

struct S2 {
   struct S0  f0;
   struct S1  f1;
   int32_t  f2;
   struct S0  f3;
   uint32_t  f4;
   int32_t  f5;
   int16_t  f6;
   uint32_t  f7;
   struct S0  f8;
   int32_t  f9;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0xAFD94FE5L;
static int32_t g_9 = (-6L);
static int32_t g_24 = 0xEA311C3FL;
static int32_t *g_33 = &g_9;
static int32_t **g_32 = &g_33;
static int32_t *g_94 = &g_24;
static int32_t g_98 = 8L;
static int32_t ** const *g_108 = &g_32;
static int32_t ** const **g_107 = &g_108;
static struct S0 g_137 = {0L};
static struct S1 g_161 = {{0x0384L}};
static struct S1 *g_160 = &g_161;
static struct S2 g_179 = {{0x2717L},{{0x9B2EL}},0xBA896EA0L,{0L},0x4CD9E10DL,-2L,0x4C28L,1UL,{4L},0x5D562BBFL};
static struct S2 g_231 = {{0xF980L},{{0x7AD1L}},5L,{0L},0x012BAB1EL,0xDD07A39AL,6L,0UL,{0x22F9L},1L};
static struct S0 *g_301 = &g_179.f8;
static struct S0 **g_300 = &g_301;
static const int32_t ****g_352 = (void*)0;
static const int32_t *****g_483 = &g_352;


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_1(void);
inline static struct S0  func_5(uint8_t  p_6);
static int32_t * func_13(int32_t * p_14, uint32_t  p_15, uint8_t  p_16);
static int8_t  func_27(int32_t ** const  p_28, int32_t ** p_29);
inline static int32_t * func_39(const int8_t  p_40);
static int32_t * func_42(const int32_t * p_43, uint32_t  p_44, int32_t ** p_45);
inline static int32_t  func_51(struct S2  p_52, uint32_t  p_53, int32_t  p_54);
static struct S2  func_55(uint32_t  p_56, struct S2  p_57, int32_t ** p_58, struct S1  p_59, const uint32_t  p_60);
static int32_t *** func_64(int32_t * p_65);
inline static uint32_t  func_69(int32_t  p_70, int32_t ** const  p_71, int8_t  p_72, int32_t  p_73, const int32_t  p_74);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2
 * writes: g_2
 */
inline static uint32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_515 = 65535UL;
    int32_t l_516 = 0L;
    for (g_2 = 0; (g_2 > 17); ++g_2)
    { /* block id: 3 */
        struct S0 l_506 = {0xD5A2L};
        int32_t ****l_514 = (void*)0;
        int32_t *****l_513 = &l_514;
        struct S0 ***l_517 = &g_300;
        if (g_2)
            break;
    }
    return l_516;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_24 g_179.f7 g_179.f3 g_108 g_32 g_107 g_33 g_231.f2 g_231.f0.f0 g_179.f5 g_231.f5 g_179.f4 g_161.f0.f0 g_300 g_179.f2 g_231.f1.f0.f0 g_179.f6 g_179.f9 g_179.f0.f0 g_137.f0 g_2 g_94 g_98 g_231.f8.f0 g_301 g_231.f9 g_231.f7 g_179.f8 g_137 g_179.f1.f0.f0
 * writes: g_9 g_24 g_179.f3 g_231.f0.f0 g_33 g_137.f0 g_94 g_98 g_107 g_352 g_179.f4 g_179.f0.f0 g_231.f2 g_179.f8 g_231.f8 g_160 g_483 g_301
 */
inline static struct S0  func_5(uint8_t  p_6)
{ /* block id: 5 */
    uint8_t l_189 = 3UL;
    struct S2 *l_246 = &g_231;
    struct S2 **l_245 = &l_246;
    const int32_t *l_248 = &g_231.f2;
    int16_t l_249 = 2L;
    uint16_t l_266 = 0UL;
    struct S1 *l_271 = (void*)0;
    int32_t ***l_275 = &g_32;
    int32_t ****l_274 = &l_275;
    int32_t *****l_273 = &l_274;
    struct S0 l_432 = {0L};
    for (p_6 = 0; (p_6 == 33); p_6 = safe_add_func_uint8_t_u_u(p_6, 1))
    { /* block id: 8 */
        uint16_t l_18 = 0UL;
        int32_t *l_31 = &g_24;
        int32_t ** const l_30 = &l_31;
        int32_t ****l_208 = (void*)0;
        struct S2 *l_229 = (void*)0;
        for (g_9 = 0; (g_9 < (-8)); --g_9)
        { /* block id: 11 */
            int16_t l_12 = 0xAD9DL;
            int32_t *l_17 = (void*)0;
            int32_t **l_25 = (void*)0;
            int32_t **l_26 = &l_17;
            int32_t *l_190 = &g_179.f2;
            const int32_t *l_207 = &g_98;
            const int32_t **l_206 = &l_207;
            const int32_t ***l_205 = &l_206;
            const int32_t ****l_204 = &l_205;
            struct S2 **l_209 = (void*)0;
            struct S0 l_210 = {0x54BDL};
            l_12 = 0xDDA37BB0L;
            (*l_26) = func_13(l_17, l_18, p_6);
        }
        if ((**l_30))
            break;
        if ((safe_add_func_int8_t_s_s((safe_sub_func_int8_t_s_s(p_6, g_179.f7)), p_6)))
        { /* block id: 100 */
            struct S2 *l_230 = &g_231;
            g_179.f3 = g_179.f3;
            l_230 = l_229;
            /* statement id: 102 */
            assert (l_230 == 0);
        }
        else
        { /* block id: 103 */
            (***g_108) = (safe_sub_func_uint16_t_u_u(((p_6 == ((safe_div_func_int16_t_s_s((safe_add_func_int32_t_s_s(0xBF4C0AB2L, (safe_div_func_uint16_t_u_u(((((void*)0 != &g_179) > ((safe_rshift_func_uint8_t_u_u(p_6, 6)) | (+(safe_div_func_uint16_t_u_u((l_245 != (void*)0), (safe_unary_minus_func_int16_t_s((&l_31 == (*g_108))))))))) > (****g_107)), g_231.f2)))), p_6)) > g_231.f2)) & 0xF6E7C4BEL), 1L));
            (*l_245) = (void*)0;
            /* statement id: 105 */
            assert (l_246 == 0);
        }
    }
    /* facts after for loop */
    assert (l_246 == 0 || l_246 == &g_231);
    l_248 = (void*)0;
    /* statement id: 108 */
    assert (l_248 == 0);
    if (l_249)
    { /* block id: 109 */
        struct S0 *l_280 = (void*)0;
        struct S0 **l_279 = &l_280;
        int32_t ****l_314 = &l_275;
        const int32_t ***l_351 = (void*)0;
        const int32_t ****l_350 = &l_351;
        uint32_t l_396 = 0xA74AEDCEL;
        for (g_231.f0.f0 = (-13); (g_231.f0.f0 > (-7)); g_231.f0.f0 = safe_add_func_uint8_t_u_u(g_231.f0.f0, 3))
        { /* block id: 112 */
            uint32_t l_265 = 0x479EB29DL;
            int32_t *l_268 = &g_24;
            const struct S1 * const l_272 = &g_231.f1;
            for (l_249 = (-25); (l_249 <= 6); l_249++)
            { /* block id: 115 */
                struct S0 l_267 = {0x2525L};
                (***g_108) = ((!g_179.f5) & (safe_sub_func_uint8_t_u_u(((safe_mod_func_int32_t_s_s(((((p_6 != ((65534UL < 65535UL) <= ((safe_lshift_func_uint8_t_u_u((g_231.f5 && g_179.f4), 2)) | ((&l_248 != (void*)0) & (safe_mod_func_int32_t_s_s(((safe_sub_func_uint32_t_u_u((l_265 > 0x22973494L), 0L)) || 0x59F9L), l_266)))))) > p_6) < p_6) | 0x378D5E2CL), 0xF1E348D7L)) && p_6), (-9L))));
                return l_267;
            }
            l_268 = l_268;
            (***g_108) = ((safe_lshift_func_int16_t_s_s(((l_271 != l_272) || (p_6 || ((void*)0 != l_273))), (safe_mod_func_int8_t_s_s(p_6, (~(l_279 != (void*)0)))))) || (safe_sub_func_uint8_t_u_u((0x9D5BA957L & (-1L)), (***l_275))));
            for (l_265 = 0; (l_265 != 44); l_265++)
            { /* block id: 123 */
                int32_t * const *l_291 = &g_33;
                int32_t *****l_329 = &l_314;
                if ((65532UL | (safe_lshift_func_uint8_t_u_u(g_179.f3.f0, (((safe_mod_func_int16_t_s_s((~0x20L), (~p_6))) | (p_6 & ((*g_108) == l_291))) >= p_6)))))
                { /* block id: 124 */
                    uint32_t l_309 = 18446744073709551615UL;
                    (***g_108) = (safe_add_func_int16_t_s_s((+0x0871CD10L), g_161.f0.f0));
                    for (g_179.f3.f0 = (-25); (g_179.f3.f0 >= 6); g_179.f3.f0 = safe_add_func_int16_t_s_s(g_179.f3.f0, 1))
                    { /* block id: 128 */
                        (*****l_273) = (p_6 > 0x46L);
                        (****l_274) = ((p_6 >= (0x48L > ((~g_9) >= ((safe_lshift_func_uint8_t_u_u((g_300 != (void*)0), g_179.f2)) == g_231.f1.f0.f0)))) == (!(safe_sub_func_int32_t_s_s((safe_rshift_func_uint8_t_u_s(p_6, 2)), (safe_mul_func_int8_t_s_s((0x81AEL || p_6), l_309))))));
                    }
                }
                else
                { /* block id: 132 */
                    int32_t ****l_313 = &l_275;
                    for (g_24 = 0; (g_24 > (-11)); g_24 = safe_sub_func_int16_t_s_s(g_24, 1))
                    { /* block id: 135 */
                        if (p_6)
                            break;
                    }
                    (***l_275) = (!(l_313 != l_314));
                    if ((g_179.f6 && ((****l_314) == ((safe_add_func_uint32_t_u_u((safe_lshift_func_int8_t_s_u(p_6, (((safe_sub_func_int16_t_s_s((safe_add_func_int8_t_s_s(p_6, ((void*)0 == (*l_314)))), (safe_add_func_uint16_t_u_u((((safe_lshift_func_uint16_t_u_s((safe_div_func_int8_t_s_s((((void*)0 == l_329) ^ g_161.f0.f0), 0xD9L)), 3)) > p_6) ^ (****g_107)), 0x7D22L)))) >= (***g_108)) ^ 248UL))), 0x86FDC5E2L)) & g_179.f9))))
                    { /* block id: 139 */
                        struct S0 l_330 = {0x9A20L};
                        return l_330;
                    }
                    else
                    { /* block id: 141 */
                        (**l_291) = (***g_108);
                        if (p_6)
                            break;
                    }
                }
                (**g_108) = (***l_314);
            }
        }
        if (((safe_mod_func_int16_t_s_s(((((0x14EA6A5FL || (((safe_add_func_uint32_t_u_u(((((*g_108) != (void*)0) < (((~(p_6 ^ ((safe_add_func_int8_t_s_s((safe_div_func_int32_t_s_s((l_314 == &g_108), 0x2C5EE9ACL)), (safe_sub_func_int16_t_s_s((safe_add_func_uint8_t_u_u((&g_161 != &g_161), (****l_314))), 0x52C3L)))) <= (****l_314)))) == 0UL) ^ (****l_314))) == p_6), (*****l_273))) >= g_179.f0.f0) && g_179.f0.f0)) == p_6) ^ g_24) == p_6), (***l_275))) >= p_6))
        { /* block id: 149 */
            const uint8_t l_348 = 248UL;
            for (g_137.f0 = (-4); (g_137.f0 != (-19)); g_137.f0 = safe_sub_func_uint32_t_u_u(g_137.f0, 5))
            { /* block id: 152 */
                (***l_274) = func_39((safe_sub_func_uint16_t_u_u(((*****l_273) && 1UL), (0xB10661FEL > (****l_314)))));
                if (l_348)
                    break;
            }
            /* facts after for loop */
            assert (g_94 == &g_24 || g_94 == &g_9);
            //assert (g_107 == &g_108 || g_107 == dangling);
        }
        else
        { /* block id: 156 */
            struct S0 l_349 = {9L};
            return l_349;
        }
        /* facts after branching */
        assert (g_94 == &g_24 || g_94 == &g_9);
        //assert (g_107 == &g_108 || g_107 == dangling);
        if ((0L > (((*l_245) == (*l_245)) == g_9)))
        { /* block id: 159 */
            int32_t **l_353 = &g_94;
            struct S1 *l_397 = &g_179.f1;
            g_352 = l_350;
            /* statement id: 160 */
            assert (g_352 == &l_351);
            if (((void*)0 != l_353))
            { /* block id: 161 */
                (**g_32) = (0xB03343D0L & p_6);
            }
            else
            { /* block id: 163 */
                struct S0 *l_374 = &g_231.f8;
                uint32_t l_395 = 1UL;
                for (g_179.f4 = 0; (g_179.f4 < 21); g_179.f4 = safe_add_func_uint8_t_u_u(g_179.f4, 4))
                { /* block id: 166 */
                    l_273 = &l_274;
                }
                for (g_179.f0.f0 = 16; (g_179.f0.f0 >= 16); --g_179.f0.f0)
                { /* block id: 171 */
                    int16_t l_370 = 1L;
                    struct S1 **l_398 = (void*)0;
                    struct S1 **l_399 = (void*)0;
                    struct S1 **l_400 = &l_397;
                }
                (****l_273) = (***l_274);
            }
            (*g_32) = (*l_353);
            /* statement id: 185 */
            assert (g_33 == &g_24 || g_33 == &g_9);
        }
        else
        { /* block id: 186 */
            struct S2 ***l_401 = &l_245;
            (*l_401) = &l_246;
        }
        /* facts after branching */
        assert (g_33 == &g_24 || g_33 == &g_9);
        assert (g_352 == 0 || g_352 == &l_351);
        (***l_275) = (safe_div_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_s(g_231.f5, 10)) != 6L), (safe_sub_func_uint16_t_u_u(((void*)0 == &l_246), ((safe_div_func_uint16_t_u_u((((safe_div_func_uint8_t_u_u((safe_lshift_func_uint16_t_u_u((g_231.f2 | g_231.f8.f0), 3)), (****l_274))) < p_6) == p_6), (***l_275))) <= g_231.f8.f0)))));
    }
    else
    { /* block id: 190 */
        int32_t *l_416 = &g_231.f2;
        struct S0 *l_420 = &g_137;
        int32_t l_500 = (-10L);
        for (g_179.f4 = 0; (g_179.f4 > 45); ++g_179.f4)
        { /* block id: 193 */
            (**g_32) = 0x98A097C5L;
            l_416 = l_416;
            (*l_416) = 0xC6E5BA76L;
            for (g_179.f3.f0 = (-30); (g_179.f3.f0 < (-19)); g_179.f3.f0++)
            { /* block id: 199 */
                struct S0 l_419 = {0xEFB3L};
                (*g_301) = l_419;
            }
        }
        if (((((-4L) || g_231.f0.f0) >= (((l_420 != (*g_300)) ^ ((safe_mod_func_int32_t_s_s((!1L), (*l_416))) > ((safe_div_func_int16_t_s_s(((!((safe_add_func_uint16_t_u_u(65534UL, ((((void*)0 == l_271) && (-1L)) >= 0x63762D14L))) != p_6)) & 0x4F2DL), g_24)) > 0x7DAFL))) < 0xE4821012L)) | p_6))
        { /* block id: 203 */
            struct S0 l_431 = {0L};
            int32_t l_436 = 0x2BF633B1L;
            struct S0 *l_437 = &g_231.f8;
            struct S1 **l_467 = &g_160;
            for (g_137.f0 = 0; (g_137.f0 >= (-21)); g_137.f0 = safe_sub_func_uint32_t_u_u(g_137.f0, 7))
            { /* block id: 206 */
                int32_t l_433 = 0xD84E146BL;
                struct S0 l_465 = {0x2241L};
                (**g_300) = l_431;
                (**g_300) = l_432;
                if (p_6)
                    break;
                if ((****g_107))
                { /* block id: 210 */
                    uint16_t l_434 = 0xF5DFL;
                    int32_t *l_463 = &g_2;
                    if (l_433)
                    { /* block id: 211 */
                        struct S1 **l_435 = &l_271;
                        (**l_275) = (void*)0;
                        /* statement id: 212 */
                        assert (g_33 == 0);
                        (*l_416) = l_434;
                        (*l_435) = &g_161;
                        /* statement id: 214 */
                        assert (l_271 == &g_161);
                        l_436 = l_431.f0;
                    }
                    else
                    { /* block id: 216 */
                        (***l_274) = &l_436;
                        /* statement id: 217 */
                        assert (g_33 == &l_436);
                        (****l_273) = &l_436;
                        l_437 = (*g_300);
                        /* statement id: 219 */
                        assert (l_437 == &g_179.f8);
                        if ((*l_416))
                            continue;
                    }
                    /* facts after branching */
                    assert (g_33 == &l_436 || g_33 == 0);
                    if ((safe_mul_func_int8_t_s_s((safe_rshift_func_uint8_t_u_s((safe_sub_func_uint16_t_u_u(((safe_lshift_func_uint8_t_u_s((p_6 & (((safe_add_func_uint8_t_u_u((safe_rshift_func_int16_t_s_s(((-2L) && 4294967294UL), 10)), (g_2 || g_179.f3.f0))) == (safe_rshift_func_int16_t_s_s(0x461EL, 13))) && (((safe_mod_func_int8_t_s_s(g_231.f9, (safe_mul_func_uint8_t_u_u(((safe_add_func_uint32_t_u_u((!0xC1580B87L), ((safe_div_func_uint8_t_u_u((safe_add_func_int16_t_s_s((0L ^ (*g_94)), p_6)), g_231.f2)) ^ g_179.f4))) | 1L), p_6)))) || p_6) != (*l_416)))), l_433)) >= p_6), (*l_416))), g_231.f8.f0)), g_231.f7)))
                    { /* block id: 222 */
                        int16_t l_464 = 0xBA33L;
                        (****l_273) = func_13(l_463, l_464, p_6);
                        /* statement id: 223 */
                        assert (g_33 == &g_2);
                        return (*g_301);
                    }
                    else
                    { /* block id: 225 */
                        (**g_108) = l_463;
                        /* statement id: 226 */
                        assert (g_33 == &g_2);
                        if (p_6)
                            continue;
                    }
                    /* facts after branching */
                    assert (g_33 == &g_2);
                    l_465 = (*l_420);
                }
                else
                { /* block id: 230 */
                    struct S0 l_466 = {-2L};
                    (**g_108) = (**l_275);
                    (*l_437) = l_466;
                }
            }
            /* facts after for loop */
            assert (g_33 == &g_2 || g_33 == &l_436 || g_33 == &g_9);
            assert (l_271 == 0 || l_271 == &g_161);
            assert (l_437 == &g_179.f8 || l_437 == &g_231.f8);
            (*l_467) = &g_161;
            (**l_275) = (****l_273);
        }
        else
        { /* block id: 237 */
            struct S1 *l_473 = &g_161;
            int32_t **l_482 = (void*)0;
            int32_t l_490 = 0L;
            (*g_33) = (p_6 ^ (safe_unary_minus_func_uint16_t_u((safe_unary_minus_func_int8_t_s((safe_mod_func_int8_t_s_s((****l_274), g_231.f0.f0)))))));
            if ((0x704FL == p_6))
            { /* block id: 239 */
                struct S0 l_472 = {0x2ABBL};
                struct S1 **l_474 = &l_473;
                (**g_300) = l_472;
                (*l_474) = l_473;
                (**l_275) = l_416;
                /* statement id: 242 */
                assert (g_33 == &g_231.f2);
                g_483 = &g_352;
            }
            else
            { /* block id: 244 */
                int32_t *l_484 = (void*)0;
                int8_t l_499 = 0L;
                (**g_108) = func_42(func_13(l_484, (((safe_mod_func_uint16_t_u_u(((g_231.f2 >= ((-2L) >= (g_179.f5 <= ((safe_mul_func_uint16_t_u_u((+(l_490 > g_179.f9)), (safe_sub_func_int8_t_s_s((0x5BL < (safe_lshift_func_uint16_t_u_s(((g_9 < ((safe_mod_func_uint16_t_u_u(g_2, l_499)) < (***g_108))) ^ p_6), 6))), p_6)))) > g_179.f1.f0.f0)))) != p_6), 0x31DBL)) >= l_500) >= 0xE809L), g_231.f2), p_6, &g_33);
                (**l_275) = (***l_274);
                for (g_231.f2 = (-20); (g_231.f2 == (-27)); --g_231.f2)
                { /* block id: 249 */
                    (*l_245) = &g_179;
                    /* statement id: 250 */
                    assert (l_246 == &g_179);
                }
                /* facts after for loop */
                assert (l_246 == &g_179 || l_246 == 0 || l_246 == &g_231);
            }
            /* facts after branching */
            assert (g_33 == &g_9 || g_33 == &g_231.f2);
            assert (l_246 == &g_179 || l_246 == 0 || l_246 == &g_231);
            (*g_301) = (**g_300);
            (*g_300) = l_420;
            /* statement id: 254 */
            assert (g_301 == &g_137);
        }
        /* facts after branching */
        //assert (g_33 == &g_9 || g_33 == &g_231.f2 || g_33 == &g_2 || g_33 == dangling);
        assert (l_246 == &g_179 || l_246 == 0 || l_246 == &g_231);
        assert (l_271 == 0 || l_271 == &g_161);
        assert (g_301 == &g_137 || g_301 == &g_179.f8);
        return (**g_300);
    }
    /* facts after branching */
    assert (g_33 == &g_24 || g_33 == &g_9);
    assert (g_94 == &g_24 || g_94 == &g_9);
    //assert (g_107 == &g_108 || g_107 == dangling);
    //assert (g_352 == 0 || g_352 == dangling);
    for (g_179.f0.f0 = 0; (g_179.f0.f0 > (-16)); g_179.f0.f0--)
    { /* block id: 260 */
        struct S2 *l_505 = &g_231;
        (**l_275) = (**l_275);
        (*l_245) = l_505;
        /* statement id: 262 */
        assert (l_246 == &g_231);
    }
    return l_432;
}


/* ------------------------------------------ */
/* 
 * reads : g_9
 * writes: g_24
 */
static int32_t * func_13(int32_t * p_14, uint32_t  p_15, uint8_t  p_16)
{ /* block id: 13 */
    const uint16_t l_22 = 0UL;
    int32_t *l_23 = &g_24;
    (*l_23) = (safe_mul_func_uint8_t_u_u(((!l_22) && 0xED99L), (g_9 > g_9)));
    return p_14;
    /* statement id: 15 */
    //assert (func_13_rv == 0 || func_13_rv == &g_2);
}


/* ------------------------------------------ */
/* 
 * reads : g_24 g_9 g_32 g_33 g_2 g_98 g_94 g_108 g_137.f0 g_107 g_161.f0.f0
 * writes: g_24 g_94 g_98 g_107 g_33 g_137 g_160
 */
static int8_t  func_27(int32_t ** const  p_28, int32_t ** p_29)
{ /* block id: 17 */
    uint32_t l_38 = 0xEDAACDA2L;
    struct S2 *l_144 = (void*)0;
    const struct S0 l_145 = {0x760DL};
    int32_t ***l_149 = &g_32;
    int32_t ****l_148 = &l_149;
    int32_t **** const * const l_147 = &l_148;
    struct S1 *l_159 = (void*)0;
    struct S2 *l_178 = &g_179;
    int32_t *l_180 = &g_98;
    if ((safe_lshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u(g_24, (g_9 && l_38))), 4)))
    { /* block id: 18 */
        const int32_t l_41 = 1L;
        int32_t *l_141 = &g_98;
        g_24 = l_38;
        (*p_28) = func_39(l_41);
        /* statement id: 63 */
        //assert (l_31 == &g_9);
        assert (g_94 == &g_24 || g_94 == &g_9);
        //assert (g_107 == &g_108 || g_107 == dangling);
        (*l_141) = (-1L);
        (*l_141) = (***g_108);
    }
    else
    { /* block id: 66 */
        struct S2 *l_143 = (void*)0;
        int32_t l_153 = 0x4F27C2C8L;
        if ((**p_29))
        { /* block id: 67 */
            const int32_t *l_142 = &g_2;
            (*g_32) = (*g_32);
            (*g_94) = (0UL < (**p_29));
            (**g_108) = func_42(l_142, (l_143 != l_144), p_29);
            (*p_29) = (*p_29);
        }
        else
        { /* block id: 72 */
            struct S0 *l_146 = &g_137;
            const int32_t l_158 = 0x9DE4BE9BL;
            (*l_146) = l_145;
            if ((l_147 != &l_148))
            { /* block id: 74 */
                return g_137.f0;
            }
            else
            { /* block id: 76 */
                (***g_107) = (void*)0;
                /* statement id: 77 */
                assert (g_33 == 0);
            }
            /* facts after branching */
            assert (g_33 == 0);
            (**p_28) = (~((safe_mul_func_uint16_t_u_u(l_153, (((((void*)0 == (***g_107)) == ((safe_lshift_func_uint16_t_u_u((l_153 <= (safe_mod_func_int8_t_s_s((((l_158 == l_158) | (l_153 && ((-8L) | ((void*)0 == &l_144)))) < g_2), 6UL))), l_158)) ^ l_153)) ^ l_153) != l_158))) ^ l_153));
        }
        /* facts after branching */
        assert (g_33 == 0 || g_33 == &g_9);
        g_160 = l_159;
        /* statement id: 81 */
        assert (g_160 == 0);
        return g_98;
    }
    /* facts after branching */
    //assert (l_31 == &g_9);
    assert (g_94 == &g_24 || g_94 == &g_9);
    //assert (g_107 == &g_108 || g_107 == dangling);
    (****l_147) = func_39((((*p_29) == (**g_108)) < ((((**p_29) | ((safe_add_func_int16_t_s_s(((safe_mod_func_int8_t_s_s(((safe_mod_func_int32_t_s_s((safe_add_func_int32_t_s_s((safe_mod_func_uint32_t_u_u((0x7F9DL != ((***l_149) <= (****l_148))), (safe_add_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(g_137.f0, (safe_rshift_func_int8_t_s_u(((*p_29) == (**g_108)), (***l_149))))), 0L)))), (**g_32))), 0x046D94E1L)) | g_98), (***l_149))) && (****l_148)), (****l_148))) && g_137.f0)) == 0L) && 0xC49AC2DAL)));
    (*l_180) = ((void*)0 != l_178);
    return g_161.f0.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_32 g_33 g_24 g_9 g_2 g_98 g_94 g_108
 * writes: g_24 g_94 g_98 g_107 g_33
 */
inline static int32_t * func_39(const int8_t  p_40)
{ /* block id: 20 */
    const int32_t *l_46 = &g_24;
    int32_t * const l_47 = &g_9;
    const int8_t l_62 = (-1L);
    struct S2 l_63 = {{-9L},{{-7L}},0xED5C0EB7L,{0x473CL},0x56B74084L,0xAEA480D8L,-1L,0x53288EE1L,{1L},0L};
    uint32_t l_116 = 0x56AE7BB4L;
    int32_t **l_117 = &g_33;
    (**g_108) = func_42(l_46, (((((l_47 != (*g_32)) ^ (~p_40)) == (g_24 || ((0xD2L <= (((safe_div_func_int32_t_s_s(func_51(func_55(((((!l_62) || (4294967288UL != 0xACA64A9BL)) < 0xABF6A420L) < 4294967292UL), l_63, &g_33, l_63.f1, p_40), p_40, (*l_47)), l_116)) <= g_9) ^ (*l_47))) == p_40))) == 0x3AL) <= 0L), l_117);
    return (*l_117);
    /* statement id: 62 */
    //assert (func_39_rv == &g_9);
}


/* ------------------------------------------ */
/* 
 * reads : g_94 g_24 g_9 g_98 g_33
 * writes: g_98
 */
static int32_t * func_42(const int32_t * p_43, uint32_t  p_44, int32_t ** p_45)
{ /* block id: 57 */
    const int32_t l_123 = 1L;
    struct S0 *l_136 = &g_137;
    int32_t *l_140 = &g_98;
    (*l_140) = (safe_mod_func_int16_t_s_s(((+(((safe_div_func_int32_t_s_s(l_123, (safe_sub_func_int16_t_s_s((0x6C1F1C6DL == (l_123 < 0x1BB9DF8DL)), (safe_sub_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u(((safe_add_func_uint8_t_u_u(((*g_94) & ((safe_mod_func_int32_t_s_s((((safe_rshift_func_uint16_t_u_u(0UL, 2)) && ((void*)0 != l_136)) <= (safe_lshift_func_int8_t_s_s((((l_123 == l_123) | l_123) == g_24), 0))), 0x1696E83DL)) < p_44)), p_44)) <= p_44), 2)) >= l_123), p_44)))))) != 0xCC98A5ECL) >= 251UL)) ^ 2UL), 1L));
    (*l_140) = ((*l_140) | (p_44 ^ g_9));
    return (*p_45);
    /* statement id: 60 */
    //assert (func_42_rv == &g_9);
}


/* ------------------------------------------ */
/* 
 * reads : g_24 g_9 g_33 g_32 g_2 g_98
 * writes: g_24 g_94 g_98 g_107
 */
inline static int32_t  func_51(struct S2  p_52, uint32_t  p_53, int32_t  p_54)
{ /* block id: 23 */
    int32_t *l_66 = (void*)0;
    int32_t ***l_113 = &g_32;
    int32_t ****l_112 = &l_113;
    struct S2 *l_115 = (void*)0;
    struct S2 **l_114 = &l_115;
    (*l_112) = func_64(l_66);
    /* statement id: 54 */
    assert (g_94 == &g_9);
    //assert (g_107 == dangling);
    assert (l_113 == 0 || l_113 == &g_32);
    (*l_114) = &p_52;
    /* statement id: 55 */
    assert (l_115 == &p_52);
    return p_52.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_55(uint32_t  p_56, struct S2  p_57, int32_t ** p_58, struct S1  p_59, const uint32_t  p_60)
{ /* block id: 21 */
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads : g_24 g_9 g_33 g_32 g_2 g_98
 * writes: g_24 g_94 g_98 g_107
 */
static int32_t *** func_64(int32_t * p_65)
{ /* block id: 24 */
    int32_t ** const l_75 = &g_33;
    int32_t *l_95 = &g_24;
    int32_t ** const *l_105 = &l_75;
    int32_t ** const **l_104 = &l_105;
    int32_t ** const ***l_106 = (void*)0;
    (*l_95) = (safe_div_func_uint32_t_u_u(func_69(g_24, l_75, g_9, (safe_add_func_int32_t_s_s((*g_33), (((**l_75) <= ((void*)0 == l_75)) >= (**l_75)))), g_9), (**l_75)));
    /* statement id: 35 */
    assert (g_94 == &g_9);
    for (g_24 = 0; (g_24 != 15); g_24 = safe_add_func_int32_t_s_s(g_24, 5))
    { /* block id: 38 */
        int32_t **l_103 = &g_94;
        for (g_98 = 9; (g_98 < (-30)); g_98 = safe_sub_func_int32_t_s_s(g_98, 8))
        { /* block id: 41 */
            struct S0 l_101 = {0x61DDL};
            struct S0 *l_102 = &l_101;
            (*l_102) = l_101;
        }
        (*l_103) = (*l_75);
        (*l_103) = (*g_32);
    }
    g_107 = l_104;
    /* statement id: 47 */
    assert (g_107 == &l_105);
    for (g_98 = 0; (g_98 > 0); g_98 = safe_add_func_uint16_t_u_u(g_98, 3))
    { /* block id: 50 */
        int32_t ***l_111 = (void*)0;
        return l_111;
        /* statement id: 51 */
        //assert (g_107 == dangling);
        //assert (func_64_rv == 0);
    }
    return &g_32;
    /* statement id: 53 */
    //assert (g_107 == dangling);
    //assert (func_64_rv == &g_32);
}


/* ------------------------------------------ */
/* 
 * reads : g_24 g_33 g_9 g_32 g_2
 * writes: g_24 g_94
 */
inline static uint32_t  func_69(int32_t  p_70, int32_t ** const  p_71, int8_t  p_72, int32_t  p_73, const int32_t  p_74)
{ /* block id: 25 */
    int32_t *l_79 = &g_24;
    int32_t **l_78 = &l_79;
    int32_t *l_89 = &g_2;
    (*l_78) = (void*)0;
    /* statement id: 26 */
    assert (l_79 == 0);
    if ((((safe_mod_func_int8_t_s_s(((p_71 != &l_79) <= 0xDBE7L), (safe_div_func_uint32_t_u_u(0x03D6E0AFL, (safe_lshift_func_uint8_t_u_u(0x87L, (safe_mod_func_uint16_t_u_u((!(&p_71 == &l_78)), 0x3FDFL)))))))) > g_24) && (*g_33)))
    { /* block id: 27 */
        int32_t *l_90 = &g_24;
        struct S0 l_91 = {0x9F9AL};
        struct S0 *l_92 = &l_91;
        (*l_90) = ((*g_32) == l_89);
        (*l_92) = l_91;
    }
    else
    { /* block id: 30 */
        int32_t ***l_93 = &l_78;
        (*l_93) = (void*)0;
        /* statement id: 31 */
        assert (l_78 == 0);
    }
    /* facts after branching */
    assert (l_78 == 0 || l_78 == &l_79);
    g_94 = (*g_32);
    return (*l_89);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_9, "g_9", print_hash_value);
    transparent_crc(g_24, "g_24", print_hash_value);
    transparent_crc(g_98, "g_98", print_hash_value);
    transparent_crc(g_137.f0, "g_137.f0", print_hash_value);
    transparent_crc(g_161.f0.f0, "g_161.f0.f0", print_hash_value);
    transparent_crc(g_179.f0.f0, "g_179.f0.f0", print_hash_value);
    transparent_crc(g_179.f1.f0.f0, "g_179.f1.f0.f0", print_hash_value);
    transparent_crc(g_179.f2, "g_179.f2", print_hash_value);
    transparent_crc(g_179.f3.f0, "g_179.f3.f0", print_hash_value);
    transparent_crc(g_179.f4, "g_179.f4", print_hash_value);
    transparent_crc(g_179.f5, "g_179.f5", print_hash_value);
    transparent_crc(g_179.f6, "g_179.f6", print_hash_value);
    transparent_crc(g_179.f7, "g_179.f7", print_hash_value);
    transparent_crc(g_179.f8.f0, "g_179.f8.f0", print_hash_value);
    transparent_crc(g_179.f9, "g_179.f9", print_hash_value);
    transparent_crc(g_231.f0.f0, "g_231.f0.f0", print_hash_value);
    transparent_crc(g_231.f1.f0.f0, "g_231.f1.f0.f0", print_hash_value);
    transparent_crc(g_231.f2, "g_231.f2", print_hash_value);
    transparent_crc(g_231.f3.f0, "g_231.f3.f0", print_hash_value);
    transparent_crc(g_231.f4, "g_231.f4", print_hash_value);
    transparent_crc(g_231.f5, "g_231.f5", print_hash_value);
    transparent_crc(g_231.f6, "g_231.f6", print_hash_value);
    transparent_crc(g_231.f7, "g_231.f7", print_hash_value);
    transparent_crc(g_231.f8.f0, "g_231.f8.f0", print_hash_value);
    transparent_crc(g_231.f9, "g_231.f9", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 3
breakdown:
   depth: 0, occurrence: 83
   depth: 1, occurrence: 14
   depth: 2, occurrence: 0
   depth: 3, occurrence: 1
XXX total union variables: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 175
   depth: 2, occurrence: 31
   depth: 3, occurrence: 3
   depth: 4, occurrence: 5
   depth: 5, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 111

XXX times a variable address is taken: 109
XXX times a pointer is dereferenced on RHS: 86
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 15
   depth: 3, occurrence: 14
   depth: 4, occurrence: 14
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 78
breakdown:
   depth: 1, occurrence: 43
   depth: 2, occurrence: 19
   depth: 3, occurrence: 9
   depth: 4, occurrence: 6
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 298

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 253
   level: 2, occurrence: 84
   level: 3, occurrence: 36
   level: 4, occurrence: 32
   level: 5, occurrence: 10
XXX number of pointers point to pointers: 57
XXX number of pointers point to scalars: 29
XXX number of pointers point to structs: 25
XXX percent of pointers has null in alias set: 29.7
XXX average alias set size: 1.27

XXX times a non-volatile is read: 595
XXX times a non-volatile is write: 256
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 147
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 27
   depth: 2, occurrence: 35
   depth: 3, occurrence: 24
   depth: 4, occurrence: 12
   depth: 5, occurrence: 18

XXX percentage a fresh-made variable is used: 20.3
XXX percentage an existing variable is used: 79.7
********************* end of statistics **********************/

