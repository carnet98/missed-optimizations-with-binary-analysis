/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --checksum --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --jumps --longlong --force-non-uniform-arrays --no-math64 --no-muls --packed-struct --paranoid --pointers --structs --no-inline-function --no-return-structs --arg-structs --dangling-global-pointers
 * Seed:      6699670921683358292
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 24;
};

/* --- GLOBAL VARIABLES --- */
static int8_t g_4 = 3L;
static struct S0 g_19 = {629};
static int32_t g_22 = (-1L);
static struct S0 *g_71 = &g_19;
static int32_t g_144 = (-4L);
static int32_t *g_143 = &g_144;
static struct S0 **g_155 = &g_71;
static struct S0 ***g_154 = &g_155;
static int32_t *g_188 = &g_22;
static int32_t **g_187 = &g_188;
static struct S0 ****g_335 = (void*)0;
static struct S0 *****g_334 = &g_335;
static int8_t g_357 = 0xD9L;
static uint16_t g_480 = 65530UL;
static int32_t ***g_494 = &g_187;
static int32_t ****g_493 = &g_494;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int8_t  func_12(int8_t  p_13);
static uint16_t  func_14(struct S0  p_15, uint8_t  p_16, uint8_t  p_17, uint16_t  p_18);
static int32_t * func_23(int8_t  p_24);
static uint32_t  func_41(int32_t * p_42, int8_t  p_43, int32_t  p_44, int32_t ** p_45);
static int32_t * func_46(struct S0 * p_47, int32_t ** p_48, int32_t ** p_49, uint32_t  p_50, uint32_t  p_51);
static struct S0 * func_52(int32_t * p_53, int32_t  p_54, int32_t  p_55, int32_t ** p_56);
static int32_t * func_61(int32_t  p_62, struct S0 * p_63, uint32_t  p_64, int32_t  p_65, uint32_t  p_66);
static struct S0 * func_67(int8_t  p_68, struct S0 * p_69, int32_t * p_70);
static uint32_t  func_72(int16_t  p_73, uint16_t  p_74, uint32_t  p_75, uint32_t  p_76, int32_t  p_77);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_144
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_9 = 0UL;
    int32_t *l_438 = &g_144;
    struct S0 *l_487 = &g_19;
    struct S0 *****l_496 = &g_335;
    int32_t ***l_510 = (void*)0;
    int8_t l_521 = 1L;
    int32_t ***l_525 = (void*)0;
    return (*l_438);
}


/* ------------------------------------------ */
/* 
 * reads : g_19 g_22 g_71 g_4 g_154 g_144 g_155 g_187 g_188 g_143 g_334 g_357 g_335
 * writes: g_19 g_22 g_143 g_144 g_188 g_334 g_154 g_357
 */
static int8_t  func_12(int8_t  p_13)
{ /* block id: 5 */
    uint8_t l_25 = 0x98L;
    int32_t **l_35 = (void*)0;
    int32_t **l_36 = (void*)0;
    int32_t *l_38 = &g_22;
    int32_t **l_37 = &l_38;
    int32_t *l_57 = &g_22;
    struct S0 l_60 = {927};
    uint16_t l_364 = 1UL;
    int32_t l_408 = 0xF2678B39L;
    struct S0 ****l_436 = (void*)0;
    (*l_37) = func_23(l_25);
    (**l_37) = g_22;
    g_22 = (**l_37);
    if ((safe_sub_func_uint32_t_u_u(((**l_37) > (0xEBB6F2BAL ^ func_41(func_46(func_52(l_57, g_19.f0, (((g_19.f0 >= (g_19.f0 || (safe_lshift_func_int8_t_s_u((((l_60 , func_61(g_19.f0, func_67(p_13, g_71, (*l_37)), p_13, (**l_37), (**l_37))) == (void*)0) & (-3L)), 6)))) , 0x53A8L) > 65526UL), g_187), &l_57, g_187, g_4, (**l_37)), l_364, p_13, g_187))), (**l_37))))
    { /* block id: 162 */
        struct S0 **l_389 = &g_71;
        int32_t ***l_391 = (void*)0;
        int32_t ****l_390 = &l_391;
        int32_t l_396 = 3L;
        for (p_13 = 2; (p_13 > (-5)); p_13--)
        { /* block id: 165 */
            struct S0 l_386 = {2512};
            struct S0 **l_388 = &g_71;
            int32_t l_397 = 0x4696B21AL;
            int32_t *l_409 = &g_144;
            uint32_t l_422 = 6UL;
            (*g_143) = ((safe_rshift_func_uint16_t_u_u(((((safe_lshift_func_uint16_t_u_u(((p_13 , l_386) , ((+((((l_388 == l_389) ^ ((void*)0 == l_390)) || ((safe_div_func_int16_t_s_s((safe_div_func_int32_t_s_s((((g_357 , &l_389) == &l_388) > p_13), g_4)), 0x4721L)) > l_386.f0)) , g_19.f0)) != p_13)), 2)) && g_357) || 0x07D9147CL) & g_4), l_396)) >= l_397);
            l_409 = func_61(p_13, (*l_388), (p_13 | (safe_sub_func_int16_t_s_s((p_13 , (((((((safe_lshift_func_int8_t_s_u((((void*)0 == l_388) < p_13), 7)) , (*l_389)) == (*l_388)) > l_408) && (*l_38)) >= (*l_38)) > 1UL)), 0x4988L))), g_22, (*l_38));
            /* statement id: 167 */
            assert (g_143 == &g_22);
            if ((*g_143))
                continue;
            (*g_187) = func_61(((g_357 > ((void*)0 == (*l_37))) , ((p_13 || (((safe_lshift_func_int16_t_s_u((-5L), ((safe_sub_func_uint8_t_u_u(g_4, ((safe_rshift_func_uint8_t_u_s((safe_mod_func_int32_t_s_s((((p_13 == ((((safe_div_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u((*l_409), g_22)), g_144)) == p_13) & p_13) < 7UL)) , &l_389) != (void*)0), (**l_37))), 6)) < 0x7D06C2CBL))) || g_144))) <= l_422) < 0xA9F1L)) <= g_19.f0)), (*l_388), g_357, g_144, g_144);
            /* statement id: 169 */
            assert (g_188 == &g_144);
        }
    }
    else
    { /* block id: 171 */
        uint16_t l_429 = 0UL;
        struct S0 ***l_437 = &g_155;
        (*l_38) = (safe_rshift_func_int8_t_s_s((safe_lshift_func_uint16_t_u_s((((safe_add_func_int8_t_s_s(g_19.f0, (((void*)0 != &g_187) <= (((-1L) != ((l_429 || 0x730FL) , (safe_div_func_uint8_t_u_u((((safe_rshift_func_int8_t_s_u(((g_144 != (g_19.f0 == (l_436 == (*g_334)))) || l_429), p_13)) <= 1L) | (*l_38)), 1UL)))) > g_19.f0)))) , l_437) == (void*)0), 3)), 5));
    }
    /* facts after branching */
    assert (l_57 == &g_22 || l_57 == &g_144);
    assert (g_143 == &g_144 || g_143 == &g_22);
    assert (g_154 == 0);
    assert (g_188 == &g_144 || g_188 == &g_22 || g_188 == 0);
    return g_144;
}


/* ------------------------------------------ */
/* 
 * reads : g_4
 * writes: g_22
 */
static uint16_t  func_14(struct S0  p_15, uint8_t  p_16, uint8_t  p_17, uint16_t  p_18)
{ /* block id: 1 */
    int32_t *l_20 = (void*)0;
    int32_t **l_21 = &l_20;
    (*l_21) = l_20;
    g_22 = p_15.f0;
    return g_4;
}


/* ------------------------------------------ */
/* 
 * reads : g_19
 * writes: g_19
 */
static int32_t * func_23(int8_t  p_24)
{ /* block id: 6 */
    int32_t l_26 = 0xFC5674FAL;
    struct S0 l_30 = {1676};
    struct S0 *l_34 = &g_19;
lbl_33:
    if (l_26)
    { /* block id: 7 */
        int32_t *l_28 = &g_22;
        int32_t **l_27 = &l_28;
        struct S0 *l_29 = &g_19;
        (*l_27) = &g_22;
        (*l_29) = g_19;
        (*l_29) = l_30;
        l_30 = (*l_29);
    }
    else
    { /* block id: 12 */
        int32_t *l_31 = &g_22;
        int32_t **l_32 = &l_31;
        (*l_32) = l_31;
        if (g_19.f0)
            goto lbl_33;
    }
    (*l_34) = l_30;
    return &g_22;
    /* statement id: 17 */
    //assert (func_23_rv == &g_22);
}


/* ------------------------------------------ */
/* 
 * reads : g_71 g_187 g_19 g_155 g_144 g_188 g_357 g_4
 * writes: g_154 g_19 g_188 g_144 g_357
 */
static uint32_t  func_41(int32_t * p_42, int8_t  p_43, int32_t  p_44, int32_t ** p_45)
{ /* block id: 137 */
    struct S0 ***l_365 = (void*)0;
    struct S0 ****l_366 = &g_154;
    int32_t l_379 = 3L;
    (*l_366) = l_365;
    /* statement id: 138 */
    assert (g_154 == 0);
    if (((void*)0 != &g_187))
    { /* block id: 139 */
        struct S0 l_367 = {3914};
        int32_t l_370 = 1L;
        (*g_71) = l_367;
        (*g_187) = (void*)0;
        /* statement id: 141 */
        assert (g_188 == 0);
        (**g_155) = (*g_71);
        for (g_144 = 14; (g_144 < 2); g_144--)
        { /* block id: 145 */
            l_370 = (*p_42);
        }
    }
    else
    { /* block id: 148 */
        int32_t ***l_372 = (void*)0;
        int32_t ****l_371 = &l_372;
        int32_t *****l_373 = (void*)0;
        int32_t *****l_374 = &l_371;
        (*l_374) = l_371;
        (*g_187) = (*p_45);
    }
    /* facts after branching */
    assert (g_188 == &g_144 || g_188 == &g_22 || g_188 == 0);
    for (p_43 = 0; (p_43 != (-16)); p_43--)
    { /* block id: 154 */
        for (g_357 = 0; (g_357 < 22); g_357 = safe_add_func_uint32_t_u_u(g_357, 1))
        { /* block id: 157 */
            return g_4;
        }
    }
    return l_379;
}


/* ------------------------------------------ */
/* 
 * reads : g_143 g_144 g_22 g_4 g_188 g_19 g_187 g_155 g_71 g_154 g_334 g_357
 * writes: g_144 g_188 g_19 g_143 g_334
 */
static int32_t * func_46(struct S0 * p_47, int32_t ** p_48, int32_t ** p_49, uint32_t  p_50, uint32_t  p_51)
{ /* block id: 98 */
    uint32_t l_243 = 4294967286UL;
    struct S0 **l_270 = &g_71;
    int8_t l_307 = (-1L);
    uint16_t l_333 = 6UL;
    int32_t l_359 = 0x2B119D4DL;
    int32_t *l_363 = &g_144;
    if (l_243)
    { /* block id: 99 */
        int16_t l_262 = 0x54CFL;
        int32_t *l_271 = &g_144;
        (*l_271) = (+((safe_lshift_func_uint16_t_u_s(0xEAB7L, 14)) >= (0x8B7BL <= (safe_sub_func_int16_t_s_s((safe_add_func_int8_t_s_s(((safe_rshift_func_int16_t_s_u(((safe_div_func_int32_t_s_s((((((safe_lshift_func_int8_t_s_s((0xA9L > ((safe_add_func_uint16_t_u_u((((safe_unary_minus_func_uint8_t_u((p_49 == &g_143))) ^ l_262) && ((safe_sub_func_int16_t_s_s(((((safe_div_func_uint32_t_u_u(((safe_add_func_uint8_t_u_u(((0L < p_50) && ((((~(*g_143)) , l_270) == l_270) == l_243)), g_4)) || g_22), (*g_188))) & l_243) | l_243) | 0xF4331D11L), 0x6F38L)) | l_243)), g_4)) != 0UL)), 1)) , l_243) , l_243) | 8L) | l_243), 0x6A20D3CCL)) <= 0xB723L), 11)) <= 1L), l_243)), 1UL)))));
        (*l_271) = (*g_143);
    }
    else
    { /* block id: 102 */
        int16_t l_293 = 0L;
        int32_t **l_300 = (void*)0;
        struct S0 l_356 = {682};
        for (l_243 = 15; (l_243 <= 8); --l_243)
        { /* block id: 105 */
            int8_t l_278 = 0x48L;
            int32_t *l_306 = &g_22;
            for (p_50 = 0; (p_50 == 56); p_50++)
            { /* block id: 108 */
                int8_t l_276 = (-9L);
                struct S0 ***l_277 = &g_155;
                int32_t *l_279 = &g_144;
                if (l_276)
                    break;
                (*l_279) = ((((((g_4 , (*p_47)) , (void*)0) == (void*)0) != (((((void*)0 != l_277) , (((g_144 >= g_19.f0) | (((**p_48) != (**p_49)) > l_278)) <= 0x7DE5L)) != (**p_49)) > g_22)) > l_243) == g_144);
            }
            (*g_187) = (*g_187);
            if ((((safe_sub_func_uint32_t_u_u(((0x327DL && (g_19.f0 != ((*p_49) != (void*)0))) || l_243), (((safe_rshift_func_uint16_t_u_s((!l_278), 3)) && ((*p_48) != (*g_187))) ^ (safe_add_func_uint8_t_u_u(1UL, l_243))))) ^ l_278) < 0UL))
            { /* block id: 113 */
                int32_t *l_304 = &g_144;
                if ((**g_187))
                    break;
                (*l_304) = (safe_div_func_int32_t_s_s((safe_lshift_func_int8_t_s_u((l_293 || ((safe_sub_func_int16_t_s_s(((safe_add_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s((l_300 != &g_188), (safe_sub_func_uint16_t_u_u((~((*p_47) , ((*g_155) == p_47))), (8UL <= (-9L)))))), (&g_188 != (void*)0))) & g_19.f0), 0xCB54L)) ^ p_50)), p_51)), g_4));
                (*l_304) = (1L & (+p_50));
                (*l_304) = ((void*)0 != (*l_270));
            }
            else
            { /* block id: 118 */
                struct S0 l_308 = {2368};
                struct S0 **l_332 = &g_71;
                int32_t *l_336 = &g_144;
                (*p_49) = l_306;
                l_307 = (p_48 != (void*)0);
                (*g_71) = l_308;
                if ((~(((safe_mod_func_uint8_t_u_u(((**p_49) , ((l_308.f0 , func_67((safe_lshift_func_int16_t_s_s((safe_rshift_func_uint8_t_u_s(0UL, 2)), 4)), p_47, func_23(((safe_div_func_int8_t_s_s((-4L), (safe_lshift_func_uint8_t_u_u((+((~(safe_lshift_func_int8_t_s_s(((l_308.f0 && (-3L)) ^ (safe_div_func_int32_t_s_s((safe_sub_func_uint32_t_u_u((safe_add_func_uint8_t_u_u(((safe_rshift_func_int8_t_s_u(((*g_154) == l_332), g_22)) && g_4), p_51)), l_333)), 4294967286UL))), g_22))) != 0xFAB1L)), l_308.f0)))) > 1L)))) != (*l_270))), g_22)) <= (*l_306)) <= (*g_188))))
                { /* block id: 122 */
                    (*g_187) = (*g_187);
                    g_334 = g_334;
                    (*p_48) = l_336;
                    /* statement id: 125 */
                    //assert (l_57 == &g_144);
                }
                else
                { /* block id: 126 */
                    int8_t l_358 = 0xC2L;
                    (*l_336) = (&g_335 != &g_335);
                    l_359 = (((*p_47) , ((l_333 | (((safe_div_func_uint8_t_u_u((g_19.f0 >= (((*l_306) >= 7UL) | 0x67C20CE6L)), ((((((safe_mod_func_uint8_t_u_u((safe_div_func_uint32_t_u_u((safe_div_func_uint16_t_u_u((((((*p_49) == (((*l_336) , ((((((safe_sub_func_uint16_t_u_u((safe_div_func_int16_t_s_s((((((((safe_sub_func_uint32_t_u_u(((safe_div_func_int32_t_s_s((((+(safe_mod_func_int8_t_s_s(g_144, g_19.f0))) , l_356) , (*g_188)), (*l_306))) ^ 1L), 9L)) || 1UL) & g_357) | (**p_48)) && g_357) | g_19.f0) && 0xAB6EL), p_50)), 0xE2ABL)) , l_358) , (*l_306)) != l_356.f0) <= p_50) , (***g_154))) , (*p_49))) > g_19.f0) || 0xD3L) | 0xD46C6D65L), 1UL)), p_50)), p_51)) && (-1L)) , 0L) | 0x9260AA1EL) || (**g_187)) | g_144))) || (*l_336)) , p_51)) < l_358)) | (**p_49));
                    (*l_336) = (*g_188);
                }
            }
        }
        /* facts after for loop */
        assert (g_143 == 0 || g_143 == &g_144 || g_143 == &g_22);
        //assert (l_57 == &g_22 || l_57 == &g_144);
        (*p_49) = func_61((**g_187), (((((((void*)0 == &g_335) >= ((&g_187 != (void*)0) > (safe_sub_func_int16_t_s_s((((p_50 != ((p_51 ^ p_50) == (((g_4 || g_144) || 0x01L) <= (**p_48)))) ^ l_243) >= g_22), 0x7B35L)))) , 65528UL) , (void*)0) == (void*)0) , p_47), p_50, g_19.f0, l_333);
        /* statement id: 133 */
        assert (g_143 == &g_22);
        assert (g_188 == &g_144);
        (**g_187) = (!(0x29EAL && (0L < l_333)));
    }
    /* facts after branching */
    assert (g_188 == &g_144 || g_188 == &g_22);
    //assert (l_57 == &g_22 || l_57 == &g_144);
    return l_363;
    /* statement id: 136 */
    //assert (func_46_rv == &g_144);
}


/* ------------------------------------------ */
/* 
 * reads : g_22 g_19 g_187 g_188 g_4 g_144 g_154 g_155 g_71
 * writes: g_19 g_188 g_144
 */
static struct S0 * func_52(int32_t * p_53, int32_t  p_54, int32_t  p_55, int32_t ** p_56)
{ /* block id: 82 */
    uint32_t l_191 = 0xEF2A897AL;
    int32_t **l_196 = &g_188;
    struct S0 l_197 = {1851};
    struct S0 ****l_202 = (void*)0;
    uint8_t l_209 = 255UL;
    struct S0 l_242 = {830};
    if ((((safe_mod_func_uint8_t_u_u(l_191, 0x44L)) > (safe_lshift_func_uint16_t_u_u((safe_sub_func_int16_t_s_s(((void*)0 != l_196), (l_197 , (safe_add_func_uint32_t_u_u((&g_154 != ((safe_rshift_func_uint8_t_u_u(p_55, (4L & (65535UL >= 4L)))) , l_202)), g_22))))), p_55))) & g_22))
    { /* block id: 83 */
        int32_t l_214 = 3L;
        struct S0 **l_221 = (void*)0;
        int32_t *l_224 = &g_144;
        (*g_187) = func_23(p_55);
        for (p_55 = 0; (p_55 != 0); p_55 = safe_add_func_uint32_t_u_u(p_55, 7))
        { /* block id: 87 */
        }
        (*l_224) = (!g_19.f0);
    }
    else
    { /* block id: 93 */
        uint32_t l_231 = 0xCE7F4B8DL;
        struct S0 ****l_241 = &g_154;
        l_242 = ((safe_lshift_func_uint16_t_u_s((1UL && ((safe_div_func_uint8_t_u_u(((l_231 & (**l_196)) ^ (safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_u((((~(((p_54 > (((**l_196) ^ g_4) , ((safe_div_func_int8_t_s_s((safe_sub_func_int8_t_s_s(((((void*)0 != &p_53) , ((l_202 != l_241) == p_55)) != 6L), (-1L))), g_4)) && l_231))) <= g_144) == 1L)) || 4L) & p_54), 6)), (**l_196)))), g_19.f0)) <= p_55)), 0)) , (****l_241));
        return (**g_154);
        /* statement id: 95 */
        //assert (func_52_rv == &g_19);
    }
    return (*g_155);
    /* statement id: 97 */
    //assert (func_52_rv == &g_19);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_143
 */
static int32_t * func_61(int32_t  p_62, struct S0 * p_63, uint32_t  p_64, int32_t  p_65, uint32_t  p_66)
{ /* block id: 79 */
    int32_t **l_186 = &g_143;
    (*l_186) = &g_22;
    /* statement id: 80 */
    assert (g_143 == &g_22);
    return &g_144;
    /* statement id: 81 */
    //assert (func_61_rv == &g_144);
}


/* ------------------------------------------ */
/* 
 * reads : g_71 g_19 g_4 g_22 g_154 g_144 g_155
 * writes: g_143 g_144
 */
static struct S0 * func_67(int8_t  p_68, struct S0 * p_69, int32_t * p_70)
{ /* block id: 21 */
    int32_t l_84 = (-7L);
    int32_t l_91 = 0x1936EFE4L;
    int32_t **l_94 = (void*)0;
    int32_t *l_96 = &g_22;
    int32_t **l_95 = &l_96;
    int32_t l_99 = (-2L);
    struct S0 l_122 = {1729};
    int32_t l_172 = (-7L);
    (*l_95) = (func_72(((*g_71) , (((((safe_add_func_uint16_t_u_u((safe_mod_func_uint8_t_u_u(((safe_add_func_uint8_t_u_u(l_84, (l_84 , g_4))) , ((((((safe_div_func_int32_t_s_s((g_22 != (safe_div_func_int8_t_s_s(1L, (safe_lshift_func_int8_t_s_u((g_4 , (((p_68 , (*p_69)) , g_22) , p_68)), 6))))), l_84)) && 4294967295UL) , &g_22) == &l_84) < g_22) | l_84)), 1UL)), 1UL)) , 0x5BL) ^ 0x84L) || g_22) | l_91)), g_19.f0, p_68, g_22, l_84) , p_70);
    if ((((p_68 && (((safe_sub_func_int32_t_s_s((*p_70), g_19.f0)) <= ((0x2CL | p_68) >= ((-7L) > 255UL))) & (*p_70))) & (g_19.f0 | l_99)) >= (*l_96)))
    { /* block id: 27 */
        struct S0 *l_100 = &g_19;
        int32_t l_114 = (-1L);
        int32_t **l_125 = &l_96;
        if (((((void*)0 == l_100) || ((safe_unary_minus_func_uint8_t_u(0xA1L)) > (&p_70 != &l_96))) != (safe_div_func_uint8_t_u_u(((void*)0 == p_70), (safe_rshift_func_int16_t_s_u(((((safe_add_func_int32_t_s_s((((safe_lshift_func_int8_t_s_u((((safe_sub_func_int32_t_s_s(((((*p_70) , ((g_22 , &g_22) != (*l_95))) ^ g_4) && g_4), g_19.f0)) > (*l_96)) == (*l_96)), 2)) >= 0x58F5970FL) != l_114), 0xA386FCCFL)) ^ (*p_70)) , 0x93L) < p_68), g_19.f0))))))
        { /* block id: 28 */
            int16_t l_127 = (-5L);
            for (l_91 = 0; (l_91 >= 25); l_91 = safe_add_func_uint16_t_u_u(l_91, 6))
            { /* block id: 31 */
                int32_t *l_126 = &l_84;
                for (l_114 = 0; (l_114 >= (-30)); l_114--)
                { /* block id: 34 */
                    for (l_99 = (-6); (l_99 != (-30)); l_99--)
                    { /* block id: 37 */
                        int32_t *l_121 = &l_91;
                        struct S0 *l_123 = (void*)0;
                        struct S0 *l_124 = &l_122;
                        (*l_95) = l_121;
                        /* statement id: 38 */
                        assert (l_96 == &l_91);
                        (*l_124) = l_122;
                        return &g_19;
                        /* statement id: 40 */
                        //assert (func_67_rv == &g_19);
                    }
                }
                l_114 = ((0xAEL <= ((void*)0 == l_125)) != 4294967295UL);
                (*l_126) = (**l_125);
                if (l_127)
                    continue;
            }
        }
        else
        { /* block id: 47 */
            (*l_95) = &g_22;
        }
    }
    else
    { /* block id: 50 */
        uint32_t l_141 = 0x07C9B672L;
        int32_t *l_142 = &l_84;
        int32_t l_149 = 2L;
        struct S0 l_159 = {3314};
        struct S0 l_171 = {2362};
        uint32_t l_174 = 0xAFE078D0L;
        (*l_142) = (safe_sub_func_uint16_t_u_u(((((p_68 , (~(safe_add_func_uint8_t_u_u((p_68 , p_68), ((((p_68 , (((((((safe_rshift_func_uint8_t_u_s((g_22 != g_4), ((-1L) && (safe_add_func_int8_t_s_s((((safe_mod_func_int32_t_s_s((g_22 | (((((((safe_lshift_func_uint16_t_u_u((255UL <= 1UL), 0)) != p_68) || g_19.f0) == 4L) , g_22) >= g_4) || l_141)), (*p_70))) ^ l_141) & 0xD5AEL), g_22))))) , p_69) != (void*)0) , (*l_96)) , p_68) , g_22) & l_141)) , (void*)0) != l_142) != (*l_142)))))) , (*p_70)) <= (*l_142)) == 3UL), g_19.f0));
        g_143 = (void*)0;
        /* statement id: 52 */
        assert (g_143 == 0);
        if (((p_68 >= ((((((safe_add_func_int8_t_s_s((safe_sub_func_int8_t_s_s((l_149 >= (((*g_71) , (*g_71)) , g_22)), (p_68 , p_68))), ((0x681BL && ((+((-1L) | g_22)) , p_68)) && 65530UL))) , g_22) >= 0UL) || (*l_142)) < p_68) < g_19.f0)) && 0xB87C57D7L))
        { /* block id: 53 */
            struct S0 *l_151 = &l_122;
            (*l_151) = (*p_69);
        }
        else
        { /* block id: 55 */
            struct S0 **l_153 = &g_71;
            struct S0 ***l_152 = &l_153;
            struct S0 ****l_156 = &l_152;
            (*l_152) = &p_69;
            /* statement id: 56 */
            assert (l_153 == &p_69);
            (*l_156) = g_154;
            /* statement id: 57 */
            assert (l_152 == &g_155);
        }
        for (g_144 = (-18); (g_144 == (-21)); g_144 = safe_sub_func_int32_t_s_s(g_144, 1))
        { /* block id: 61 */
            struct S0 *l_160 = &l_122;
            int32_t l_173 = (-2L);
            uint32_t l_181 = 0x1483A88FL;
            (*l_160) = l_159;
            for (l_141 = (-5); (l_141 != 28); l_141 = safe_add_func_uint16_t_u_u(l_141, 3))
            { /* block id: 65 */
                struct S0 l_170 = {3139};
                int32_t *l_175 = &l_84;
                int8_t l_182 = 0L;
                int32_t ***l_183 = &l_94;
                (*l_142) = (safe_rshift_func_uint16_t_u_s(((((g_144 & (((safe_lshift_func_uint8_t_u_s((g_22 < ((g_19.f0 || (p_68 <= (p_68 >= (*l_96)))) <= ((safe_div_func_uint32_t_u_u(((((+((*g_154) != (((((l_170 , &g_143) != (void*)0) , l_171) , (*p_70)) , (*g_154)))) != l_172) , l_173) , p_68), 1UL)) >= g_144))), g_144)) , p_68) , (*p_70))) , l_171) , p_68) , g_4), l_174));
                g_143 = (((((((((void*)0 == l_175) , l_170) , 0xB743FEE9L) == (4294967293UL & (*p_70))) < (((safe_sub_func_uint8_t_u_u(p_68, ((((((~((safe_lshift_func_uint8_t_u_s((l_181 && ((2L > (*l_175)) < (**l_95))), p_68)) && g_4)) & 0x2BCBDF4BL) , p_68) || g_22) || p_68) && g_22))) <= 0x4D6DL) < l_182)) != (*l_142)) > 0xBEL) , (void*)0);
                (*l_183) = (void*)0;
                (*l_95) = &g_22;
            }
        }
    }
    for (l_172 = (-21); (l_172 == (-5)); l_172++)
    { /* block id: 75 */
        l_122 = (p_68 , (*g_71));
    }
    return p_69;
    /* statement id: 78 */
    //assert (func_67_rv == &g_19);
}


/* ------------------------------------------ */
/* 
 * reads : g_4
 * writes:
 */
static uint32_t  func_72(int16_t  p_73, uint16_t  p_74, uint32_t  p_75, uint32_t  p_76, int32_t  p_77)
{ /* block id: 22 */
    int32_t *l_92 = &g_22;
    int32_t **l_93 = &l_92;
    (*l_93) = l_92;
    (*l_93) = (void*)0;
    /* statement id: 24 */
    assert (l_92 == 0);
    return g_4;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_19.f0, "g_19.f0", print_hash_value);
    transparent_crc(g_22, "g_22", print_hash_value);
    transparent_crc(g_144, "g_144", print_hash_value);
    transparent_crc(g_357, "g_357", print_hash_value);
    transparent_crc(g_480, "g_480", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 90
   depth: 1, occurrence: 16
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 36
breakdown:
   indirect level: 0, occurrence: 16
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 16
breakdown:
   indirect level: 0, occurrence: 16
XXX times a bitfields struct's address is taken: 10
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 42

XXX max expression depth: 44
breakdown:
   depth: 1, occurrence: 123
   depth: 2, occurrence: 21
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 2
   depth: 44, occurrence: 1

XXX total number of pointers: 97

XXX times a variable address is taken: 97
XXX times a pointer is dereferenced on RHS: 128
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 30
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 63
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 356

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 369
   level: 2, occurrence: 93
   level: 3, occurrence: 8
   level: 4, occurrence: 9
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 54
XXX number of pointers point to scalars: 29
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 23.7
XXX average alias set size: 1.1

XXX times a non-volatile is read: 692
XXX times a non-volatile is write: 157
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 104
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 31
   depth: 2, occurrence: 16
   depth: 3, occurrence: 18
   depth: 4, occurrence: 7
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 17
XXX percentage an existing variable is used: 83
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

