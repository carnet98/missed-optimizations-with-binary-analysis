/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-jumps --no-longlong --force-non-uniform-arrays --no-math64 --no-muls --packed-struct --no-paranoid --pointers --structs --no-inline-function --no-return-structs --no-arg-structs --dangling-global-pointers
 * Seed:      7372019272251875440
 */


#define NO_LONGLONG

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint8_t  f0;
   unsigned f1 : 3;
   unsigned f2 : 25;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   signed f0 : 18;
   unsigned f1 : 22;
   signed f2 : 31;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_8 = 4294967295U;
static int32_t g_54 = 0x95C4B79A;
static int32_t *g_105 = &g_54;
static int32_t **g_104 = &g_105;
static int32_t g_121 = 0;
static uint8_t g_134 = 247U;
static struct S1 g_145 = {-286,1571,30945};
static struct S1 *g_144 = &g_145;
static struct S1 *g_146 = &g_145;
static int32_t g_172 = 0x21BE7324;
static struct S0 g_223 = {0x6C,1,2823};
static int32_t g_236 = 0xE2EB9B0F;
static int32_t ***g_247 = &g_104;
static int32_t ****g_246 = &g_247;
static int32_t ****g_306 = &g_247;
static int32_t *****g_305 = &g_306;
static int32_t *g_319 = &g_172;
static uint8_t g_329 = 1U;
static int32_t g_332 = (-2);
static struct S1 **g_348 = (void*)0;
static struct S1 ***g_347 = &g_348;
static struct S1 ****g_346 = &g_347;
static struct S1 *****g_345 = &g_346;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static uint8_t  func_2(int8_t  p_3);
static int32_t  func_16(int32_t  p_17, int32_t  p_18, uint8_t  p_19);
static int32_t  func_20(int32_t  p_21, int16_t  p_22, int16_t  p_23, int32_t  p_24);
static int16_t  func_30(uint8_t  p_31, uint32_t  p_32, int8_t  p_33);
static uint8_t  func_38(int32_t  p_39);
static int32_t * func_49(int32_t * p_50, int32_t  p_51, int16_t  p_52);
static int32_t ** func_67(int16_t  p_68, uint32_t  p_69);
static int8_t  func_76(uint32_t  p_77);
static int16_t  func_87(int32_t * p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_54 g_104 g_105 g_121 g_134 g_144 g_146 g_172 g_145.f2 g_145.f0 g_145.f1 g_236 g_246 g_247 g_223.f0 g_223.f2 g_145 g_305 g_319 g_306 g_329 g_332 g_345 g_346 g_347
 * writes: g_54 g_121 g_8 g_105 g_145 g_134 g_172 g_104 g_223 g_246
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int16_t l_304 = (-5);
    int32_t *****l_307 = (void*)0;
    struct S1 ***l_310 = (void*)0;
    struct S1 ****l_309 = &l_310;
    struct S1 *****l_308 = &l_309;
    int8_t l_317 = (-8);
    uint16_t l_318 = 0x9BA0;
    int32_t *l_366 = &g_172;
    if (((func_2((safe_lshift_func_uint16_t_u_u(2U, (safe_lshift_func_int16_t_s_s(g_8, 5))))) || l_304) == (((g_305 == l_307) <= ((void*)0 != l_308)) || (g_144 == g_146))))
    { /* block id: 141 */
        int32_t l_311 = 0;
        struct S1 *****l_337 = &l_309;
        (***g_306) = g_319;
        for (g_172 = 0; (g_172 >= 14); g_172++)
        { /* block id: 145 */
            uint8_t l_322 = 0x0F;
            l_311 = (*g_319);
            if (l_322)
                break;
            for (l_311 = 19; (l_311 >= (-5)); l_311 = safe_sub_func_int16_t_s_s(l_311, 5))
            { /* block id: 150 */
                int32_t l_335 = 0xFED91531;
                struct S1 *****l_336 = &l_309;
                int32_t *l_340 = &g_54;
                (*l_340) = (safe_add_func_int16_t_s_s(((((((safe_sub_func_int16_t_s_s((0xCEF5 & (((****g_306) | g_329) && (safe_div_func_int16_t_s_s(((g_332 > ((safe_lshift_func_uint8_t_u_u((1 < l_335), (l_336 != l_337))) == ((safe_div_func_int16_t_s_s((g_145.f2 ^ g_134), g_121)) == g_236))) <= 1), 0xE133)))), g_145.f2)) && l_322) == l_311) | l_317) >= g_121) >= l_335), 0U));
                for (g_223.f0 = (-16); (g_223.f0 >= 34); g_223.f0 = safe_add_func_int8_t_s_s(g_223.f0, 9))
                { /* block id: 154 */
                }
                (***g_246) = (**g_247);
            }
            return g_134;
        }
    }
    else
    { /* block id: 167 */
        struct S0 l_364 = {0x01,0,694};
        struct S0 *l_365 = &l_364;
        (*g_319) = (safe_sub_func_uint16_t_u_u((0x52B4 || ((0x8C || (safe_lshift_func_int16_t_s_u((safe_sub_func_uint16_t_u_u(g_8, g_54)), 6))) > (!4294967286U))), (safe_div_func_uint16_t_u_u(g_145.f0, (safe_div_func_int16_t_s_s((((safe_div_func_int8_t_s_s(((void*)0 != (**g_345)), (((safe_add_func_uint32_t_u_u((&g_346 != &g_346), g_134)) < g_54) ^ 0x5E6DA357))) | g_223.f2) & 5), (-1)))))));
        (*l_365) = l_364;
        return g_329;
    }
    (***g_246) = l_366;
    (***g_306) = (***g_306);
    return g_134;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_54 g_104 g_105 g_121 g_134 g_144 g_146 g_172 g_145.f2 g_145.f0 g_145.f1 g_236 g_246 g_247 g_223.f0 g_223.f2 g_145
 * writes: g_54 g_121 g_8 g_105 g_145 g_134 g_172 g_104 g_223 g_246
 */
static uint8_t  func_2(int8_t  p_3)
{ /* block id: 1 */
    uint16_t l_11 = 65534U;
    uint32_t l_27 = 0U;
    int32_t l_48 = 0xB30B137D;
    uint8_t l_235 = 0xDD;
    struct S1 **l_239 = &g_144;
    int32_t *l_242 = &g_54;
    struct S1 ***l_261 = &l_239;
    struct S1 ****l_260 = &l_261;
    if (((safe_div_func_int16_t_s_s((((p_3 | (l_11 || (safe_rshift_func_int8_t_s_s(((safe_sub_func_int32_t_s_s(func_16(func_20((safe_lshift_func_uint16_t_u_s(l_27, 11)), (safe_div_func_int16_t_s_s(func_30(((safe_sub_func_int32_t_s_s((((((g_8 != 0x1FCC) & p_3) | (safe_rshift_func_uint8_t_u_u(func_38((safe_add_func_uint8_t_u_u(254U, (safe_rshift_func_uint8_t_u_u((safe_sub_func_int32_t_s_s((((g_8 | l_27) ^ 0U) || 4294967288U), l_27)), 3))))), l_48))) ^ l_11) <= 0xE548), g_8)) >= 0xA0), l_48, l_27), l_11)), g_134, p_3), g_172, p_3), l_235)) <= 0x5B), p_3)))) || p_3) <= l_48), 0x4805)) != g_236))
    { /* block id: 89 */
        int32_t *l_241 = &g_172;
        for (g_121 = (-2); (g_121 < (-25)); g_121 = safe_sub_func_uint16_t_u_u(g_121, 1))
        { /* block id: 92 */
            struct S1 **l_240 = (void*)0;
            int32_t *l_243 = &l_48;
            l_240 = l_239;
            l_242 = l_241;
            (*g_104) = l_243;
            (*g_104) = (*g_104);
        }
        (*g_104) = l_241;
    }
    else
    { /* block id: 99 */
        int32_t *l_249 = (void*)0;
        int32_t l_257 = 0x52E7EA93;
        for (l_27 = 0; (l_27 <= 22); l_27 = safe_add_func_int32_t_s_s(l_27, 5))
        { /* block id: 102 */
            int32_t *****l_248 = &g_246;
            (*l_248) = g_246;
            return g_8;
        }
        (*g_104) = &l_48;
        (***g_247) = ((p_3 > ((l_249 == (void*)0) & (&l_48 != (*g_104)))) & (safe_add_func_uint8_t_u_u(((safe_rshift_func_uint16_t_u_u((g_134 & (((!(safe_div_func_uint32_t_u_u(((l_257 == (***g_247)) && ((((p_3 == 65535U) & p_3) >= 7U) >= g_223.f0)), p_3))) & p_3) | (*g_105))), 11)) < 0x1B4AE9B5), 1U)));
        if ((1U | (safe_div_func_uint16_t_u_u((*l_242), p_3))))
        { /* block id: 108 */
            (*l_242) = (3U == 0x4A77);
        }
        else
        { /* block id: 110 */
            uint8_t l_276 = 0x99;
            int32_t *l_280 = &l_48;
            if ((4294967289U < (l_249 == l_249)))
            { /* block id: 111 */
                struct S1 *****l_262 = &l_260;
                (***g_246) = (void*)0;
                (*l_262) = l_260;
            }
            else
            { /* block id: 114 */
                int32_t l_265 = 6;
                if (((((safe_div_func_int32_t_s_s(l_265, (safe_div_func_int16_t_s_s((((g_236 <= ((((((safe_add_func_uint32_t_u_u((safe_div_func_uint32_t_u_u(l_265, (*l_242))), (p_3 <= 0x6282))) ^ (safe_add_func_uint8_t_u_u(g_134, (p_3 && (0x1E8B384F & p_3))))) && (*l_242)) || (***g_247)) ^ g_145.f2) != l_276)) >= g_172) ^ p_3), p_3)))) >= 0xB3E9) > g_223.f2) < l_276))
                { /* block id: 115 */
                    int32_t *l_279 = &g_121;
                    for (l_257 = 19; (l_257 <= 19); l_257 = safe_add_func_uint32_t_u_u(l_257, 5))
                    { /* block id: 118 */
                        (***g_246) = &l_265;
                    }
                    (****g_246) = ((p_3 && (*l_242)) == (g_54 == 4));
                    (***g_246) = func_49(l_279, (*l_242), g_54);
                }
                else
                { /* block id: 123 */
                    (*l_242) = (**g_104);
                }
                (***g_246) = (**g_247);
                (**l_239) = (***l_261);
            }
            if ((((safe_sub_func_uint32_t_u_u(g_134, ((safe_mod_func_int16_t_s_s(((((safe_mod_func_int8_t_s_s(g_121, (*l_280))) >= 0U) == ((0xF0BC <= (*l_242)) >= 0)) && (safe_rshift_func_int16_t_s_s(0x868B, (safe_lshift_func_uint8_t_u_u(g_8, (*l_242)))))), 65535U)) & g_236))) & (*l_280)) | 0x5BB58BC3))
            { /* block id: 129 */
                uint8_t l_301 = 3U;
                (*l_242) = (((-10) || (p_3 < g_223.f2)) || (safe_add_func_uint16_t_u_u((((*l_261) == &g_144) & (g_134 || g_8)), (safe_lshift_func_int16_t_s_u((safe_mod_func_int32_t_s_s((-1), ((0U | g_172) || l_301))), p_3)))));
            }
            else
            { /* block id: 131 */
                struct S0 l_302 = {255U,1,3675};
                struct S0 *l_303 = &g_223;
                (*l_303) = l_302;
                l_280 = &l_48;
            }
        }
    }
    (*l_242) = p_3;
    (*g_104) = &l_48;
    l_242 = (*g_104);
    return g_223.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_172 g_145.f2 g_121 g_145.f0 g_145.f1 g_104 g_105 g_54 g_134
 * writes: g_172 g_104 g_105 g_223 g_121 g_54
 */
static int32_t  func_16(int32_t  p_17, int32_t  p_18, uint8_t  p_19)
{ /* block id: 71 */
    int8_t l_201 = 0xC0;
    struct S0 l_234 = {0x62,1,2385};
    for (g_172 = (-3); (g_172 >= (-4)); g_172 = safe_sub_func_int8_t_s_s(g_172, 7))
    { /* block id: 74 */
        int32_t **l_199 = &g_105;
        int32_t ***l_200 = &g_104;
        (*l_200) = l_199;
    }
    if (((l_201 <= ((((safe_rshift_func_int8_t_s_s((0x76E4515C ^ ((((((safe_add_func_uint32_t_u_u(((g_145.f2 <= (safe_sub_func_uint16_t_u_u(65530U, 0x895D))) && p_18), (safe_lshift_func_uint16_t_u_u(g_121, 14)))) > (safe_lshift_func_int8_t_s_s((p_18 | (safe_div_func_int32_t_s_s(0x5331A3B0, l_201))), p_19))) && g_145.f0) | (-5)) >= 0xACCF6335) ^ p_19)), g_172)) > l_201) | l_201) || g_145.f1)) && l_201))
    { /* block id: 77 */
        int32_t ***l_214 = &g_104;
        int32_t ***l_215 = &g_104;
        struct S0 *l_222 = &g_223;
        p_18 = (l_214 != l_215);
        (**l_215) = (*g_104);
        if ((safe_add_func_int32_t_s_s((~(safe_rshift_func_uint16_t_u_u(((+(***l_215)) >= ((void*)0 == l_222)), ((&g_105 == (void*)0) ^ ((**l_215) == &p_18))))), (safe_mod_func_int16_t_s_s((((((!(safe_mod_func_uint32_t_u_u((safe_lshift_func_int16_t_s_u((!(safe_sub_func_uint16_t_u_u((0xBB944C1B != (((*l_215) == &g_105) > p_18)), 0xFA3B))), l_201)), l_201))) & (***l_215)) & 0) > g_134) || (-1)), p_17)))))
        { /* block id: 80 */
            (*l_222) = l_234;
        }
        else
        { /* block id: 82 */
            (**l_214) = &p_18;
        }
    }
    else
    { /* block id: 85 */
        (*g_105) = (**g_104);
    }
    return p_17;
}


/* ------------------------------------------ */
/* 
 * reads : g_104 g_105 g_134
 * writes: g_105 g_134
 */
static int32_t  func_20(int32_t  p_21, int16_t  p_22, int16_t  p_23, int32_t  p_24)
{ /* block id: 43 */
    int32_t *l_160 = &g_121;
    uint32_t l_161 = 0U;
    struct S0 l_194 = {255U,1,2842};
    struct S0 *l_195 = &l_194;
    uint32_t l_196 = 0x563820F0;
    (*g_104) = (*g_104);
    for (p_24 = 0; (p_24 <= 14); ++p_24)
    { /* block id: 47 */
        uint32_t l_188 = 0U;
        struct S1 **l_191 = &g_146;
        struct S1 ***l_192 = (void*)0;
        struct S1 ***l_193 = &l_191;
        for (g_134 = 0; (g_134 >= 42); ++g_134)
        { /* block id: 50 */
            int8_t l_183 = 0x66;
            uint32_t l_185 = 0x9E523DBD;
            struct S1 l_186 = {472,1383,-45485};
            int32_t *l_187 = (void*)0;
        }
        (*l_193) = l_191;
    }
    (*l_195) = l_194;
    return l_196;
}


/* ------------------------------------------ */
/* 
 * reads : g_54 g_8 g_104 g_105 g_121 g_134 g_144 g_146
 * writes: g_54 g_121 g_8 g_105 g_145
 */
static int16_t  func_30(uint8_t  p_31, uint32_t  p_32, int8_t  p_33)
{ /* block id: 4 */
    int32_t *l_53 = &g_54;
    struct S1 l_153 = {27,510,-2921};
    l_53 = func_49(l_53, (*l_53), g_54);
    (*g_144) = l_153;
    (**g_104) = ((safe_rshift_func_int16_t_s_s(g_121, 9)) > g_134);
    return g_134;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_38(int32_t  p_39)
{ /* block id: 2 */
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads : g_54 g_8 g_104 g_105 g_121 g_134 g_144 g_146 g_172
 * writes: g_54 g_121 g_8 g_105 g_145
 */
static int32_t * func_49(int32_t * p_50, int32_t  p_51, int16_t  p_52)
{ /* block id: 5 */
    uint16_t l_59 = 0x54C3;
    int32_t *l_66 = &g_54;
    int32_t **l_151 = (void*)0;
    int32_t *l_152 = (void*)0;
    (*l_66) = (((p_51 ^ (safe_rshift_func_uint8_t_u_s(p_51, ((safe_rshift_func_uint8_t_u_s(l_59, func_38((safe_rshift_func_int16_t_s_s(p_51, (((&p_51 != &p_51) <= (safe_rshift_func_int16_t_s_u((l_66 == &p_51), 13))) | (&g_54 != &g_54))))))) | 0xFEA44E0C)))) <= (*l_66)) && (*l_66));
    l_151 = func_67(p_52, ((safe_sub_func_int8_t_s_s((safe_sub_func_int32_t_s_s(func_38((*l_66)), (0x51 < func_38(((*l_66) != (safe_lshift_func_int8_t_s_u(func_76(g_54), 6))))))), (safe_lshift_func_uint16_t_u_s((g_144 == g_146), (*l_66))))) ^ p_51));
    return l_152;
}


/* ------------------------------------------ */
/* 
 * reads : g_146 g_121
 * writes: g_145 g_121
 */
static int32_t ** func_67(int16_t  p_68, uint32_t  p_69)
{ /* block id: 29 */
    struct S1 l_147 = {425,221,-33531};
    (*g_146) = l_147;
    for (g_121 = (-21); (g_121 != (-21)); g_121 = safe_add_func_uint32_t_u_u(g_121, 5))
    { /* block id: 33 */
        int32_t **l_150 = &g_105;
        return l_150;
    }
    return &g_105;
}


/* ------------------------------------------ */
/* 
 * reads : g_54 g_8 g_104 g_105 g_121 g_134 p_24 l_265 l_48 g_172
 * writes: g_121 g_8 g_105
 */
static int8_t  func_76(uint32_t  p_77)
{ /* block id: 7 */
    uint16_t l_84 = 0U;
    int32_t *l_89 = &g_54;
    struct S1 l_140 = {-253,1222,19695};
    if ((safe_mod_func_int16_t_s_s((((safe_add_func_uint8_t_u_u(l_84, (safe_rshift_func_int8_t_s_s(2, 4)))) & func_87(l_89)) == ((((safe_lshift_func_int16_t_s_u(((-7) <= (!0U)), 7)) & ((safe_rshift_func_uint8_t_u_s((+(g_54 == g_8)), 4)) != (((g_54 || p_77) >= g_8) == p_77))) > 0) == 0xCB)), (-1))))
    { /* block id: 10 */
        int32_t **l_99 = &l_89;
        int8_t l_119 = 0xA8;
        int32_t *l_120 = &g_121;
        (*l_99) = l_89;
        (*l_120) = (safe_rshift_func_uint16_t_u_s((safe_sub_func_int16_t_s_s((((void*)0 != g_104) || (**l_99)), (*l_89))), (g_8 < (safe_div_func_int8_t_s_s(((p_77 || (*l_89)) <= (safe_sub_func_uint32_t_u_u((((safe_add_func_uint32_t_u_u((safe_lshift_func_int8_t_s_u(((((~g_54) >= ((safe_add_func_int32_t_s_s((((safe_add_func_int16_t_s_s(l_119, g_8)) == (**g_104)) | 0xC2FE0EC9), 1)) | g_54)) <= g_8) & (-1)), 5)), (*l_89))) & g_54) | g_54), 0x773A67FE))), (**l_99))))));
        (*l_120) = (safe_add_func_uint32_t_u_u(((safe_lshift_func_int8_t_s_s((g_121 && (safe_rshift_func_uint16_t_u_s((((0x98ED | (safe_sub_func_int16_t_s_s(0x9412, 0x1A55))) || (safe_rshift_func_int16_t_s_u((p_77 > ((*l_120) <= 6U)), (safe_sub_func_int32_t_s_s((((((&l_89 == (void*)0) != p_77) != (-7)) && g_134) <= (**l_99)), 0x57B567EB))))) == (*l_89)), 3))), g_134)) <= 0x9A6A910B), (**g_104)));
    }
    else
    { /* block id: 14 */
        struct S1 *l_141 = &l_140;
        for (g_8 = 0; (g_8 != 42); g_8 = safe_add_func_int32_t_s_s(g_8, 3))
        { /* block id: 17 */
            for (l_84 = 28; (l_84 == 37); l_84 = safe_add_func_int32_t_s_s(l_84, 7))
            { /* block id: 20 */
                int32_t *l_139 = &g_121;
                (*g_104) = l_139;
                return g_54;
            }
            if (p_77)
                break;
        }
        (*l_141) = l_140;
    }
    return (*l_89);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_87(int32_t * p_88)
{ /* block id: 8 */
    int32_t l_90 = 0;
    return l_90;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_8;
    csmith_sink_ = g_54;
    csmith_sink_ = g_121;
    csmith_sink_ = g_134;
    csmith_sink_ = g_145.f0;
    csmith_sink_ = g_145.f1;
    csmith_sink_ = g_145.f2;
    csmith_sink_ = g_172;
    csmith_sink_ = g_223.f0;
    csmith_sink_ = g_223.f1;
    csmith_sink_ = g_223.f2;
    csmith_sink_ = g_236;
    csmith_sink_ = g_329;
    csmith_sink_ = g_332;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 67
   depth: 1, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 19
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 0
   indirect level: 4, occurrence: 1
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 4
breakdown:
   indirect level: 0, occurrence: 4
XXX times a bitfields struct's address is taken: 7
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 8
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 16

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 105
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 58

XXX times a variable address is taken: 70
XXX times a pointer is dereferenced on RHS: 54
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 11
   depth: 3, occurrence: 8
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 52
breakdown:
   depth: 1, occurrence: 37
   depth: 2, occurrence: 4
   depth: 3, occurrence: 10
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 166

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 184
   level: 2, occurrence: 53
   level: 3, occurrence: 27
   level: 4, occurrence: 9
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 31
XXX number of pointers point to scalars: 20
XXX number of pointers point to structs: 7
XXX percent of pointers has null in alias set: 20.7
XXX average alias set size: 1.24

XXX times a non-volatile is read: 384
XXX times a non-volatile is write: 153
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 89
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 24
   depth: 2, occurrence: 17
   depth: 3, occurrence: 13
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1

XXX percentage a fresh-made variable is used: 21.4
XXX percentage an existing variable is used: 78.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

