/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --jumps --no-longlong --force-non-uniform-arrays --math64 --muls --packed-struct --paranoid --pointers --no-structs --inline-function --return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      3817054696
 */


#define NO_LONGLONG

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_10 = 0xEEE2FDE2;
static int32_t g_18 = 0x779C63C4;
static int32_t g_31 = (-9);
static int32_t *g_30[4] = {&g_31,&g_31,&g_31,&g_31};
static uint16_t g_59 = 0U;
static uint8_t g_65 = 0x16;
static int32_t g_82 = (-1);
static int32_t g_94 = 0x900EB00D;
static uint8_t g_95[1] = {0x0D};
static uint16_t *g_101 = &g_59;
static uint16_t **g_100[2] = {&g_101,&g_101};
static uint16_t ***g_99 = &g_100[1];
static uint32_t g_127 = 3U;
static int32_t *g_154 = &g_94;
static int16_t g_164 = 0x45E5;
static int32_t * const *g_176 = &g_30[3];
static int32_t * const **g_175 = &g_176;
static int8_t g_200 = 0x5A;
static int16_t g_282 = 1;
static uint16_t ****g_294 = &g_99;
static uint16_t *****g_293 = &g_294;
static uint32_t g_329 = 0x3A66112E;
static int16_t *g_340 = &g_164;
static int16_t **g_339 = &g_340;
static int16_t ***g_338 = &g_339;
static int32_t g_349[9] = {1,1,0x36738FE2,1,1,0x36738FE2,1,1,0x36738FE2};
static int32_t *g_348 = &g_349[3];


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_1(void);
inline static int32_t  func_2(int32_t  p_3, int16_t  p_4, int32_t  p_5, int16_t  p_6, int8_t  p_7);
inline static uint32_t  func_14(uint32_t  p_15, int8_t  p_16);
inline static int32_t * func_19(uint8_t  p_20, int8_t  p_21);
static uint32_t  func_23(uint32_t  p_24, const int32_t  p_25, int32_t  p_26);
inline static uint32_t  func_27(int32_t * p_28, uint16_t  p_29);
inline static int32_t ** func_33(int32_t ** p_34);
static int32_t ** func_35(int32_t ** p_36);
inline static int32_t  func_41(int32_t ** p_42, int32_t ** p_43, int16_t  p_44, int32_t * p_45, uint32_t  p_46);
static int32_t  func_52(uint16_t  p_53, uint16_t  p_54, int32_t * p_55, int32_t  p_56, int32_t ** p_57);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_10 g_30 g_31 g_175 g_82 g_176 g_59 g_154 g_164 g_348 g_329 g_94 g_99 g_100 g_101
 * writes: g_18 g_31 g_59 g_30 g_338 g_176 g_94 g_339 g_154 g_82 g_349
 */
inline static uint16_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_11 = 8U;
    int32_t *l_17 = &g_18;
    int32_t l_32[9][8][3] = {{{1,0xE3D4752E,0x57F39CEE},{0xC84A4E7F,0xBBD4856C,(-1)},{0xBA8DAD4F,(-1),1},{0xB0881DDA,1,0xD3CC114F},{(-1),0x51807356,(-2)},{9,9,0x3649D959},{(-2),(-9),1},{0xC5533F2A,0xA77D77FC,0x9B4AF7BD}},{{0x51807356,0xADD33D73,0x28033590},{0x3649D959,0xC5533F2A,0x9B4AF7BD},{(-10),0x2FC9AEB9,(-9)},{0xCB296AD9,0,9},{0xDF39F3C5,(-9),0x1BA52B33},{0xB0881DDA,1,9},{0x51807356,1,0x9E520C3D},{0x07374FD5,0xCB296AD9,0x07374FD5}},{{0x3EEDA781,0,1},{0x3649D959,0x7216709E,0xC5533F2A},{1,(-1),(-1)},{1,0xC0F1FA6F,(-5)},{1,(-2),0xDF39F3C5},{0x3649D959,0xF0EF2F37,0x7216709E},{0x3EEDA781,0x093AF8EF,0x83398963},{0x07374FD5,0x4A104ACD,0}},{{0x51807356,1,0},{0xB0881DDA,0xA77D77FC,0xA77D77FC},{0xDF39F3C5,1,0x2FC9AEB9},{0xCB296AD9,0x9B4AF7BD,0xC58F5537},{(-10),0xE3D4752E,0x28033590},{9,9,0xB0881DDA},{0x57F39CEE,0xE3D4752E,1},{0xD3CC114F,0x9B4AF7BD,1}},{{0x1BA52B33,1,0x4938140A},{0x8E5161E3,0xA77D77FC,(-8)},{0x83398963,1,0},{0xA77D77FC,0x4A104ACD,1},{0x093AF8EF,0x093AF8EF,0xBA8DAD4F},{1,0xF0EF2F37,0xCB296AD9},{(-1),(-2),1},{0x4A104ACD,0xC0F1FA6F,0xBBD4856C}},{{0xBA8DAD4F,(-1),1},{0x5F7A0D7C,0x7216709E,0xCB296AD9},{(-9),0,0xBA8DAD4F},{0xC58F5537,0xCB296AD9,1},{(-1),1,0},{0xF0EF2F37,1,(-8)},{0x4938140A,(-9),0x4938140A},{0x41311E2D,0,1}},{{0,0x2FC9AEB9,1},{5,0xD3CC114F,0xB0881DDA},{1,1,0x28033590},{5,0xC84A4E7F,0xC58F5537},{0,0x51807356,0x2FC9AEB9},{0x41311E2D,0x8E5161E3,0xA77D77FC},{0x4938140A,0x57F39CEE,0},{0xF0EF2F37,0xC5533F2A,0}},{{(-1),0x83398963,0x83398963},{0xC58F5537,5,0x7216709E},{(-9),0xADD33D73,0xDF39F3C5},{0x5F7A0D7C,(-2),(-5)},{0xBA8DAD4F,0,(-1)},{0x4A104ACD,(-2),0xC5533F2A},{(-1),0xADD33D73,1},{1,5,0x07374FD5}},{{0x093AF8EF,0x83398963,0x9E520C3D},{0xA77D77FC,0xC5533F2A,9},{0x83398963,0x57F39CEE,0x1BA52B33},{0x8E5161E3,0x8E5161E3,9},{0x1BA52B33,0x51807356,(-9)},{0xD3CC114F,0xC84A4E7F,0xC0F1FA6F},{0x57F39CEE,1,9},{9,0xD3CC114F,0xC0F1FA6F}}};
    int32_t **l_347[6][2] = {{&g_30[3],&g_30[3]},{&g_30[3],&g_30[3]},{&g_30[3],&g_154},{&g_30[3],&g_30[3]},{&g_154,&g_30[3]},{&g_30[3],&g_154}};
    int i, j, k;
    (*l_17) = func_2(((safe_mod_func_int32_t_s_s(1, g_10)) || g_10), l_11, ((*l_17) = (safe_lshift_func_int16_t_s_u((func_14(g_10, g_10) ^ l_11), 5))), ((g_154 = func_19((~((func_23(func_27(g_30[3], l_32[6][6][1]), g_10, g_82) & 0) || 0xF1)), l_11)) != g_348), g_329);
    /* statement id: 249 */
    //assert (g_30[0] == dangling || g_30[0] == &g_31);
    //assert (g_338 == dangling);
    return (***g_99);
}


/* ------------------------------------------ */
/* 
 * reads : g_82 g_154 g_30 g_31 g_94 g_348
 * writes: g_82 g_94 g_30 g_349
 */
inline static int32_t  func_2(int32_t  p_3, int16_t  p_4, int32_t  p_5, int16_t  p_6, int8_t  p_7)
{ /* block id: 238 */
    int8_t l_355 = (-2);
    for (g_82 = (-19); (g_82 > 4); g_82 = safe_add_func_int8_t_s_s(g_82, 3))
    { /* block id: 241 */
        int32_t **l_353 = &g_30[0];
        (*g_154) = (~p_3);
        (*l_353) = &p_5;
        if ((**l_353))
            continue;
        if ((*g_154))
            break;
    }
    /* facts after for loop */
    //assert (g_30[0] == &p_5 || g_30[0] == &g_31);
    (*g_348) = (!l_355);
    return p_7;
    /* statement id: 248 */
    //assert (g_30[0] == dangling || g_30[0] == &g_31);
}


/* ------------------------------------------ */
/* 
 * reads : g_10
 * writes:
 */
inline static uint32_t  func_14(uint32_t  p_15, int8_t  p_16)
{ /* block id: 1 */
    return g_10;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_339
 */
inline static int32_t * func_19(uint8_t  p_20, int8_t  p_21)
{ /* block id: 234 */
    int16_t **l_344 = &g_340;
    int16_t ***l_345 = (void*)0;
    int16_t ***l_346 = &g_339;
    (*l_346) = l_344;
    return &g_94;
    /* statement id: 236 */
    //assert (func_19_rv == &g_94);
}


/* ------------------------------------------ */
/* 
 * reads : g_176 g_30 g_59 g_175 g_154 g_164
 * writes: g_30 g_31 g_94
 */
static uint32_t  func_23(uint32_t  p_24, const int32_t  p_25, int32_t  p_26)
{ /* block id: 229 */
    int32_t **l_341[6] = {&g_30[3],&g_30[3],&g_30[0],&g_30[3],&g_30[3],&g_30[0]};
    int32_t **l_342 = &g_30[2];
    int i;
    (*l_342) = (*g_176);
    (*g_154) = ((***g_175) = (!g_59));
    return g_164;
}


/* ------------------------------------------ */
/* 
 * reads : g_31 g_59 g_30 g_175
 * writes: g_31 g_59 g_30 g_338 g_176
 */
inline static uint32_t  func_27(int32_t * p_28, uint16_t  p_29)
{ /* block id: 4 */
    (*p_28) = ((p_28 != (void*)0) >= 0x32DC);
    (*g_175) = func_33(func_35(&g_30[3]));
    /* statement id: 227 */
    //assert (g_338 == dangling);
    return p_29;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_338
 */
inline static int32_t ** func_33(int32_t ** p_34)
{ /* block id: 223 */
    int16_t **l_334 = (void*)0;
    int16_t ***l_333[7] = {&l_334,&l_334,&l_334,&l_334,&l_334,&l_334,&l_334};
    int16_t ****l_335 = &l_333[1];
    int16_t ****l_336 = (void*)0;
    int16_t ****l_337 = (void*)0;
    int i;
    g_338 = ((*l_335) = l_333[1]);
    /* statement id: 225 */
    assert (g_338 == &l_334);
    return &g_30[3];
    /* statement id: 226 */
    //assert (g_338 == dangling);
    //assert ((func_33_rv >= &g_30[0] && func_33_rv <= &g_30[3]));
}


/* ------------------------------------------ */
/* 
 * reads : g_31 g_59 g_30
 * writes: g_31 g_59 g_30
 */
static int32_t ** func_35(int32_t ** p_36)
{ /* block id: 6 */
    uint8_t l_39 = 255U;
    uint16_t l_51 = 65534U;
    int32_t *l_79 = &g_31;
    int16_t *l_153 = (void*)0;
    uint32_t l_246 = 0U;
lbl_330:
    for (g_31 = 0; (g_31 == 13); ++g_31)
    { /* block id: 9 */
        int32_t l_40[7][4] = {{0xDC0AC77A,(-1),(-8),0xDC0AC77A},{0x1BC642EE,0xA8F302D7,0x1BC642EE,(-8)},{0x340421A1,0xA8F302D7,(-4),0xDC0AC77A},{0xA8F302D7,(-1),(-1),0xA8F302D7},{0x1BC642EE,0xDC0AC77A,(-1),(-8)},{0xA8F302D7,0x340421A1,(-4),0x340421A1},{0x340421A1,(-1),0x1BC642EE,0x340421A1}};
        uint16_t *l_58[6][3][6] = {{{&g_59,&l_51,&l_51,&l_51,&l_51,&g_59},{&g_59,&l_51,&l_51,&g_59,&l_51,&g_59},{&g_59,&l_51,&g_59,&g_59,&l_51,&g_59}},{{&g_59,&l_51,&g_59,&g_59,&l_51,&g_59},{&g_59,&l_51,&g_59,&l_51,&l_51,&g_59},{&g_59,&l_51,&l_51,&l_51,&l_51,&g_59}},{{&g_59,&l_51,&l_51,&g_59,&l_51,&g_59},{&g_59,&l_51,&g_59,&g_59,&l_51,&g_59},{&g_59,&l_51,&g_59,&g_59,&l_51,&g_59}},{{&g_59,&l_51,&g_59,&l_51,&l_51,&g_59},{&g_59,&l_51,&l_51,&l_51,&l_51,&g_59},{&g_59,&l_51,&l_51,&g_59,&l_51,&g_59}},{{&g_59,&l_51,&g_59,&g_59,&l_51,&g_59},{&g_59,&l_51,&g_59,&g_59,&l_51,&g_59},{&g_59,&l_51,&g_59,&l_51,&l_51,&g_59}},{{&g_59,&l_51,&l_51,&l_51,&l_51,&g_59},{&g_59,&l_51,&l_51,&g_59,&l_51,&g_59},{&g_59,&l_51,&g_59,&g_59,&l_51,&g_59}}};
        uint8_t *l_63 = (void*)0;
        uint8_t *l_64 = &g_65;
        int32_t *l_66 = &g_31;
        int32_t l_77 = (-10);
        uint16_t *l_93 = &l_51;
        int32_t l_114 = 0x4F6C93EC;
        uint16_t **l_159 = &l_58[3][2][4];
        int16_t **l_283 = &l_153;
        int i, j, k;
        l_40[1][3] = l_39;
        if (l_39)
            goto lbl_330;
    }
    for (g_59 = (-26); (g_59 < 38); g_59 = safe_add_func_int8_t_s_s(g_59, 5))
    { /* block id: 214 */
        for (l_39 = 0; (l_39 <= 3); l_39 += 1)
        { /* block id: 217 */
            int i;
            g_30[l_39] = g_30[l_39];
            if ((**p_36))
                break;
        }
    }
    return &g_30[3];
    /* statement id: 222 */
    //assert ((func_35_rv >= &g_30[0] && func_35_rv <= &g_30[3]));
}


/* ------------------------------------------ */
/* 
 * reads : g_30 g_31
 * writes:
 */
inline static int32_t  func_41(int32_t ** p_42, int32_t ** p_43, int16_t  p_44, int32_t * p_45, uint32_t  p_46)
{ /* block id: 32 */
    return (**p_43);
}


/* ------------------------------------------ */
/* 
 * reads : g_30 g_31
 * writes: g_30
 */
static int32_t  func_52(uint16_t  p_53, uint16_t  p_54, int32_t * p_55, int32_t  p_56, int32_t ** p_57)
{ /* block id: 13 */
    int32_t *l_67 = &g_31;
    uint32_t l_72 = 4294967290U;
    (*p_57) = l_67;
    for (p_56 = 3; (p_56 >= 0); p_56 -= 1)
    { /* block id: 17 */
        return (**p_57);
    }
    for (p_54 = 0; (p_54 <= 3); p_54 += 1)
    { /* block id: 22 */
        int32_t **l_69 = &l_67;
        int32_t ***l_68 = &l_69;
        int i;
        (*l_68) = &g_30[p_54];
        /* statement id: 23 */
        assert ((l_69 >= &g_30[0] && l_69 <= &g_30[3]));
        g_30[p_54] = &g_31;
    }
    for (p_56 = (-15); (p_56 < (-27)); p_56 = safe_sub_func_uint8_t_u_u(p_56, 7))
    { /* block id: 28 */
        (*p_57) = (*p_57);
    }
    return l_72;
}




/* ---------------------------------------- */
int main (void)
{
    int i;
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    for (i = 0; i < 4; i++)
        g_30[i] = 0;
    g_338 = 0;
    csmith_sink_ = g_10;
    csmith_sink_ = g_18;
    csmith_sink_ = g_31;
    csmith_sink_ = g_59;
    csmith_sink_ = g_65;
    csmith_sink_ = g_82;
    csmith_sink_ = g_94;
    for (i = 0; i < 1; i++)
    {
        csmith_sink_ = g_95[i];
    }
    csmith_sink_ = g_127;
    csmith_sink_ = g_164;
    csmith_sink_ = g_200;
    csmith_sink_ = g_282;
    csmith_sink_ = g_329;
    for (i = 0; i < 9; i++)
    {
        csmith_sink_ = g_349[i];
    }
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 74
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 42
   depth: 2, occurrence: 9
   depth: 3, occurrence: 2
   depth: 24, occurrence: 1

XXX total number of pointers: 80

XXX times a variable address is taken: 123
XXX times a pointer is dereferenced on RHS: 62
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 8
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 61
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 0
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 426

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 226
   level: 2, occurrence: 53
   level: 3, occurrence: 17
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 42
XXX number of pointers point to scalars: 38
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22.5
XXX average alias set size: 1.31

XXX times a non-volatile is read: 317
XXX times a non-volatile is write: 185
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 38
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 11
   depth: 2, occurrence: 2

XXX percentage a fresh-made variable is used: 20.7
XXX percentage an existing variable is used: 79.3
********************* end of statistics **********************/

