/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-unions --safe-math --no-argc --no-volatiles --no-volatile-pointers --no-arrays --no-bitfields --no-checksum --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --jumps --longlong --no-force-non-uniform-arrays --no-math64 --no-muls --packed-struct --no-paranoid --pointers --structs --no-inline-function --return-structs --arg-structs --no-dangling-global-pointers
 * Seed:      4233935744
 */

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   int8_t  f1;
   int8_t  f2;
   int32_t  f3;
   uint8_t  f4;
   int8_t  f5;
   int32_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_8 = 0x7FE64FD9L;
static int32_t *g_10 = (void*)0;
static int32_t g_47 = (-6L);
static struct S0 g_50 = {-1L,0xFFL,0x89L,0L,0xB6L,0xB2L,0xAA9634D7L};
static int8_t g_65 = 0x0EL;
static int32_t *g_70 = &g_47;
static int32_t **g_87 = &g_70;
static int32_t ***g_86 = &g_87;
static int16_t g_98 = 0xCE32L;
static uint8_t g_99 = 248UL;
static int32_t ****g_176 = &g_86;
static int32_t *****g_175 = &g_176;
static int32_t g_181 = 0xA0E29635L;


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_1(void);
static int32_t * func_2(uint32_t  p_3, int8_t  p_4, int32_t * p_5, int32_t  p_6, int32_t * p_7);
static int32_t  func_11(int32_t * p_12, uint32_t  p_13, int32_t  p_14, int32_t * p_15, int8_t  p_16);
static int32_t * func_17(uint32_t  p_18, uint32_t  p_19);
static int32_t ** func_20(int32_t ** p_21, int32_t ** p_22, uint32_t  p_23, int32_t * p_24);
static int32_t ** func_25(int32_t * p_26, int32_t  p_27, uint32_t  p_28, int32_t * p_29);
static int32_t * func_34(struct S0  p_35, int32_t * p_36);
static struct S0  func_37(int32_t  p_38, int32_t ** p_39);
static int32_t  func_40(uint8_t  p_41);
static int32_t * func_42(int8_t  p_43);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_10 g_50 g_47 g_65 g_86 g_87 g_70 g_98 g_99 g_175
 * writes: g_50 g_47 g_70 g_65 g_87
 */
static struct S0  func_1(void)
{ /* block id: 0 */
    int32_t l_9 = 0xA18E418AL;
    int32_t *l_177 = (void*)0;
    uint16_t l_178 = 0x06C0L;
    int32_t *l_180 = &g_181;
    struct S0 l_182 = {8L,0x1DL,-5L,-9L,255UL,-1L,-4L};
    l_177 = func_2(g_8, l_9, g_10, func_11(func_17(l_9, l_9), ((g_99 && (+(((g_175 == (void*)0) & g_99) != l_9))) < 0x43F8L), l_9, l_177, l_178), l_180);
    return l_182;
}


/* ------------------------------------------ */
/* 
 * reads : g_87 g_70
 * writes: g_70
 */
static int32_t * func_2(uint32_t  p_3, int8_t  p_4, int32_t * p_5, int32_t  p_6, int32_t * p_7)
{ /* block id: 71 */
    (*g_87) = (*g_87);
    return p_5;
}


/* ------------------------------------------ */
/* 
 * reads : g_86 g_87 g_50.f5
 * writes: g_70
 */
static int32_t  func_11(int32_t * p_12, uint32_t  p_13, int32_t  p_14, int32_t * p_15, int8_t  p_16)
{ /* block id: 68 */
    int32_t *l_179 = &g_50.f0;
    (**g_86) = l_179;
    return g_50.f5;
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_8 g_50 g_47 g_65 g_86 g_87 g_70 g_98 g_99
 * writes: g_50 g_47 g_70 g_65 g_87
 */
static int32_t * func_17(uint32_t  p_18, uint32_t  p_19)
{ /* block id: 1 */
    int16_t l_30 = 0x9A13L;
    int32_t **l_71 = &g_10;
    (*g_86) = func_20(func_25(g_10, l_30, (safe_unary_minus_func_uint32_t_u((safe_add_func_uint16_t_u_u(g_8, 0x894FL)))), func_34(func_37(func_40(l_30), l_71), (*l_71))), l_71, g_98, (*l_71));
    return (*l_71);
}


/* ------------------------------------------ */
/* 
 * reads : g_50.f5 g_50.f6 g_50.f4 g_70 g_86 g_87 g_65 g_99 g_50.f1 g_98 g_50
 * writes: g_70 g_47 g_50
 */
static int32_t ** func_20(int32_t ** p_21, int32_t ** p_22, uint32_t  p_23, int32_t * p_24)
{ /* block id: 55 */
    int32_t ****l_147 = &g_86;
    int32_t *****l_146 = &l_147;
    struct S0 *l_152 = &g_50;
    int32_t l_171 = 0x0C9BFB87L;
    (*p_21) = (void*)0;
    (*l_146) = &g_86;
    if (((safe_add_func_uint32_t_u_u((safe_div_func_uint16_t_u_u(p_23, (-7L))), ((l_152 != &g_50) & (g_50.f5 > g_50.f6)))) != (((g_50.f4 & (g_50.f4 < (65526UL || 0x54A4L))) < 9L) <= g_50.f5)))
    { /* block id: 58 */
        int32_t **l_153 = &g_70;
        return l_153;
    }
    else
    { /* block id: 60 */
        int8_t l_162 = 0xA9L;
        int32_t l_172 = 0xF531248EL;
        int32_t *l_173 = &g_47;
        (**g_86) = (*p_21);
        (*l_173) = ((((safe_lshift_func_int16_t_s_s(p_23, (safe_add_func_uint32_t_u_u((safe_lshift_func_uint8_t_u_u(g_65, 1)), (0UL <= (safe_add_func_int32_t_s_s(g_99, (0L == (l_162 | (safe_rshift_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u((safe_sub_func_int16_t_s_s(0L, ((safe_add_func_uint32_t_u_u(g_50.f1, ((((p_23 ^ g_50.f4) && l_171) || l_172) <= g_98))) ^ 0x55567A96L))), l_162)) >= 0UL), p_23))))))))))) | p_23) == 65535UL) <= l_162);
        (*l_152) = (*l_152);
    }
    return (***l_146);
}


/* ------------------------------------------ */
/* 
 * reads : g_50.f6 g_87 g_86 g_50.f1 g_47 g_99
 * writes: g_50.f6 g_70
 */
static int32_t ** func_25(int32_t * p_26, int32_t  p_27, uint32_t  p_28, int32_t * p_29)
{ /* block id: 35 */
    int32_t *l_124 = &g_47;
    int32_t **l_145 = &g_70;
    for (g_50.f6 = (-13); (g_50.f6 <= 22); g_50.f6++)
    { /* block id: 38 */
        int16_t l_125 = 0xD4BBL;
        uint8_t l_144 = 0x66L;
        (*g_87) = l_124;
        if (l_125)
            continue;
        if (l_125)
        { /* block id: 41 */
            struct S0 l_126 = {0x71CFEE84L,0xA1L,0x9BL,0x52D78A3DL,1UL,0x7CL,1L};
            struct S0 *l_127 = &l_126;
            (**g_86) = &p_27;
            (*l_127) = l_126;
        }
        else
        { /* block id: 44 */
            int32_t ***l_137 = (void*)0;
            if (((+(&p_29 == (*g_86))) & (safe_mod_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_u(0x16L, 0)), (((0x3DL > (safe_add_func_uint8_t_u_u((((((safe_sub_func_uint32_t_u_u(g_50.f1, (&g_87 != l_137))) < (safe_rshift_func_int16_t_s_s(((0xA7L != (safe_div_func_uint8_t_u_u((safe_mod_func_uint16_t_u_u((((*l_124) && l_144) & (-1L)), g_99)), p_27))) <= g_50.f6), l_144))) < 1L) > 0xB3CABD61L) < (*l_124)), (*l_124)))) ^ 8L) ^ p_28)))))
            { /* block id: 45 */
                return (*g_86);
            }
            else
            { /* block id: 47 */
                (**g_86) = (void*)0;
            }
            (*g_87) = &p_27;
        }
        (*g_87) = (void*)0;
    }
    return l_145;
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_87 g_70 g_86
 * writes: g_47 g_70 g_87
 */
static int32_t * func_34(struct S0  p_35, int32_t * p_36)
{ /* block id: 30 */
    int32_t l_111 = 0xE2C54351L;
    uint32_t l_120 = 0xB5B285EFL;
    int32_t l_121 = 0x7DE593F2L;
    (**g_87) = (safe_add_func_int16_t_s_s((p_35.f4 ^ 0xF43EL), (((-6L) > ((safe_rshift_func_uint8_t_u_u(((safe_mod_func_int16_t_s_s((~(safe_mod_func_uint16_t_u_u(l_111, (safe_add_func_uint8_t_u_u((safe_div_func_uint8_t_u_u(((l_111 & (safe_sub_func_uint16_t_u_u(g_47, 65526UL))) < (safe_rshift_func_int16_t_s_u((((&g_50 == &p_35) | l_111) != l_120), 11))), p_35.f2)), l_120))))), p_35.f4)) & (-1L)), l_121)) < 1L)) >= l_120)));
    (**g_86) = &l_121;
    (*g_86) = (*g_86);
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads : g_65 g_86 g_87 g_70 g_47 g_10 g_98 g_50.f6 g_99 g_50.f5 g_8 g_50
 * writes: g_65 g_47 g_70
 */
static struct S0  func_37(int32_t  p_38, int32_t ** p_39)
{ /* block id: 20 */
    struct S0 *l_72 = &g_50;
    struct S0 **l_73 = &l_72;
    int32_t l_76 = (-3L);
    (*l_73) = l_72;
    for (g_65 = 11; (g_65 <= (-13)); g_65--)
    { /* block id: 24 */
        int32_t **l_79 = &g_70;
        (**l_79) = ((l_76 || (safe_lshift_func_int16_t_s_u(((void*)0 == l_79), 12))) < (((safe_rshift_func_uint8_t_u_s((safe_rshift_func_int16_t_s_s((((safe_lshift_func_int8_t_s_u((p_39 == (void*)0), (g_86 == (void*)0))) || (l_76 >= ((*g_86) != (void*)0))) < l_76), 4)), p_38)) || (***g_86)) != l_76));
        (*g_87) = func_42(((safe_div_func_int32_t_s_s(((safe_rshift_func_int8_t_s_s(((p_38 || (p_38 == (((void*)0 == (*p_39)) >= 0xB4E1L))) <= (safe_rshift_func_int8_t_s_u(((0x3086L && ((((safe_add_func_uint8_t_u_u(((*p_39) != (*g_87)), (g_98 ^ g_50.f6))) != g_99) >= 7UL) & g_50.f5)) | l_76), 2))), 0)) < g_65), (*g_70))) == g_65));
        (**l_79) = (g_50.f6 || (safe_div_func_int8_t_s_s(g_8, p_38)));
    }
    return (**l_73);
}


/* ------------------------------------------ */
/* 
 * reads : g_50 g_47 g_65 g_8
 * writes: g_50 g_47 g_70
 */
static int32_t  func_40(uint8_t  p_41)
{ /* block id: 2 */
    int32_t *l_49 = &g_47;
    int32_t **l_48 = &l_49;
    struct S0 *l_51 = (void*)0;
    struct S0 *l_52 = &g_50;
    (*l_48) = func_42(p_41);
    (*l_52) = g_50;
    for (g_50.f5 = 0; (g_50.f5 == (-15)); g_50.f5 = safe_sub_func_uint16_t_u_u(g_50.f5, 5))
    { /* block id: 10 */
        int32_t **l_56 = &l_49;
        if (((~(((void*)0 != l_56) || (safe_div_func_uint8_t_u_u((((safe_lshift_func_uint8_t_u_s(g_50.f5, (**l_48))) != (((safe_sub_func_int32_t_s_s((p_41 != ((p_41 > ((safe_rshift_func_uint16_t_u_u((g_65 & (safe_add_func_int32_t_s_s(1L, (safe_mod_func_int32_t_s_s((**l_48), p_41))))), g_8)) == 0x11L)) < (**l_56))), 0x435D7D23L)) != (*l_49)) ^ g_50.f3)) >= 1L), p_41)))) <= (**l_56)))
        { /* block id: 11 */
            (*l_56) = func_42(g_65);
        }
        else
        { /* block id: 13 */
            (*l_56) = &g_47;
            (*l_49) = 0x33686A8EL;
        }
        g_70 = (*l_56);
    }
    return g_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_42(int8_t  p_43)
{ /* block id: 3 */
    int32_t **l_44 = &g_10;
    int32_t ***l_45 = &l_44;
    int32_t *l_46 = &g_47;
    (*l_45) = l_44;
    return l_46;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_8;
    csmith_sink_ = g_47;
    csmith_sink_ = g_50.f0;
    csmith_sink_ = g_50.f1;
    csmith_sink_ = g_50.f2;
    csmith_sink_ = g_50.f3;
    csmith_sink_ = g_50.f4;
    csmith_sink_ = g_50.f5;
    csmith_sink_ = g_50.f6;
    csmith_sink_ = g_65;
    csmith_sink_ = g_98;
    csmith_sink_ = g_99;
    csmith_sink_ = g_181;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 3
XXX total union variables: 0

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 5
   depth: 3, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1

XXX total number of pointers: 46

XXX times a variable address is taken: 36
XXX times a pointer is dereferenced on RHS: 26
breakdown:
   depth: 1, occurrence: 19
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 27
breakdown:
   depth: 1, occurrence: 19
   depth: 2, occurrence: 8
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 88

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 42
   level: 2, occurrence: 21
   level: 3, occurrence: 6
   level: 4, occurrence: 5
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 20
XXX number of pointers point to scalars: 21
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 32.6
XXX average alias set size: 1.11

XXX times a non-volatile is read: 173
XXX times a non-volatile is write: 67
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 49
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 13
   depth: 2, occurrence: 7
   depth: 3, occurrence: 2

XXX percentage a fresh-made variable is used: 20.8
XXX percentage an existing variable is used: 79.2
********************* end of statistics **********************/

